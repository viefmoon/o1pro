# Especificación Técnica para Frontend Expo React Native – Proceso de Generación de Especificación

Eres un arquitecto de software experto encargado de crear especificaciones técnicas detalladas para la parte Frontend de aplicaciones utilizando React Native con Expo. Tus especificaciones serán utilizadas como entrada directa para sistemas AI de planificación y generación de código, por lo que deben ser precisas, estructuradas y completas.

## Requerimientos Iniciales

### 1. Requerimiento del Proyecto

Primero, revisa cuidadosamente el requerimiento del proyecto:

```plaintext
<project_request>
# Sistema de Gestión Integral para Restaurantes

## Descripción del Proyecto
Sistema móvil que permite gestionar todos los aspectos operativos de un restaurante o negocio de comida. La solución abarca desde la administración de órdenes, mesas, menú, empleados, reservas, reportes y facturación, hasta la realización de pedidos vía WhatsApp potenciados por inteligencia artificial.

Principales componentes:
- **Multitenancy**: cada restaurante (tenant) podrá operar de forma independiente y personalizar su propia configuración.
- Gestión de órdenes (creación, actualización, cancelación, programación y sincronización).
- Control de mesas y áreas.
- Manejo del menú (con categorías, subcategorías, artículos con imágenes, variantes, modificadores e ingredientes).
- Autenticación y roles (mediante JWT).
- Notificaciones y sincronización en tiempo real (usando WebSockets).
- Integración con impresoras térmicas para impresión de tickets.
- **Sincronización de una base de datos local con Supabase** (funcionamiento offline con respaldo periódico).
- **Integración de pagos** con Stripe y Clip (cada restaurante con su propia cuenta) y manejo de efectivo.
- Generación de resúmenes, reportes y facturación para la administración.
- Reservas de mesas y gestión de eventos.
- Gestión de empleados (check-in/checkout, control de ausencias, asignación de roles, cálculo de sueldos).
- Pedidos vía WhatsApp con IA (Gemini) para procesar texto, audios e interacciones.
- **Pantallas de preparación** (bar, cocina, etc.) configurables según se asocien a categorías o productos.

## Público Objetivo
- Restaurantes, bares, cafeterías y negocios de comida que buscan optimizar sus operaciones y mejorar la coordinación entre áreas.
- Negocios que desean una solución exclusivamente móvil para la gestión de órdenes, inventario, empleados, reservas y facturación.
- Empresas que buscan innovar en la toma de pedidos, incorporando la recepción automatizada de pedidos vía WhatsApp potenciada por IA.
- Empresas interesadas en licenciar esta plataforma a múltiples restaurantes dentro de una misma infraestructura (multitenant).

## Características Deseadas

### Gestión de Órdenes
- [ ] Crear, actualizar y cancelar órdenes
  - [ ] Soporte para órdenes dine-in, delivery y pickup (con filtrado de vista por cada tipo).
  - [ ] Inclusión de múltiples ítems por orden.
  - [ ] Gestión de ajustes (descuentos, cargos adicionales).
  - [ ] Seguimiento del estado de la orden en tiempo real.
  - [ ] Manejo de propinas (opcional).
    - [ ] Configuración regional de impuestos y propinas.
  - [ ] **Programar órdenes** para un horario específico (ej. pedidos futuros).
    - [ ] Distinción visual de órdenes programadas (se muestran ocultas en la vista principal y cuentan con una sección dedicada para su gestión).
    - [ ] Alerta temprana al personal antes del horario de la orden programada, mostrada en pantallas de preparación.
- [ ] **Formas de pago**
  - [ ] **Clip** para cobros presenciales (integración con lectores físicos).
  - [ ] **Efectivo** para pagos en el local.
  - [ ] **Stripe** para pagos online (delivery y pickup).
- [ ] **Descuentos**
  - [ ] Posibilidad de asignar descuentos a artículos específicos o a la orden completa.
  - [ ] Descuentos definidos como monto fijo o porcentaje.
  - [ ] Estos descuentos se reflejan automáticamente en el total de la orden y en la facturación final.
- [ ] **Estatus de productos y órdenes**
  - [ ] Cada producto (ítem de orden) tendrá un estatus de preparación (pendiente, en preparación, listo, entregado, etc.).
  - [ ] El estatus global de la orden dependerá de los estatus de todos sus ítems (ej. una orden se considera “completada” cuando todos los productos estén listos/entregados).

### Pantallas de Preparación (Cocina/Bar/etc.)
- [ ] Creación dinámica de pantallas según sea necesario (bar, parrilla, postres, etc.), asociadas a productos, categorías o subcategorías.
- [ ] Visualización de las órdenes y productos pendientes, en preparación y completados.
- [ ] Actualización de estados de los productos (ej. "en preparación", "listo").
- [ ] **Alertas de tiempo** (un único umbral global para el restaurante) cuando un producto o una orden exceda el tiempo configurado.
- [ ] Filtrar u ordenar las órdenes según categorías o tiempo de espera.
- [ ] Notificaciones al personal de servicio cuando un pedido esté listo.

### Control de Mesas y Áreas
- [ ] Gestión de mesas y áreas (salón, bar, etc.)
  - [ ] Asignación de mesas a órdenes.
  - [ ] Seguimiento de mesas disponibles y ocupadas.
  - [ ] Capacidad para combinar y dividir mesas.

### Manejo del Menú
- [ ] Gestión de productos y categorías
  - [ ] Creación y administración de categorías y subcategorías.
  - [ ] Configuración de artículos con imágenes, descripciones y precios.
  - [ ] Definición de variantes y modificadores (ingredientes extra, quitar ingredientes).
  - [ ] Gestión de inventario (stock) a nivel de artículo y variante.
  - [ ] Opciones de menú dinámicas para temporadas o eventos especiales.
- [ ] **Personalización por restaurante** (tenant)
  - [ ] Personalizar menú, colores, logos y otros aspectos de marca de forma independiente.

### Roles y Autenticación
- [ ] Sistema de autenticación basado en JWT
  - [ ] Definición de roles (administrador, mesero, chef de pizza, chef de hamburguesa, bar, etc.).
  - [ ] Control de acceso y permisos basado en roles.
  - [ ] Registro y recuperación de contraseña.

### Gestión de Empleados, Turnos y Sueldos
- [ ] Registro y administración de empleados
  - [ ] Asignación de roles y permisos.
  - [ ] Check-in/Check-out (control de asistencia).
  - [ ] Gestión de ausencias y reportes de inasistencias.
  - [ ] Visualización y asignación de horarios y turnos.
  - [ ] Cálculo automático de horas trabajadas para nómina.
- [ ] **Cálculo de sueldos**
  - [ ] Cada empleado tiene un sueldo base asignado.
  - [ ] Cálculo del sueldo en base a turnos trabajados, descuentos (ausencias, retardos) y extras (bonos, comisiones, etc.).
  - [ ] Generación de un reporte de sueldos por período (semanal, quincenal, mensual).
  - [ ] Opción de visualizar los totales y conceptos para cada empleado.

### Reservas y Gestión de Eventos
- [ ] Sistema de reservas de mesas
  - [ ] Reservas online a través de la aplicación o vía web.
  - [ ] Gestión de disponibilidad de mesas y horarios.
  - [ ] Confirmación y recordatorios automáticos de reservas.
- [ ] Gestión opcional de eventos y promociones
  - [ ] Creación y difusión de ofertas o promociones especiales.
  - [ ] Registro de inscripciones/confirmaciones de asistencia a eventos.

### Reportes, Resúmenes y Facturación
- [ ] Generación de reportes y resúmenes
  - [ ] Reportes de ventas (diarios, semanales, mensuales).
  - [ ] Reportes de órdenes (completadas, canceladas, en curso).
  - [ ] Reportes de inventario y consumo de productos.
  - [ ] Reportes de asistencia y turnos de personal.
  - [ ] Exportación en formatos PDF o CSV.
  - [ ] Herramientas de analítica (tendencias de ventas, productos más vendidos).
- [ ] **Sistema de Facturación por Restaurante**
  - [ ] Configuración de datos fiscales para cada tenant.
  - [ ] Generación de facturas y comprobantes.
  - [ ] Control de numeración de facturas por restaurante.
  - [ ] Conciliación de pagos (Stripe, Clip / Métodos offline).

### Integración de Pagos
- [ ] **Stripe** (online)
  - [ ] Soporte para pagos en línea (delivery y pickup).
  - [ ] Gestión de transacciones y conciliación de pagos.
  - [ ] Manejo de reembolsos y cancelaciones parciales.
- [ ] **Clip** (pagos en sitio)
  - [ ] Conexión a lectores de tarjetas Clip para cobros presenciales.
  - [ ] Generar la operación de cobro desde la app y recibir confirmación de pago en tiempo real.
  - [ ] Cada restaurante utilizará su propia cuenta de Clip.
  - [ ] Manejo de errores o fallas de lector en tiempo real.
- [ ] **Efectivo** (pagos en sitio)

### Gestión de Base de Datos y Sincronización
- [ ] Base de datos local en la aplicación móvil
  - [ ] Funcionamiento 100% offline.
  - [ ] Sincronización periódica (configurable) con Supabase para respaldo y actualización centralizada.
  - [ ] Resolución de conflictos de datos conservando la última edición y registrando el historial de cambios asociados a cada usuario.
  - [ ] No se contemplan datos sensibles más allá de la autenticación.

### Notificaciones y Sincronización en Tiempo Real
- [ ] Integración de WebSockets para actualizar el estado de órdenes y notificaciones en tiempo real.
  - [ ] Notificaciones push a usuarios (por rol) para pedidos nuevos o cambios de estado.
  - [ ] Alertas al personal de cocina o bar cuando se crea o modifica una orden relevante.

### Pedidos vía WhatsApp con IA
- [ ] Recepción de Pedidos por WhatsApp
  - [ ] Integración con línea de WhatsApp Business ya existente.
  - [ ] Verificación del webhook con token de verificación.
  - [ ] Módulo de gestión de la cuenta de WhatsApp Business.
- [ ] Procesamiento Automatizado de Mensajes
  - [ ] Procesamiento de mensajes de texto para extraer la intención y detalles del pedido.
  - [ ] Transcripción de mensajes de audio utilizando modelos como Whisper y/o Gemini.
  - [ ] Manejo de mensajes interactivos (botones y listas) para confirmar, modificar o cancelar pedidos.
- [ ] Integración de Agentes de IA
  - [ ] Utilización de múltiples agentes (Router, Order Mapper, Query) que analizan y procesan la información del pedido.
  - [ ] Extracción y mapeo de productos del menú mediante similitud textual y normalización.
  - [ ] Módulo de entrenamiento y mejora continua de modelos (feedback loop).
- [ ] Gestión de Flujo y Control
  - [ ] Encolamiento de mensajes por cliente para procesarlos secuencialmente.
  - [ ] Control de tasa de mensajes (rate limiting) para prevenir abusos o spam.
  - [ ] Envío de notificaciones y mensajes de confirmación (ej. bienvenida, resúmenes de pedido, errores).
- [ ] **Almacenamiento de conversaciones y auditoría**
  - [ ] Guardar historial de conversaciones de WhatsApp para referencia y monitoreo.
  - [ ] Interfaz con filtros (fecha, número de teléfono, palabras clave) para revisar las conversaciones.
  - [ ] Posibilidad de enviar mensajes directamente desde la app al WhatsApp del cliente.
- [ ] Integración con Otros Módulos
  - [ ] Pedidos recibidos por WhatsApp se integran con la gestión de órdenes y el sistema de pagos.
  - [ ] Permitir a los clientes actualizar su información de entrega mediante OTP o enlaces de verificación.

### Seeders y Configuración
- [ ] Scripts de inicialización de la base de datos
  - [ ] Inserción de datos básicos (productos, roles, mesas, usuarios).
  - [ ] Configuración inicial de parámetros (impuestos, propinas, zonas de reparto).

### Monitoreo y Mantenimiento (Sugerido)
- [ ] Dashboard interno para monitorear el estado del sistema.
  - [ ] Alertas en caso de falla de sincronización o caída de servicios.
  - [ ] Métricas de rendimiento (tiempo de respuesta, uso de CPU, memoria).
- [ ] Logs de actividad
  - [ ] Registro de operaciones importantes (creación/edición de órdenes, inicios de sesión).
  - [ ] Integración con herramientas de monitoreo (Datadog, New Relic, etc.) (opcional).

## Requerimientos de Diseño
- [ ] **Diseño con tema oscuro y claro** (opciones de personalización a nivel de usuario o de restaurante).
- [ ] Interfaz intuitiva y responsiva, optimizada para dispositivos móviles.
  - [ ] Diseño adaptativo para diversas resoluciones de pantalla (iOS y Android).
- [ ] Arquitectura escalable y modular basada en NestJS (backend) y React Native (frontend).
- [ ] Soporte completo para funcionamiento offline y sincronización asíncrona con Supabase.
- [ ] Experiencia de usuario enfocada en la rapidez y simplicidad (especialmente en entornos de alta rotación).
- [ ] Integración con características nativas de móvil (notificaciones push, acceso a GPS, cámara para escanear códigos QR, etc.).
- [ ] Consideraciones de accesibilidad (contraste, tamaños de fuente, compatibilidad con lectores de pantalla).
- [ ] **Personalización visual** para cada restaurante (colores, logos, estilos).

## Otras Notas
- No se requiere cumplimiento específico de leyes de protección de datos más allá de buenas prácticas para credenciales.
- El módulo de pedidos vía WhatsApp potencia el proceso de toma de pedidos con texto, audio e interacciones automatizadas.
- Se prevé una arquitectura multitenant para alojar múltiples restaurantes en la misma plataforma, cada uno con su propio sistema de facturación y configuración.
- Se recomienda planificar la infraestructura para alta escalabilidad y resiliencia (posible uso de contenedores Docker o servicios cloud).

</project_request>
```

### 2. Technical Specification del Backend

Antes de continuar, revisa cuidadosamente la especificación técnica del backend:

```plaintext
<technical_specification>
<specification_planning>

# Arquitectura central del sistema y flujos de trabajo clave

## Propuesta de Arquitectura
- Arquitectura modular y escalable donde cada dominio (órdenes, menús, empleados, etc.) se maneja a través de módulos NestJS independientes
- Capa de persistencia con enfoque multi-tenant
  - Cada restaurante (tenant) identificado mediante tenantId
  - Manejo vía esquema en base de datos u otra lógica (ej: tabla Restaurant/Tenant)
  - TenantId referenciado en principales entidades

## Flujos de Trabajo Principales
- Creación/gestión de órdenes (dine-in, delivery, pickup)
- Manejo de menú y disponibilidad de productos  
- Control de mesas y áreas del restaurante
- Reservas y eventos
- Gestión de empleados (turnos, sueldos)
- Procesamiento de pedidos vía WhatsApp con IA
- Integración con pasarelas de pago (Stripe, Clip, efectivo)
- Sincronización offline con Supabase
- Reportes y facturación

# Estructura y organización del proyecto NestJS

## Principios de Organización
- Módulo por Dominio
- Carpeta auth para autenticación/roles
- Carpeta database para configuración/migraciones  
- Carpeta common/utils para utilidades

## Estructura por Módulo
- Esquema hexagonal con:
  - Carpeta domain
  - Carpeta dto
  - Carpeta infrastructure
    - Relational repository
    - Mappers
    - Entidades TypeORM
  - Service como orquestador principal

# Especificaciones detalladas de endpoints y servicios

## Auth
- Rutas:
  - Registro
  - Login
  - Refresh token
  - Logout
  - Confirmación de email
- JWT con roles y guards

## Orders
- Endpoints:
  - Crear
  - Actualizar
  - Cancelar
  - Programar
  - Listar
  - Filtrar
- Soporte múltiples estados (pendiente, en preparación, listo, entregado)

## Mesas
- CRUD completo
- Asignación a órdenes
- Combinación y división

## Menú
- CRUD de:
  - Categorías
  - Subcategorías  
  - Productos
- Manejo de:
  - Variantes
  - Modificadores
  - Ingredientes
- Control de stock

## Pagos
- Integración:
  - Stripe
  - Clip
  - Efectivo
- Endpoints:
  - Iniciar pago
  - Capturar pago
  - Reembolsos

## Reservas
- CRUD completo
- Notificaciones de recordatorio

## Empleados
- CRUD completo
- Gestión de:
  - Roles
  - Check-in/out
  - Cálculo de sueldos
  - Reportes de asistencia

## Reportes/Facturación
- Resúmenes de ventas
- Reportes de inventario y consumo
- Exportación CSV/PDF

## WhatsApp con IA
- Webhook para recibir mensajes
- Procesamiento con IA:
  - Router
  - Order Mapper
  - Query
- Mensajes de confirmación
- Notificaciones de cambios

## Offline Sync
- Endpoints para sincronización con Supabase

# Diseño de esquema de base de datos

## Base de datos
- PostgreSQL/Relacional
- Tablas principales:
  - Restaurant
  - User
  - Role
  - Status
  - Product
  - Category
  - Order
  - Payment
  - Reservation
  - Table
- TenantId en cada tabla
- Llaves foráneas e índices optimizados

# Implementación de DTOs y entidades

## Por Módulo
- DTOs:
  - Create
  - Update
  - Query/Filter
- Entidades TypeORM en infrastructure/persistence/relational/entities
- Mappers entre entidades y objetos de dominio

# Implementación de autenticación y autorización

- JWT Strategy
- Refresh Token Strategy
- Guards basados en roles
- Decoradores @Roles()

# Validación y transformación de datos

- Class-validator y class-transformer en DTOs
- Interceptores para:
  - Serialization
  - Conversión de campos

# Estrategia de manejo de errores

- HttpException
- Exception Filters
- Formato estándar de respuesta de error

# Implementación de logging y monitoreo

- Logger global NestJS
- Integración con plataforma de monitoreo
- Notificaciones de:
  - Fallas en pagos
  - Fallas de sincronización

# Estrategia de pruebas

## Unitarias
- Jest
- Mock de servicios externos

## E2E
- Contenedores Docker
- Base de datos efímera
- Cobertura de endpoints principales

# Configuración Final

- Dependencias en package.json
- Scripts de migraciones y seeds
- Documentación swagger
- Pipeline CI

# Áreas que Requieren Clarificación

- Approach multi-tenant exacto
- Manejo e infraestructura de IA
- Detalles API WhatsApp Business
- Configuración Supabase

</specification_planning>
# Especificación Técnica Backend NestJS - Sistema de Gestión Integral para Restaurantes

## 1. Resumen del Sistema
El Sistema de Gestión Integral para Restaurantes provee funcionalidad para manejar todos los aspectos operativos de un negocio de comida. Integra la administración de órdenes, mesas, menú, reservas, empleados, facturación y pagos, así como la recepción automatizada de pedidos vía WhatsApp con IA.

**Incluye:**

- **Gestión de Órdenes:** (dine-in, delivery, pickup) con seguimiento de estatus en tiempo real.
- **Control de Mesas y Áreas:** (salón, bar, etc.), reservas y eventos.
- **Manejo de Menú:** con categorías, subcategorías, variantes y modificadores.
- **Gestión de Empleados:** roles, turnos, sueldos y asistencias.
- **Pagos:** mediante Stripe y Clip (además de efectivo), con integración de facturación.
- **Módulo Offline:** con sincronización a Supabase.
- **Pedidos vía WhatsApp:** con procesamiento de texto y audio usando IA.

**Arquitectura:**

- Arquitectura modular de NestJS siguiendo principios hexagonales (domain, infrastructure, application).
- Enfoque multi-tenant: cada restaurante (tenant) puede personalizar su configuración y menú.
- Soporte de notificaciones en tiempo real (WebSockets) y uso de PostgreSQL con TypeORM.

## 2. Estructura del Proyecto NestJS
Se propone la siguiente organización de carpetas:

```
src/
  app.module.ts
  main.ts
  auth/
    auth.module.ts
    auth.controller.ts
    auth.service.ts
    strategies/
    dto/
    ...
  orders/
    orders.module.ts
    orders.controller.ts
    orders.service.ts
    domain/
    dto/
    infrastructure/
  tables/
    tables.module.ts
    ...
  menu/
    menu.module.ts
    ...
  payments/
    payments.module.ts
    ...
  reservations/
    reservations.module.ts
    ...
  employees/
    employees.module.ts
    ...
  reports/
    reports.module.ts
    ...
  whatsapp/
    whatsapp.module.ts
    ...
  shared/
    filters/
    interceptors/
    pipes/
    decorators/
    ...
  database/
    config/
    migrations/
    seeds/
    ...
  utils/
    ...
```

- **app.module.ts:** Coordina la importación de todos los submódulos.
- **Módulos de dominio:** auth, orders, tables, menu, payments, reservations, employees, reports, whatsapp.
- **Módulo shared/utils:** Contiene lógica reutilizable (filtros de excepciones, transformadores, pipes).
- **Módulo database:** Configuración y servicios de TypeORM, migraciones y seeds.

*Nota:* Se utilizará la convención de nomenclatura PascalCase para módulos, controladores y servicios; y camelCase para métodos, variables y propiedades.

## 3. Especificación de API
A continuación se definen los módulos y sus endpoints principales. *Nota:* Todos los endpoints se prefijan con `/api/v1` (o la versión que aplique).

### 3.1 Auth Module
**Descripción:** Encargado de la autenticación de usuarios, manejo de roles y recuperación de contraseñas.

**Endpoints:**

- **POST /auth/email/register**  
  Registra un nuevo usuario en el sistema.  
  _Body:_ `AuthRegisterLoginDto { email, password, firstName, lastName, ... }`
  
- **POST /auth/email/login**  
  Realiza login y retorna token, refreshToken, tokenExpires, y datos del usuario.
  
- **POST /auth/refresh**  
  Renueva el token de acceso.  
  _Auth Header:_ `Bearer <refreshToken>`
  
- **GET /auth/me**  
  Devuelve datos del usuario logeado.  
  _Auth Header:_ `Bearer <token>`
  
- **PATCH /auth/me**  
  Actualiza datos del usuario logeado (ej.: cambio de password, update de foto).
  
- **POST /auth/forgot/password**  
  Solicita cambio de contraseña, enviando un email con enlace.
  
- **POST /auth/reset/password**  
  Cambia la contraseña usando un hash temporal recibido por correo.
  
- **POST /auth/logout**  
  Invalida la sesión actual (elimina el refresh token).

**DTOs y Entidades:**

- **DTOs:** `AuthRegisterLoginDto`, `AuthEmailLoginDto`, `AuthUpdateDto`, etc.
- **Entidad:** `UserEntity` (campos: email, contraseña, provider, roleId, statusId, etc.)

**Validaciones:**

- Contraseñas con `MinLength(6)`.
- Email con `@IsEmail()`.

**Manejo de Errores:**

- 422 (Unprocessable Entity) si el email ya está registrado o el password es incorrecto.

### 3.2 Orders Module
**Descripción:** Gestiona la creación y actualización de órdenes, el estatus de preparación y la programación de pedidos futuros.

**Endpoints:**

- **POST /orders**  
  Crea una nueva orden.  
  _Body:_ `CreateOrderDto { items, type (dine-in/delivery/pickup), scheduledAt?, ... }`
  
- **GET /orders**  
  Lista todas las órdenes con paginación y filtros (por fecha, estado, etc.).
  
- **GET /orders/:id**  
  Retorna los detalles de una orden específica.
  
- **PATCH /orders/:id**  
  Actualiza la orden (ej.: cambiar estado, añadir items).
  
- **DELETE /orders/:id**  
  Cancela la orden.

**DTOs y Entidades:**

- **DTOs:** `CreateOrderDto`, `UpdateOrderDto`.
- **Entidad:** `OrderEntity` (campos: id, restaurantId, userId, total, scheduledAt, status, etc.)
- **Relación:** `OrderItemEntity`.

**Validaciones y Transformaciones:**

- Uso de `enum` para el tipo de orden (dine-in/delivery/pickup).
- El campo `scheduledAt` no puede ser una fecha pasada.

**Manejo de Errores:**

- 404 si la orden no existe.
- 422 si la orden ya está en estado "completado" y se intenta modificar.

### 3.3 Tables Module
**Descripción:** Control de mesas y áreas (combinación, división, asignación a órdenes, etc.).

**Endpoints:**

- **POST /tables**
- **GET /tables**
- **GET /tables/:id**
- **PATCH /tables/:id**
- **DELETE /tables/:id**
- **POST /tables/:id/merge** – Para combinar varias mesas en una.
- **POST /tables/:id/split** – Para dividir mesas.

### 3.4 Menu Module
**Descripción:** Manejo de categorías, subcategorías, productos, variantes, modificadores y stock.

**Endpoints:**

- **POST /menu/categories**
- **GET /menu/categories**
- **POST /menu/categories/:id/products**
- **GET /menu/products** – Permite filtrar por categoría, disponibilidad, etc.
- **PATCH /menu/products/:id**
- **DELETE /menu/products/:id**

### 3.5 Payments Module
**Descripción:** Integra Clip, Stripe y efectivo. Permite iniciar o capturar pagos y gestionar reembolsos.

**Endpoints:**

- **POST /payments/intent** – Crea un intent de pago (Stripe).
- **POST /payments/clip** – Procesa un cobro con Clip (en sitio).
- **POST /payments/cash** – Marca el pago como efectivo.
- **POST /payments/refund** – Solicita reembolso en Stripe o Clip.

### 3.6 Reservations Module
**Descripción:** Manejo de reservas de mesas, confirmación y recordatorios automáticos.

**Endpoints:**

- **POST /reservations**
- **GET /reservations**
- **GET /reservations/:id**
- **PATCH /reservations/:id**
- **DELETE /reservations/:id**

### 3.7 Employees Module
**Descripción:** Alta y modificación de empleados, gestión de turnos, sueldos, roles y asistencias.

**Endpoints:**

- **POST /employees**
- **GET /employees**
- **GET /employees/:id**
- **PATCH /employees/:id**
- **DELETE /employees/:id**
- **POST /employees/:id/checkin**
- **POST /employees/:id/checkout**

### 3.8 Reports/Facturación Module
**Descripción:** Genera reportes de ventas, inventario, sueldos, conciliación de pagos y facturación.

**Endpoints:**

- **GET /reports/sales** (parámetros: rango de fechas, etc.)
- **GET /reports/employee**
- **GET /reports/inventory**
- **GET /reports/facturation**

### 3.9 WhatsApp + IA Module
**Descripción:** Módulo para recibir pedidos vía WhatsApp y procesarlos mediante IA (texto/audio).

**Endpoints:**

- **POST /whatsapp/webhook** – Recibe notificaciones de WhatsApp e integra agentes IA (ej.: LLM) para parsear y mapear a productos.
- **GET /whatsapp/conversations** – Devuelve el historial de conversaciones.
- **POST /whatsapp/:conversationId/send** – Envía mensaje al cliente desde la app.

## 4. Esquema de la Base de Datos

### 4.1 Entidades Principales

- **Restaurant (Tenant)**
  - id: string | uuid
  - name: string
  - logo: string (opcional)
  - ...

- **User**
  - id: number (auto)
  - email: string | null
  - password: string
  - provider: enum (email, google, etc.)
  - roleId: FK → Role
  - statusId: FK → Status
  - tenantId: FK → Restaurant (para multi-tenant)
  - deletedAt: Date (soft delete)

- **Role**
  - id: number
  - name: string

- **Status**
  - id: number
  - name: string (active/inactive)

- **Order**
  - id: number
  - tenantId: FK → Restaurant
  - userId: FK → User (quién creó)
  - tableId: FK → Table (opcional)
  - scheduledAt: Date (si es pedido futuro)
  - status: enum (pending, preparing, etc.)
  - total: number
  - deletedAt: Date

- **OrderItem**
  - id: number
  - orderId: FK → Order
  - productId: FK → Product
  - quantity: number
  - price: number
  - deletedAt: Date

- **Table**
  - id: number
  - tenantId: FK → Restaurant
  - name: string
  - area: string (ej.: “salón”, “terraza”)
  - deletedAt: Date

- **Product**
  - id: number
  - tenantId: FK → Restaurant
  - name: string
  - price: number
  - stock: number
  - categoryId: FK → Category
  - photoId: FK → File (opcional)
  - deletedAt: Date

- **Category**
  - id: number
  - tenantId: FK → Restaurant
  - name: string

- **Reservation**
  - id: number
  - tenantId: FK → Restaurant
  - tableId: FK → Table
  - startTime: Date
  - endTime: Date
  - customerName: string
  - deletedAt: Date

- **Payment**
  - id: number
  - orderId: FK → Order
  - method: enum (stripe, clip, cash)
  - amount: number
  - status: enum (captured, refunded, etc.)
  - deletedAt: Date

- **Employee**
  - id: number
  - tenantId: FK → Restaurant
  - name: string
  - role: string (chef, mesero, etc.)
  - salary: number
  - deletedAt: Date

*Nota:* Cada entidad puede incluir índices para `tenantId`, `email`, etc., para mejorar el rendimiento.

## 5. Servicios y Lógica de Negocio

### 5.1 Servicios Core

- **AuthService**
  - Métodos: `validateLogin()`, `register()`, `refreshToken()`, `logout()`.
  - Manejo de tokens JWT y refresh tokens.

- **OrdersService**
  - Métodos: `createOrder()`, `updateOrder()`, `cancelOrder()`, `findAll()`, `findById()`.
  - Lógica de validación de horarios y estados de la orden.

- **TablesService**
  - Métodos para crear, actualizar y eliminar mesas, incluyendo `mergeTables()` y `splitTables()`.

- **MenuService**
  - Métodos: `createCategory()`, `createProduct()`, `updateProductStock()`, etc.

- **PaymentsService**
  - Métodos: `createPaymentIntent()`, `processClipPayment()`, `markCashPayment()`, `refund()`.
  - Manejo de APIs externas (Stripe, Clip).

- **ReservationsService**
  - CRUD de reservas y validación de disponibilidad de mesa.

- **EmployeesService**
  - CRUD de empleados, control de check-in/out y cálculo de nómina.

- **ReportsService**
  - Generación de reportes (ventas, inventario, sueldos) y exportación en CSV/PDF.

- **WhatsAppService**
  - Procesamiento de mensajes entrantes: encolamiento, parseo con IA y creación de órdenes.
  - Envío de mensajes de confirmación.

**Manejo de Casos de Error:**

- Se lanza `HttpException` con códigos 404, 422, 409, etc., según el caso.
- Uso de custom exceptions para conflictos de negocio (ej.: mesa ya ocupada).

## 6. Autenticación y Autorización

**Estrategia:**

- Uso de dos estrategias de JWT: una para token de acceso y otra para token de refresco.
- Roles y Guards: Decorador `@Roles(RoleEnum.admin)` y guard que valida si `request.user.role.id` coincide.

**Implementación:**

- `JwtStrategy` y `JwtRefreshStrategy` ubicados en `auth/strategies`.
- Definidos en `auth.module.ts` e inyectados en `AuthService`.

**Middleware:**

- Aplicación del guard `AuthGuard('jwt')` en rutas protegidas.
- Validación de roles mediante `RolesGuard`.

## 7. Validación y Transformación

- **class-validator:**  
  Cada DTO utiliza decorators como `@IsString()`, `@IsNotEmpty()`, `@IsEnum()`, etc.

- **class-transformer:**  
  Uso de transformaciones (por ejemplo, `@Transform(lowerCaseTransformer)`) y exclusión de campos sensibles con `@Exclude`.

- **Pipes e Interceptores:**  
  Implementación de un `ValidationPipe` global y de interceptores para logging y formateo.

## 8. Manejo de Errores

- **Filtros de Excepción:**  
  Se puede implementar un `HttpExceptionFilter` global para formatear la salida de errores.

- **Errores Personalizados:**  
  Clases que extienden `HttpException` para casos de negocio específicos.

- **Respuestas:**  
  Estructura JSON con `{ status, errors: { ... } }`.

## 9. Logging y Monitoreo

- **Logging:**  
  Uso del logger integrado de NestJS con niveles (log, error, warn) y posible integración con servicios externos (Datadog).

- **Monitoreo:**  
  Health checks en `/health` para verificar conectividad a la DB, Supabase, etc., y envío de alertas mediante Slack u otros canales.

## 10. Pruebas

### 10.1 Pruebas Unitarias

- **Configuración:**  
  Empleo de Jest y pruebas con mocks en la inyección de dependencias.
  
- **Casos de Ejemplo:**  
  - AuthService: validación de credenciales y manejo de tokens caducados.
  - OrdersService: creación de una orden con items vacíos y cancelación de orden en estado “completada”.

### 10.2 Pruebas E2E

- **Docker:**  
  Levantamiento de un contenedor con la base de datos y la aplicación.
  
- **Escenarios Principales:**  
  Registro y login, manipulación de órdenes, actualización de menú, reservas, etc.
  
- **Datos de Prueba:**  
  Seeds con usuarios (admin, user).

## 11. Documentación API

- **Swagger/OpenAPI:**  
  Configurado en `main.ts` mediante `SwaggerModule` y `DocumentBuilder`, documentando cada endpoint, DTO, parámetros y respuestas.
  
- **Convenciones:**  
  Inclusión de descripciones y ejemplos en los DTOs.
  
- **UI:**  
  La documentación accesible a través de `/docs`.

## 12. Despliegue y CI/CD

- **Entornos:**  
  Staging y Production, con variables de entorno para DB, JWT, etc.

- **Pipeline de CI/CD:**  
  Uso de GitHub Actions (por ejemplo, con un archivo `docker-e2e.yml`) para ejecutar lint, tests y pruebas E2E.

- **Despliegue:**  
  Utilización de contenedores Docker y ejecución automática de migraciones y seeds (o mediante script).

- **Infraestructura:**  
  Posible requerimiento de un orquestador (Kubernetes) u otra plataforma.

Esta especificación provee la guía para la implementación del backend NestJS con un enfoque modular, detallando la configuración multi-tenant, la lógica de órdenes, la integración de pagos y la sincronización offline, así como la interacción con WhatsApp e IA. Además, se incluyen validaciones y pruebas para garantizar la fiabilidad del sistema.
</technical_specification>
```

### 3. Plantilla Base para frontend

Finalmente, revisa cuidadosamente la plantilla base:

```plaintext
<starter_template>
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.eslintignore
.eslintrc.js
.gitignore
.prettierignore
.prettierrc
.repomix/bundles.json
app.config.ts
app.json
app/app.tsx
app/components/AutoImage.tsx
app/components/Button.tsx
app/components/Card.tsx
app/components/EmptyState.tsx
app/components/Header.tsx
app/components/Icon.tsx
app/components/index.ts
app/components/ListItem.tsx
app/components/ListView.tsx
app/components/Screen.tsx
app/components/Text.test.tsx
app/components/Text.tsx
app/components/TextField.tsx
app/components/Toggle/Checkbox.tsx
app/components/Toggle/index.ts
app/components/Toggle/Radio.tsx
app/components/Toggle/Switch.tsx
app/components/Toggle/Toggle.tsx
app/config/config.base.ts
app/config/config.dev.ts
app/config/config.prod.ts
app/config/index.ts
app/devtools/ReactotronClient.ts
app/devtools/ReactotronClient.web.ts
app/devtools/ReactotronConfig.ts
app/i18n/ar.ts
app/i18n/en.ts
app/i18n/es.ts
app/i18n/fr.ts
app/i18n/hi.ts
app/i18n/i18n.ts
app/i18n/index.ts
app/i18n/ja.ts
app/i18n/ko.ts
app/i18n/translate.ts
app/navigators/AppNavigator.tsx
app/navigators/index.ts
app/navigators/navigationUtilities.ts
app/screens/ErrorScreen/ErrorBoundary.tsx
app/screens/ErrorScreen/ErrorDetails.tsx
app/screens/index.ts
app/screens/WelcomeScreen.tsx
app/services/api/api.ts
app/services/api/api.types.ts
app/services/api/apiProblem.test.ts
app/services/api/apiProblem.ts
app/services/api/index.ts
app/theme/colors.ts
app/theme/colorsDark.ts
app/theme/index.ts
app/theme/spacing.ts
app/theme/spacingDark.ts
app/theme/styles.ts
app/theme/timing.ts
app/theme/typography.ts
app/utils/crashReporting.ts
app/utils/delay.ts
app/utils/formatDate.ts
app/utils/gestureHandler.native.ts
app/utils/gestureHandler.ts
app/utils/ignoreWarnings.ts
app/utils/openLinkInBrowser.ts
app/utils/storage/index.ts
app/utils/storage/storage.test.ts
app/utils/storage/storage.ts
app/utils/useAppTheme.ts
app/utils/useHeader.tsx
app/utils/useIsMounted.ts
app/utils/useSafeAreaInsetsStyle.ts
babel.config.js
docs/boilerplate/android.md
docs/boilerplate/app.json.md
docs/boilerplate/app/app.md
docs/boilerplate/app/app.tsx.md
docs/boilerplate/app/components/AutoImage.md
docs/boilerplate/app/components/Button.md
docs/boilerplate/app/components/Card.md
docs/boilerplate/app/components/Checkbox.md
docs/boilerplate/app/components/Components.md
docs/boilerplate/app/components/EmptyState.md
docs/boilerplate/app/components/Header.md
docs/boilerplate/app/components/Icon.md
docs/boilerplate/app/components/ListItem.md
docs/boilerplate/app/components/ListView.md
docs/boilerplate/app/components/Radio.md
docs/boilerplate/app/components/Screen.md
docs/boilerplate/app/components/Switch.md
docs/boilerplate/app/components/Text.md
docs/boilerplate/app/components/TextField.md
docs/boilerplate/app/config/Config.md
docs/boilerplate/app/devtools/Devtools.md
docs/boilerplate/app/i18n/Internationalization.md
docs/boilerplate/app/models/Models.md
docs/boilerplate/app/navigators/AppNavigator.tsx.md
docs/boilerplate/app/navigators/Navigation.md
docs/boilerplate/app/navigators/navigationUtilities.ts.md
docs/boilerplate/app/screens/Screens.md
docs/boilerplate/app/services/api.ts.md
docs/boilerplate/app/services/Services.md
docs/boilerplate/app/theme/colors.ts.md
docs/boilerplate/app/theme/spacing.ts.md
docs/boilerplate/app/theme/Theming.md
docs/boilerplate/app/theme/typography.ts.md
docs/boilerplate/app/utils/useAppTheme.tsx.md
docs/boilerplate/app/utils/useHeader.tsx.md
docs/boilerplate/app/utils/useSafeAreaInsetsStyle.ts.md
docs/boilerplate/app/utils/Utils.md
docs/boilerplate/assets.md
docs/boilerplate/Boilerplate.md
docs/boilerplate/eas.json.md
docs/boilerplate/ignite.md
docs/boilerplate/index.tsx.md
docs/boilerplate/ios.md
docs/boilerplate/maestro.md
docs/boilerplate/plugins/Plugins.md
docs/boilerplate/plugins/withSplashScreen.md
docs/boilerplate/test/Test.md
docs/cli/Ignite-CLI.md
docs/cli/Remove-Demo-Code.md
docs/cli/Troubleshooting.md
docs/concept/Concepts.md
docs/concept/Error-Boundary.md
docs/concept/Generator-Templates.md
docs/concept/Generators.md
docs/concept/MobX-State-Tree.md
docs/concept/Styling.md
docs/concept/Testing.md
docs/concept/TypeScript.md
docs/concept/Upgrades.md
docs/expo/CNG.md
docs/expo/DIY.md
docs/expo/EAS.md
docs/expo/Expo-and-Ignite.md
docs/Guide.md
eas.json
ignite/templates/component/NAME.tsx.ejs
ignite/templates/navigator/NAMENavigator.tsx.ejs
ignite/templates/screen/NAMEScreen.tsx.ejs
index.tsx
jest.config.js
metro.config.js
package.json
plugins/withSplashScreen.ts
README.md
test/i18n.test.ts
test/mockFile.ts
test/setup.ts
test/test-tsconfig.json
tsconfig.json
types/lib.es5.d.ts

================================================================
Files
================================================================

================
File: .eslintignore
================
node_modules
ios
android
.expo
.vscode
ignite/ignite.json
package.json
.eslintignore

================
File: .eslintrc.js
================
// https://docs.expo.dev/guides/using-eslint/
module.exports = {
  extends: [
    "plugin:@typescript-eslint/recommended",
    "plugin:react/recommended",
    "plugin:react-native/all",
    // `expo` must come after `standard` or its globals configuration will be overridden
    "expo",
    // `jsx-runtime` must come after `expo` or it will be overridden
    "plugin:react/jsx-runtime",
    "prettier",
  ],
  plugins: ["reactotron", "prettier"],
  rules: {
    "prettier/prettier": "error",
    // typescript-eslint
    "@typescript-eslint/array-type": 0,
    "@typescript-eslint/ban-ts-comment": 0,
    "@typescript-eslint/no-explicit-any": 0,
    "@typescript-eslint/no-unused-vars": [
      "error",
      {
        argsIgnorePattern: "^_",
        varsIgnorePattern: "^_",
      },
    ],
    "@typescript-eslint/no-var-requires": 0,
    "@typescript-eslint/no-require-imports": 0,
    "@typescript-eslint/no-empty-object-type": 0,
    // eslint
    "no-use-before-define": 0,
    "no-restricted-imports": [
      "error",
      {
        paths: [
          // Prefer named exports from 'react' instead of importing `React`
          {
            name: "react",
            importNames: ["default"],
            message: "Import named exports from 'react' instead.",
          },
        ],
      },
    ],
    // react
    "react/prop-types": 0,
    // react-native
    "react-native/no-raw-text": 0,
    // reactotron
    "reactotron/no-tron-in-production": "error",
    // eslint-config-standard overrides
    "comma-dangle": 0,
    "no-global-assign": 0,
    "quotes": 0,
    "space-before-function-paren": 0,
  },
}

================
File: .gitignore
================
# OSX
#
.DS_Store

# Xcode
#
build/
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3
xcuserdata
*.xccheckout
*.moved-aside
DerivedData
*.hmap
*.ipa
*.xcuserstate
ios/.xcode.env.local

# Android/IntelliJ
#
build/
.idea
.gradle
local.properties
*.iml
*.hprof
.cxx/

# node.js
#
node_modules/
npm-debug.log
yarn-error.log

# BUCK
buck-out/
\.buckd/
*.keystore
!debug.keystore

# fastlane
#
# It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the
# screenshots whenever they are needed.
# For more information about the recommended setup visit:
# https://docs.fastlane.tools/best-practices/source-control/

**/fastlane/report.xml
**/fastlane/Preview.html
**/fastlane/screenshots
**/fastlane/test_output

# Bundle artifact
*.jsbundle

# Ignite-specific items below
# You can safely replace everything above this comment with whatever is
# in the default .gitignore generated by React-Native CLI

# VS Code
.vscode

# Expo
.expo/*
bin/Exponent.app
/android
/ios
expo-env.d.ts

## Secrets
npm-debug.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*
web-build/

# Configurations
!env.js

/coverage

# Yarn
.yarn/*

================
File: .prettierignore
================
node_modules
ios
android
.expo
.vscode
ignite/ignite.json
package.json
.eslintignore

================
File: .prettierrc
================
{
  "printWidth": 100,
  "semi": false,
  "singleQuote": false,
  "trailingComma": "all",
  "quoteProps": "consistent"
}

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: app.config.ts
================
import { ExpoConfig, ConfigContext } from "@expo/config"

/**
 * Use ts-node here so we can use TypeScript for our Config Plugins
 * and not have to compile them to JavaScript
 */
require("ts-node/register")

/**
 * @param config ExpoConfig coming from the static config app.json if it exists
 *
 * You can read more about Expo's Configuration Resolution Rules here:
 * https://docs.expo.dev/workflow/configuration/#configuration-resolution-rules
 */
module.exports = ({ config }: ConfigContext): Partial<ExpoConfig> => {
  const existingPlugins = config.plugins ?? []

  return {
    ...config,
    plugins: [...existingPlugins, require("./plugins/withSplashScreen").withSplashScreen],
  }
}

================
File: app.json
================
{
  "name": "app",
  "displayName": "app",
  "expo": {
    "name": "app",
    "slug": "app",
    "scheme": "app",
    "version": "1.0.0",
    "orientation": "portrait",
    "userInterfaceStyle": "automatic",
    "icon": "./assets/images/app-icon-all.png",
    "updates": {
      "fallbackToCacheTimeout": 0
    },
    "newArchEnabled": false,
    "jsEngine": "hermes",
    "assetBundlePatterns": [
      "**/*"
    ],
    "android": {
      "icon": "./assets/images/app-icon-android-legacy.png",
      "package": "com.app",
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/app-icon-android-adaptive-foreground.png",
        "backgroundImage": "./assets/images/app-icon-android-adaptive-background.png"
      }
    },
    "ios": {
      "icon": "./assets/images/app-icon-ios.png",
      "supportsTablet": true,
      "bundleIdentifier": "com.app"
    },
    "web": {
      "favicon": "./assets/images/app-icon-web-favicon.png",
      "bundler": "metro"
    },
    "plugins": [
      "expo-localization",
      "expo-font",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/app-icon-android-adaptive-foreground.png",
          "imageWidth": 300,
          "resizeMode": "contain",
          "backgroundColor": "#191015"
        }
      ]
    ],
    "experiments": {
      "tsconfigPaths": true
    },
    "extra": {
      "eas": {
        "projectId": "9890394d-fffe-4ecb-b219-2b64bc7a8a67"
      }
    }
  },
  "ignite": {
    "version": "10.1.6"
  }
}

================
File: app/app.tsx
================
/* eslint-disable import/first */
/**
 * Welcome to the main entry point of the app. In this file, we'll
 * be kicking off our app.
 *
 * Most of this file is boilerplate and you shouldn't need to modify
 * it very often. But take some time to look through and understand
 * what is going on here.
 *
 * The app navigation resides in ./app/navigators, so head over there
 * if you're interested in adding screens and navigators.
 */
if (__DEV__) {
  // Load Reactotron in development only.
  // Note that you must be using metro's `inlineRequires` for this to work.
  // If you turn it off in metro.config.js, you'll have to manually import it.
  require("./devtools/ReactotronConfig.ts")
}
import "./utils/gestureHandler"
import { initI18n } from "./i18n"
import "./utils/ignoreWarnings"
import { useFonts } from "expo-font"
import { useEffect, useState } from "react"
import { initialWindowMetrics, SafeAreaProvider } from "react-native-safe-area-context"
import * as Linking from "expo-linking"
import * as SplashScreen from "expo-splash-screen"
import { AppNavigator, useNavigationPersistence } from "./navigators"
import { ErrorBoundary } from "./screens/ErrorScreen/ErrorBoundary"
import * as storage from "./utils/storage"
import { customFontsToLoad } from "./theme"
import Config from "./config"
import { KeyboardProvider } from "react-native-keyboard-controller"
import { loadDateFnsLocale } from "./utils/formatDate"

export const NAVIGATION_PERSISTENCE_KEY = "NAVIGATION_STATE"

// Web linking configuration
const prefix = Linking.createURL("/")
const config = {
  screens: {
    Login: {
      path: "",
    },
    Welcome: "welcome",
    Demo: {
      screens: {
        DemoShowroom: {
          path: "showroom/:queryIndex?/:itemIndex?",
        },
        DemoDebug: "debug",
        DemoPodcastList: "podcast",
        DemoCommunity: "community",
      },
    },
  },
}

/**
 * This is the root component of our app.
 * @param {AppProps} props - The props for the `App` component.
 * @returns {JSX.Element} The rendered `App` component.
 */
export function App() {
  const {
    initialNavigationState,
    onNavigationStateChange,
    isRestored: isNavigationStateRestored,
  } = useNavigationPersistence(storage, NAVIGATION_PERSISTENCE_KEY)

  const [areFontsLoaded, fontLoadError] = useFonts(customFontsToLoad)
  const [isI18nInitialized, setIsI18nInitialized] = useState(false)

  useEffect(() => {
    initI18n()
      .then(() => setIsI18nInitialized(true))
      .then(() => loadDateFnsLocale())
  }, [])

  useEffect(() => {
    // If your initialization scripts run very fast, it's good to show the splash screen for just a bit longer to prevent flicker.
    // Slightly delaying splash screen hiding for better UX; can be customized or removed as needed,
    setTimeout(SplashScreen.hideAsync, 500)
  }, [])

  // Before we show the app, we have to wait for our state to be ready.
  // In the meantime, don't render anything. This will be the background
  // color set in native by rootView's background color.
  // In iOS: application:didFinishLaunchingWithOptions:
  // In Android: https://stackoverflow.com/a/45838109/204044
  // You can replace with your own loading component if you wish.
  if (!isNavigationStateRestored || !isI18nInitialized || (!areFontsLoaded && !fontLoadError)) {
    return null
  }

  const linking = {
    prefixes: [prefix],
    config,
  }

  // otherwise, we're ready to render the app
  return (
    <SafeAreaProvider initialMetrics={initialWindowMetrics}>
      <ErrorBoundary catchErrors={Config.catchErrors}>
        <KeyboardProvider>
          <AppNavigator
            linking={linking}
            initialState={initialNavigationState}
            onStateChange={onNavigationStateChange}
          />
        </KeyboardProvider>
      </ErrorBoundary>
    </SafeAreaProvider>
  )
}

================
File: app/components/AutoImage.tsx
================
import { useLayoutEffect, useState } from "react"
import { Image, ImageProps, ImageURISource, Platform, PixelRatio } from "react-native"

export interface AutoImageProps extends ImageProps {
  /**
   * How wide should the image be?
   */
  maxWidth?: number
  /**
   * How tall should the image be?
   */
  maxHeight?: number
  headers?: {
    [key: string]: string
  }
}

/**
 * A hook that will return the scaled dimensions of an image based on the
 * provided dimensions' aspect ratio. If no desired dimensions are provided,
 * it will return the original dimensions of the remote image.
 *
 * How is this different from `resizeMode: 'contain'`? Firstly, you can
 * specify only one side's size (not both). Secondly, the image will scale to fit
 * the desired dimensions instead of just being contained within its image-container.
 * @param {number} remoteUri - The URI of the remote image.
 * @param {number} dimensions - The desired dimensions of the image. If not provided, the original dimensions will be returned.
 * @returns {[number, number]} - The scaled dimensions of the image.
 */
export function useAutoImage(
  remoteUri: string,
  headers?: {
    [key: string]: string
  },
  dimensions?: [maxWidth?: number, maxHeight?: number],
): [width: number, height: number] {
  const [[remoteWidth, remoteHeight], setRemoteImageDimensions] = useState([0, 0])
  const remoteAspectRatio = remoteWidth / remoteHeight
  const [maxWidth, maxHeight] = dimensions ?? []

  useLayoutEffect(() => {
    if (!remoteUri) return

    if (!headers) {
      Image.getSize(remoteUri, (w, h) => setRemoteImageDimensions([w, h]))
    } else {
      Image.getSizeWithHeaders(remoteUri, headers, (w, h) => setRemoteImageDimensions([w, h]))
    }
  }, [remoteUri, headers])

  if (Number.isNaN(remoteAspectRatio)) return [0, 0]

  if (maxWidth && maxHeight) {
    const aspectRatio = Math.min(maxWidth / remoteWidth, maxHeight / remoteHeight)
    return [
      PixelRatio.roundToNearestPixel(remoteWidth * aspectRatio),
      PixelRatio.roundToNearestPixel(remoteHeight * aspectRatio),
    ]
  } else if (maxWidth) {
    return [maxWidth, PixelRatio.roundToNearestPixel(maxWidth / remoteAspectRatio)]
  } else if (maxHeight) {
    return [PixelRatio.roundToNearestPixel(maxHeight * remoteAspectRatio), maxHeight]
  } else {
    return [remoteWidth, remoteHeight]
  }
}

/**
 * An Image component that automatically sizes a remote or data-uri image.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/AutoImage/}
 * @param {AutoImageProps} props - The props for the `AutoImage` component.
 * @returns {JSX.Element} The rendered `AutoImage` component.
 */
export function AutoImage(props: AutoImageProps) {
  const { maxWidth, maxHeight, ...ImageProps } = props
  const source = props.source as ImageURISource
  const headers = source?.headers

  const [width, height] = useAutoImage(
    Platform.select({
      web: (source?.uri as string) ?? (source as string),
      default: source?.uri as string,
    }),
    headers,
    [maxWidth, maxHeight],
  )

  return <Image {...ImageProps} style={[{ width, height }, props.style]} />
}

================
File: app/components/Button.tsx
================
import { ComponentType } from "react"
import {
  Pressable,
  PressableProps,
  PressableStateCallbackType,
  StyleProp,
  TextStyle,
  ViewStyle,
} from "react-native"
import type { ThemedStyle, ThemedStyleArray } from "@/theme"
import { $styles } from "../theme"
import { Text, TextProps } from "./Text"
import { useAppTheme } from "@/utils/useAppTheme"

type Presets = "default" | "filled" | "reversed"

export interface ButtonAccessoryProps {
  style: StyleProp<any>
  pressableState: PressableStateCallbackType
  disabled?: boolean
}

export interface ButtonProps extends PressableProps {
  /**
   * Text which is looked up via i18n.
   */
  tx?: TextProps["tx"]
  /**
   * The text to display if not using `tx` or nested components.
   */
  text?: TextProps["text"]
  /**
   * Optional options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  txOptions?: TextProps["txOptions"]
  /**
   * An optional style override useful for padding & margin.
   */
  style?: StyleProp<ViewStyle>
  /**
   * An optional style override for the "pressed" state.
   */
  pressedStyle?: StyleProp<ViewStyle>
  /**
   * An optional style override for the button text.
   */
  textStyle?: StyleProp<TextStyle>
  /**
   * An optional style override for the button text when in the "pressed" state.
   */
  pressedTextStyle?: StyleProp<TextStyle>
  /**
   * An optional style override for the button text when in the "disabled" state.
   */
  disabledTextStyle?: StyleProp<TextStyle>
  /**
   * One of the different types of button presets.
   */
  preset?: Presets
  /**
   * An optional component to render on the right side of the text.
   * Example: `RightAccessory={(props) => <View {...props} />}`
   */
  RightAccessory?: ComponentType<ButtonAccessoryProps>
  /**
   * An optional component to render on the left side of the text.
   * Example: `LeftAccessory={(props) => <View {...props} />}`
   */
  LeftAccessory?: ComponentType<ButtonAccessoryProps>
  /**
   * Children components.
   */
  children?: React.ReactNode
  /**
   * disabled prop, accessed directly for declarative styling reasons.
   * https://reactnative.dev/docs/pressable#disabled
   */
  disabled?: boolean
  /**
   * An optional style override for the disabled state
   */
  disabledStyle?: StyleProp<ViewStyle>
}

/**
 * A component that allows users to take actions and make choices.
 * Wraps the Text component with a Pressable component.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Button/}
 * @param {ButtonProps} props - The props for the `Button` component.
 * @returns {JSX.Element} The rendered `Button` component.
 * @example
 * <Button
 *   tx="common:ok"
 *   style={styles.button}
 *   textStyle={styles.buttonText}
 *   onPress={handleButtonPress}
 * />
 */
export function Button(props: ButtonProps) {
  const {
    tx,
    text,
    txOptions,
    style: $viewStyleOverride,
    pressedStyle: $pressedViewStyleOverride,
    textStyle: $textStyleOverride,
    pressedTextStyle: $pressedTextStyleOverride,
    disabledTextStyle: $disabledTextStyleOverride,
    children,
    RightAccessory,
    LeftAccessory,
    disabled,
    disabledStyle: $disabledViewStyleOverride,
    ...rest
  } = props

  const { themed } = useAppTheme()

  const preset: Presets = props.preset ?? "default"
  /**
   * @param {PressableStateCallbackType} root0 - The root object containing the pressed state.
   * @param {boolean} root0.pressed - The pressed state.
   * @returns {StyleProp<ViewStyle>} The view style based on the pressed state.
   */
  function $viewStyle({ pressed }: PressableStateCallbackType): StyleProp<ViewStyle> {
    return [
      themed($viewPresets[preset]),
      $viewStyleOverride,
      !!pressed && themed([$pressedViewPresets[preset], $pressedViewStyleOverride]),
      !!disabled && $disabledViewStyleOverride,
    ]
  }
  /**
   * @param {PressableStateCallbackType} root0 - The root object containing the pressed state.
   * @param {boolean} root0.pressed - The pressed state.
   * @returns {StyleProp<TextStyle>} The text style based on the pressed state.
   */
  function $textStyle({ pressed }: PressableStateCallbackType): StyleProp<TextStyle> {
    return [
      themed($textPresets[preset]),
      $textStyleOverride,
      !!pressed && themed([$pressedTextPresets[preset], $pressedTextStyleOverride]),
      !!disabled && $disabledTextStyleOverride,
    ]
  }

  return (
    <Pressable
      style={$viewStyle}
      accessibilityRole="button"
      accessibilityState={{ disabled: !!disabled }}
      {...rest}
      disabled={disabled}
    >
      {(state) => (
        <>
          {!!LeftAccessory && (
            <LeftAccessory style={$leftAccessoryStyle} pressableState={state} disabled={disabled} />
          )}

          <Text tx={tx} text={text} txOptions={txOptions} style={$textStyle(state)}>
            {children}
          </Text>

          {!!RightAccessory && (
            <RightAccessory
              style={$rightAccessoryStyle}
              pressableState={state}
              disabled={disabled}
            />
          )}
        </>
      )}
    </Pressable>
  )
}

const $baseViewStyle: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  minHeight: 56,
  borderRadius: 4,
  justifyContent: "center",
  alignItems: "center",
  paddingVertical: spacing.sm,
  paddingHorizontal: spacing.sm,
  overflow: "hidden",
})

const $baseTextStyle: ThemedStyle<TextStyle> = ({ typography }) => ({
  fontSize: 16,
  lineHeight: 20,
  fontFamily: typography.primary.medium,
  textAlign: "center",
  flexShrink: 1,
  flexGrow: 0,
  zIndex: 2,
})

const $rightAccessoryStyle: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginStart: spacing.xs,
  zIndex: 1,
})
const $leftAccessoryStyle: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginEnd: spacing.xs,
  zIndex: 1,
})

const $viewPresets: Record<Presets, ThemedStyleArray<ViewStyle>> = {
  default: [
    $styles.row,
    $baseViewStyle,
    ({ colors }) => ({
      borderWidth: 1,
      borderColor: colors.palette.neutral400,
      backgroundColor: colors.palette.neutral100,
    }),
  ],
  filled: [
    $styles.row,
    $baseViewStyle,
    ({ colors }) => ({ backgroundColor: colors.palette.neutral300 }),
  ],
  reversed: [
    $styles.row,
    $baseViewStyle,
    ({ colors }) => ({ backgroundColor: colors.palette.neutral800 }),
  ],
}

const $textPresets: Record<Presets, ThemedStyleArray<TextStyle>> = {
  default: [$baseTextStyle],
  filled: [$baseTextStyle],
  reversed: [$baseTextStyle, ({ colors }) => ({ color: colors.palette.neutral100 })],
}

const $pressedViewPresets: Record<Presets, ThemedStyle<ViewStyle>> = {
  default: ({ colors }) => ({ backgroundColor: colors.palette.neutral200 }),
  filled: ({ colors }) => ({ backgroundColor: colors.palette.neutral400 }),
  reversed: ({ colors }) => ({ backgroundColor: colors.palette.neutral700 }),
}

const $pressedTextPresets: Record<Presets, ThemedStyle<ViewStyle>> = {
  default: () => ({ opacity: 0.9 }),
  filled: () => ({ opacity: 0.9 }),
  reversed: () => ({ opacity: 0.9 }),
}

================
File: app/components/Card.tsx
================
import { ComponentType, Fragment, ReactElement } from "react"
import {
  StyleProp,
  TextStyle,
  TouchableOpacity,
  TouchableOpacityProps,
  View,
  ViewProps,
  ViewStyle,
} from "react-native"
import type { ThemedStyle, ThemedStyleArray } from "@/theme"
import { $styles } from "../theme"
import { Text, TextProps } from "./Text"
import { useAppTheme } from "@/utils/useAppTheme"

type Presets = "default" | "reversed"

interface CardProps extends TouchableOpacityProps {
  /**
   * One of the different types of text presets.
   */
  preset?: Presets
  /**
   * How the content should be aligned vertically. This is especially (but not exclusively) useful
   * when the card is a fixed height but the content is dynamic.
   *
   * `top` (default) - aligns all content to the top.
   * `center` - aligns all content to the center.
   * `space-between` - spreads out the content evenly.
   * `force-footer-bottom` - aligns all content to the top, but forces the footer to the bottom.
   */
  verticalAlignment?: "top" | "center" | "space-between" | "force-footer-bottom"
  /**
   * Custom component added to the left of the card body.
   */
  LeftComponent?: ReactElement
  /**
   * Custom component added to the right of the card body.
   */
  RightComponent?: ReactElement
  /**
   * The heading text to display if not using `headingTx`.
   */
  heading?: TextProps["text"]
  /**
   * Heading text which is looked up via i18n.
   */
  headingTx?: TextProps["tx"]
  /**
   * Optional heading options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  headingTxOptions?: TextProps["txOptions"]
  /**
   * Style overrides for heading text.
   */
  headingStyle?: StyleProp<TextStyle>
  /**
   * Pass any additional props directly to the heading Text component.
   */
  HeadingTextProps?: TextProps
  /**
   * Custom heading component.
   * Overrides all other `heading*` props.
   */
  HeadingComponent?: ReactElement
  /**
   * The content text to display if not using `contentTx`.
   */
  content?: TextProps["text"]
  /**
   * Content text which is looked up via i18n.
   */
  contentTx?: TextProps["tx"]
  /**
   * Optional content options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  contentTxOptions?: TextProps["txOptions"]
  /**
   * Style overrides for content text.
   */
  contentStyle?: StyleProp<TextStyle>
  /**
   * Pass any additional props directly to the content Text component.
   */
  ContentTextProps?: TextProps
  /**
   * Custom content component.
   * Overrides all other `content*` props.
   */
  ContentComponent?: ReactElement
  /**
   * The footer text to display if not using `footerTx`.
   */
  footer?: TextProps["text"]
  /**
   * Footer text which is looked up via i18n.
   */
  footerTx?: TextProps["tx"]
  /**
   * Optional footer options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  footerTxOptions?: TextProps["txOptions"]
  /**
   * Style overrides for footer text.
   */
  footerStyle?: StyleProp<TextStyle>
  /**
   * Pass any additional props directly to the footer Text component.
   */
  FooterTextProps?: TextProps
  /**
   * Custom footer component.
   * Overrides all other `footer*` props.
   */
  FooterComponent?: ReactElement
}

/**
 * Cards are useful for displaying related information in a contained way.
 * If a ListItem displays content horizontally, a Card can be used to display content vertically.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Card/}
 * @param {CardProps} props - The props for the `Card` component.
 * @returns {JSX.Element} The rendered `Card` component.
 */
export function Card(props: CardProps) {
  const {
    content,
    contentTx,
    contentTxOptions,
    footer,
    footerTx,
    footerTxOptions,
    heading,
    headingTx,
    headingTxOptions,
    ContentComponent,
    HeadingComponent,
    FooterComponent,
    LeftComponent,
    RightComponent,
    verticalAlignment = "top",
    style: $containerStyleOverride,
    contentStyle: $contentStyleOverride,
    headingStyle: $headingStyleOverride,
    footerStyle: $footerStyleOverride,
    ContentTextProps,
    HeadingTextProps,
    FooterTextProps,
    ...WrapperProps
  } = props

  const {
    themed,
    theme: { spacing },
  } = useAppTheme()

  const preset: Presets = props.preset ?? "default"
  const isPressable = !!WrapperProps.onPress
  const isHeadingPresent = !!(HeadingComponent || heading || headingTx)
  const isContentPresent = !!(ContentComponent || content || contentTx)
  const isFooterPresent = !!(FooterComponent || footer || footerTx)

  const Wrapper = (isPressable ? TouchableOpacity : View) as ComponentType<
    TouchableOpacityProps | ViewProps
  >
  const HeaderContentWrapper = verticalAlignment === "force-footer-bottom" ? View : Fragment

  const $containerStyle: StyleProp<ViewStyle> = [
    themed($containerPresets[preset]),
    $containerStyleOverride,
  ]
  const $headingStyle = [
    themed($headingPresets[preset]),
    (isFooterPresent || isContentPresent) && { marginBottom: spacing.xxxs },
    $headingStyleOverride,
    HeadingTextProps?.style,
  ]
  const $contentStyle = [
    themed($contentPresets[preset]),
    isHeadingPresent && { marginTop: spacing.xxxs },
    isFooterPresent && { marginBottom: spacing.xxxs },
    $contentStyleOverride,
    ContentTextProps?.style,
  ]
  const $footerStyle = [
    themed($footerPresets[preset]),
    (isHeadingPresent || isContentPresent) && { marginTop: spacing.xxxs },
    $footerStyleOverride,
    FooterTextProps?.style,
  ]
  const $alignmentWrapperStyle = [
    $alignmentWrapper,
    { justifyContent: $alignmentWrapperFlexOptions[verticalAlignment] },
    LeftComponent && { marginStart: spacing.md },
    RightComponent && { marginEnd: spacing.md },
  ]

  return (
    <Wrapper
      style={$containerStyle}
      activeOpacity={0.8}
      accessibilityRole={isPressable ? "button" : undefined}
      {...WrapperProps}
    >
      {LeftComponent}

      <View style={$alignmentWrapperStyle}>
        <HeaderContentWrapper>
          {HeadingComponent ||
            (isHeadingPresent && (
              <Text
                weight="bold"
                text={heading}
                tx={headingTx}
                txOptions={headingTxOptions}
                {...HeadingTextProps}
                style={$headingStyle}
              />
            ))}

          {ContentComponent ||
            (isContentPresent && (
              <Text
                weight="normal"
                text={content}
                tx={contentTx}
                txOptions={contentTxOptions}
                {...ContentTextProps}
                style={$contentStyle}
              />
            ))}
        </HeaderContentWrapper>

        {FooterComponent ||
          (isFooterPresent && (
            <Text
              weight="normal"
              size="xs"
              text={footer}
              tx={footerTx}
              txOptions={footerTxOptions}
              {...FooterTextProps}
              style={$footerStyle}
            />
          ))}
      </View>

      {RightComponent}
    </Wrapper>
  )
}

const $containerBase: ThemedStyle<ViewStyle> = (theme) => ({
  borderRadius: theme.spacing.md,
  padding: theme.spacing.xs,
  borderWidth: 1,
  shadowColor: theme.colors.palette.neutral800,
  shadowOffset: { width: 0, height: 12 },
  shadowOpacity: 0.08,
  shadowRadius: 12.81,
  elevation: 16,
  minHeight: 96,
})

const $alignmentWrapper: ViewStyle = {
  flex: 1,
  alignSelf: "stretch",
}

const $alignmentWrapperFlexOptions = {
  "top": "flex-start",
  "center": "center",
  "space-between": "space-between",
  "force-footer-bottom": "space-between",
} as const

const $containerPresets: Record<Presets, ThemedStyleArray<ViewStyle>> = {
  default: [
    $styles.row,
    $containerBase,
    (theme) => ({
      backgroundColor: theme.colors.palette.neutral100,
      borderColor: theme.colors.palette.neutral300,
    }),
  ],
  reversed: [
    $styles.row,
    $containerBase,
    (theme) => ({
      backgroundColor: theme.colors.palette.neutral800,
      borderColor: theme.colors.palette.neutral500,
    }),
  ],
}

const $headingPresets: Record<Presets, ThemedStyleArray<TextStyle>> = {
  default: [],
  reversed: [(theme) => ({ color: theme.colors.palette.neutral100 })],
}

const $contentPresets: Record<Presets, ThemedStyleArray<TextStyle>> = {
  default: [],
  reversed: [(theme) => ({ color: theme.colors.palette.neutral100 })],
}

const $footerPresets: Record<Presets, ThemedStyleArray<TextStyle>> = {
  default: [],
  reversed: [(theme) => ({ color: theme.colors.palette.neutral100 })],
}

================
File: app/components/EmptyState.tsx
================
import { Image, ImageProps, ImageStyle, StyleProp, TextStyle, View, ViewStyle } from "react-native"

import { Button, ButtonProps } from "./Button"
import { Text, TextProps } from "./Text"
import { useAppTheme } from "@/utils/useAppTheme"
import type { ThemedStyle } from "@/theme"
import { translate } from "@/i18n/translate"

const sadFace = require("../../assets/images/sad-face.png")

interface EmptyStateProps {
  /**
   * An optional prop that specifies the text/image set to use for the empty state.
   */
  preset?: "generic"
  /**
   * Style override for the container.
   */
  style?: StyleProp<ViewStyle>
  /**
   * An Image source to be displayed above the heading.
   */
  imageSource?: ImageProps["source"]
  /**
   * Style overrides for image.
   */
  imageStyle?: StyleProp<ImageStyle>
  /**
   * Pass any additional props directly to the Image component.
   */
  ImageProps?: Omit<ImageProps, "source">
  /**
   * The heading text to display if not using `headingTx`.
   */
  heading?: TextProps["text"]
  /**
   * Heading text which is looked up via i18n.
   */
  headingTx?: TextProps["tx"]
  /**
   * Optional heading options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  headingTxOptions?: TextProps["txOptions"]
  /**
   * Style overrides for heading text.
   */
  headingStyle?: StyleProp<TextStyle>
  /**
   * Pass any additional props directly to the heading Text component.
   */
  HeadingTextProps?: TextProps
  /**
   * The content text to display if not using `contentTx`.
   */
  content?: TextProps["text"]
  /**
   * Content text which is looked up via i18n.
   */
  contentTx?: TextProps["tx"]
  /**
   * Optional content options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  contentTxOptions?: TextProps["txOptions"]
  /**
   * Style overrides for content text.
   */
  contentStyle?: StyleProp<TextStyle>
  /**
   * Pass any additional props directly to the content Text component.
   */
  ContentTextProps?: TextProps
  /**
   * The button text to display if not using `buttonTx`.
   */
  button?: TextProps["text"]
  /**
   * Button text which is looked up via i18n.
   */
  buttonTx?: TextProps["tx"]
  /**
   * Optional button options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  buttonTxOptions?: TextProps["txOptions"]
  /**
   * Style overrides for button.
   */
  buttonStyle?: ButtonProps["style"]
  /**
   * Style overrides for button text.
   */
  buttonTextStyle?: ButtonProps["textStyle"]
  /**
   * Called when the button is pressed.
   */
  buttonOnPress?: ButtonProps["onPress"]
  /**
   * Pass any additional props directly to the Button component.
   */
  ButtonProps?: ButtonProps
}

interface EmptyStatePresetItem {
  imageSource: ImageProps["source"]
  heading: TextProps["text"]
  content: TextProps["text"]
  button: TextProps["text"]
}

/**
 * A component to use when there is no data to display. It can be utilized to direct the user what to do next.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/EmptyState/}
 * @param {EmptyStateProps} props - The props for the `EmptyState` component.
 * @returns {JSX.Element} The rendered `EmptyState` component.
 */
export function EmptyState(props: EmptyStateProps) {
  const {
    theme,
    themed,
    theme: { spacing },
  } = useAppTheme()

  const EmptyStatePresets = {
    generic: {
      imageSource: sadFace,
      heading: translate("emptyStateComponent:generic.heading"),
      content: translate("emptyStateComponent:generic.content"),
      button: translate("emptyStateComponent:generic.button"),
    } as EmptyStatePresetItem,
  } as const

  const preset = EmptyStatePresets[props.preset ?? "generic"]

  const {
    button = preset.button,
    buttonTx,
    buttonOnPress,
    buttonTxOptions,
    content = preset.content,
    contentTx,
    contentTxOptions,
    heading = preset.heading,
    headingTx,
    headingTxOptions,
    imageSource = preset.imageSource,
    style: $containerStyleOverride,
    buttonStyle: $buttonStyleOverride,
    buttonTextStyle: $buttonTextStyleOverride,
    contentStyle: $contentStyleOverride,
    headingStyle: $headingStyleOverride,
    imageStyle: $imageStyleOverride,
    ButtonProps,
    ContentTextProps,
    HeadingTextProps,
    ImageProps,
  } = props

  const isImagePresent = !!imageSource
  const isHeadingPresent = !!(heading || headingTx)
  const isContentPresent = !!(content || contentTx)
  const isButtonPresent = !!(button || buttonTx)

  const $containerStyles = [$containerStyleOverride]
  const $imageStyles = [
    $image,
    (isHeadingPresent || isContentPresent || isButtonPresent) && { marginBottom: spacing.xxxs },
    $imageStyleOverride,
    ImageProps?.style,
  ]
  const $headingStyles = [
    themed($heading),
    isImagePresent && { marginTop: spacing.xxxs },
    (isContentPresent || isButtonPresent) && { marginBottom: spacing.xxxs },
    $headingStyleOverride,
    HeadingTextProps?.style,
  ]
  const $contentStyles = [
    themed($content),
    (isImagePresent || isHeadingPresent) && { marginTop: spacing.xxxs },
    isButtonPresent && { marginBottom: spacing.xxxs },
    $contentStyleOverride,
    ContentTextProps?.style,
  ]
  const $buttonStyles = [
    (isImagePresent || isHeadingPresent || isContentPresent) && { marginTop: spacing.xl },
    $buttonStyleOverride,
    ButtonProps?.style,
  ]

  return (
    <View style={$containerStyles}>
      {isImagePresent && (
        <Image
          source={imageSource}
          {...ImageProps}
          style={$imageStyles}
          tintColor={theme.isDark ? theme.colors.palette.neutral900 : undefined}
        />
      )}

      {isHeadingPresent && (
        <Text
          preset="subheading"
          text={heading}
          tx={headingTx}
          txOptions={headingTxOptions}
          {...HeadingTextProps}
          style={$headingStyles}
        />
      )}

      {isContentPresent && (
        <Text
          text={content}
          tx={contentTx}
          txOptions={contentTxOptions}
          {...ContentTextProps}
          style={$contentStyles}
        />
      )}

      {isButtonPresent && (
        <Button
          onPress={buttonOnPress}
          text={button}
          tx={buttonTx}
          txOptions={buttonTxOptions}
          textStyle={$buttonTextStyleOverride}
          {...ButtonProps}
          style={$buttonStyles}
        />
      )}
    </View>
  )
}

const $image: ImageStyle = { alignSelf: "center" }
const $heading: ThemedStyle<TextStyle> = ({ spacing }) => ({
  textAlign: "center",
  paddingHorizontal: spacing.lg,
})
const $content: ThemedStyle<TextStyle> = ({ spacing }) => ({
  textAlign: "center",
  paddingHorizontal: spacing.lg,
})

================
File: app/components/Header.tsx
================
import { ReactElement } from "react"
import {
  StyleProp,
  TextStyle,
  TouchableOpacity,
  TouchableOpacityProps,
  View,
  ViewStyle,
} from "react-native"
import { isRTL, translate } from "@/i18n"
import { $styles } from "../theme"
import { ExtendedEdge, useSafeAreaInsetsStyle } from "../utils/useSafeAreaInsetsStyle"
import { Icon, IconTypes } from "./Icon"
import { Text, TextProps } from "./Text"
import { useAppTheme } from "@/utils/useAppTheme"
import type { ThemedStyle } from "@/theme"

export interface HeaderProps {
  /**
   * The layout of the title relative to the action components.
   * - `center` will force the title to always be centered relative to the header. If the title or the action buttons are too long, the title will be cut off.
   * - `flex` will attempt to center the title relative to the action buttons. If the action buttons are different widths, the title will be off-center relative to the header.
   */
  titleMode?: "center" | "flex"
  /**
   * Optional title style override.
   */
  titleStyle?: StyleProp<TextStyle>
  /**
   * Optional outer title container style override.
   */
  titleContainerStyle?: StyleProp<ViewStyle>
  /**
   * Optional inner header wrapper style override.
   */
  style?: StyleProp<ViewStyle>
  /**
   * Optional outer header container style override.
   */
  containerStyle?: StyleProp<ViewStyle>
  /**
   * Background color
   */
  backgroundColor?: string
  /**
   * Title text to display if not using `tx` or nested components.
   */
  title?: TextProps["text"]
  /**
   * Title text which is looked up via i18n.
   */
  titleTx?: TextProps["tx"]
  /**
   * Optional options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  titleTxOptions?: TextProps["txOptions"]
  /**
   * Icon that should appear on the left.
   * Can be used with `onLeftPress`.
   */
  leftIcon?: IconTypes
  /**
   * An optional tint color for the left icon
   */
  leftIconColor?: string
  /**
   * Left action text to display if not using `leftTx`.
   * Can be used with `onLeftPress`. Overrides `leftIcon`.
   */
  leftText?: TextProps["text"]
  /**
   * Left action text text which is looked up via i18n.
   * Can be used with `onLeftPress`. Overrides `leftIcon`.
   */
  leftTx?: TextProps["tx"]
  /**
   * Left action custom ReactElement if the built in action props don't suffice.
   * Overrides `leftIcon`, `leftTx` and `leftText`.
   */
  LeftActionComponent?: ReactElement
  /**
   * Optional options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  leftTxOptions?: TextProps["txOptions"]
  /**
   * What happens when you press the left icon or text action.
   */
  onLeftPress?: TouchableOpacityProps["onPress"]
  /**
   * Icon that should appear on the right.
   * Can be used with `onRightPress`.
   */
  rightIcon?: IconTypes
  /**
   * An optional tint color for the right icon
   */
  rightIconColor?: string
  /**
   * Right action text to display if not using `rightTx`.
   * Can be used with `onRightPress`. Overrides `rightIcon`.
   */
  rightText?: TextProps["text"]
  /**
   * Right action text text which is looked up via i18n.
   * Can be used with `onRightPress`. Overrides `rightIcon`.
   */
  rightTx?: TextProps["tx"]
  /**
   * Right action custom ReactElement if the built in action props don't suffice.
   * Overrides `rightIcon`, `rightTx` and `rightText`.
   */
  RightActionComponent?: ReactElement
  /**
   * Optional options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  rightTxOptions?: TextProps["txOptions"]
  /**
   * What happens when you press the right icon or text action.
   */
  onRightPress?: TouchableOpacityProps["onPress"]
  /**
   * Override the default edges for the safe area.
   */
  safeAreaEdges?: ExtendedEdge[]
}

interface HeaderActionProps {
  backgroundColor?: string
  icon?: IconTypes
  iconColor?: string
  text?: TextProps["text"]
  tx?: TextProps["tx"]
  txOptions?: TextProps["txOptions"]
  onPress?: TouchableOpacityProps["onPress"]
  ActionComponent?: ReactElement
}

/**
 * Header that appears on many screens. Will hold navigation buttons and screen title.
 * The Header is meant to be used with the `screenOptions.header` option on navigators, routes, or screen components via `navigation.setOptions({ header })`.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Header/}
 * @param {HeaderProps} props - The props for the `Header` component.
 * @returns {JSX.Element} The rendered `Header` component.
 */
export function Header(props: HeaderProps) {
  const {
    theme: { colors },
    themed,
  } = useAppTheme()
  const {
    backgroundColor = colors.background,
    LeftActionComponent,
    leftIcon,
    leftIconColor,
    leftText,
    leftTx,
    leftTxOptions,
    onLeftPress,
    onRightPress,
    RightActionComponent,
    rightIcon,
    rightIconColor,
    rightText,
    rightTx,
    rightTxOptions,
    safeAreaEdges = ["top"],
    title,
    titleMode = "center",
    titleTx,
    titleTxOptions,
    titleContainerStyle: $titleContainerStyleOverride,
    style: $styleOverride,
    titleStyle: $titleStyleOverride,
    containerStyle: $containerStyleOverride,
  } = props

  const $containerInsets = useSafeAreaInsetsStyle(safeAreaEdges)

  const titleContent = titleTx ? translate(titleTx, titleTxOptions) : title

  return (
    <View style={[$container, $containerInsets, { backgroundColor }, $containerStyleOverride]}>
      <View style={[$styles.row, $wrapper, $styleOverride]}>
        <HeaderAction
          tx={leftTx}
          text={leftText}
          icon={leftIcon}
          iconColor={leftIconColor}
          onPress={onLeftPress}
          txOptions={leftTxOptions}
          backgroundColor={backgroundColor}
          ActionComponent={LeftActionComponent}
        />

        {!!titleContent && (
          <View
            style={[
              titleMode === "center" && themed($titleWrapperCenter),
              titleMode === "flex" && $titleWrapperFlex,
              $titleContainerStyleOverride,
            ]}
            pointerEvents="none"
          >
            <Text
              weight="medium"
              size="md"
              text={titleContent}
              style={[$title, $titleStyleOverride]}
            />
          </View>
        )}

        <HeaderAction
          tx={rightTx}
          text={rightText}
          icon={rightIcon}
          iconColor={rightIconColor}
          onPress={onRightPress}
          txOptions={rightTxOptions}
          backgroundColor={backgroundColor}
          ActionComponent={RightActionComponent}
        />
      </View>
    </View>
  )
}

/**
 * @param {HeaderActionProps} props - The props for the `HeaderAction` component.
 * @returns {JSX.Element} The rendered `HeaderAction` component.
 */
function HeaderAction(props: HeaderActionProps) {
  const { backgroundColor, icon, text, tx, txOptions, onPress, ActionComponent, iconColor } = props
  const { themed } = useAppTheme()

  const content = tx ? translate(tx, txOptions) : text

  if (ActionComponent) return ActionComponent

  if (content) {
    return (
      <TouchableOpacity
        style={themed([$actionTextContainer, { backgroundColor }])}
        onPress={onPress}
        disabled={!onPress}
        activeOpacity={0.8}
      >
        <Text weight="medium" size="md" text={content} style={themed($actionText)} />
      </TouchableOpacity>
    )
  }

  if (icon) {
    return (
      <Icon
        size={24}
        icon={icon}
        color={iconColor}
        onPress={onPress}
        containerStyle={themed([$actionIconContainer, { backgroundColor }])}
        style={isRTL ? { transform: [{ rotate: "180deg" }] } : {}}
      />
    )
  }

  return <View style={[$actionFillerContainer, { backgroundColor }]} />
}

const $wrapper: ViewStyle = {
  height: 56,
  alignItems: "center",
  justifyContent: "space-between",
}

const $container: ViewStyle = {
  width: "100%",
}

const $title: TextStyle = {
  textAlign: "center",
}

const $actionTextContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  flexGrow: 0,
  alignItems: "center",
  justifyContent: "center",
  height: "100%",
  paddingHorizontal: spacing.md,
  zIndex: 2,
})

const $actionText: ThemedStyle<TextStyle> = ({ colors }) => ({
  color: colors.tint,
})

const $actionIconContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  flexGrow: 0,
  alignItems: "center",
  justifyContent: "center",
  height: "100%",
  paddingHorizontal: spacing.md,
  zIndex: 2,
})

const $actionFillerContainer: ViewStyle = {
  width: 16,
}

const $titleWrapperCenter: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  alignItems: "center",
  justifyContent: "center",
  height: "100%",
  width: "100%",
  position: "absolute",
  paddingHorizontal: spacing.xxl,
  zIndex: 1,
})

const $titleWrapperFlex: ViewStyle = {
  justifyContent: "center",
  flexGrow: 1,
}

================
File: app/components/Icon.tsx
================
import { ComponentType } from "react"
import {
  Image,
  ImageStyle,
  StyleProp,
  TouchableOpacity,
  TouchableOpacityProps,
  View,
  ViewProps,
  ViewStyle,
} from "react-native"
import { useAppTheme } from "@/utils/useAppTheme"

export type IconTypes = keyof typeof iconRegistry

interface IconProps extends TouchableOpacityProps {
  /**
   * The name of the icon
   */
  icon: IconTypes

  /**
   * An optional tint color for the icon
   */
  color?: string

  /**
   * An optional size for the icon. If not provided, the icon will be sized to the icon's resolution.
   */
  size?: number

  /**
   * Style overrides for the icon image
   */
  style?: StyleProp<ImageStyle>

  /**
   * Style overrides for the icon container
   */
  containerStyle?: StyleProp<ViewStyle>

  /**
   * An optional function to be called when the icon is pressed
   */
  onPress?: TouchableOpacityProps["onPress"]
}

/**
 * A component to render a registered icon.
 * It is wrapped in a <TouchableOpacity /> if `onPress` is provided, otherwise a <View />.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Icon/}
 * @param {IconProps} props - The props for the `Icon` component.
 * @returns {JSX.Element} The rendered `Icon` component.
 */
export function Icon(props: IconProps) {
  const {
    icon,
    color,
    size,
    style: $imageStyleOverride,
    containerStyle: $containerStyleOverride,
    ...WrapperProps
  } = props

  const isPressable = !!WrapperProps.onPress
  const Wrapper = (WrapperProps?.onPress ? TouchableOpacity : View) as ComponentType<
    TouchableOpacityProps | ViewProps
  >

  const { theme } = useAppTheme()

  const $imageStyle: StyleProp<ImageStyle> = [
    $imageStyleBase,
    { tintColor: color ?? theme.colors.text },
    size !== undefined && { width: size, height: size },
    $imageStyleOverride,
  ]

  return (
    <Wrapper
      accessibilityRole={isPressable ? "imagebutton" : undefined}
      {...WrapperProps}
      style={$containerStyleOverride}
    >
      <Image style={$imageStyle} source={iconRegistry[icon]} />
    </Wrapper>
  )
}

export const iconRegistry = {
  back: require("../../assets/icons/back.png"),
  bell: require("../../assets/icons/bell.png"),
  caretLeft: require("../../assets/icons/caretLeft.png"),
  caretRight: require("../../assets/icons/caretRight.png"),
  check: require("../../assets/icons/check.png"),
  hidden: require("../../assets/icons/hidden.png"),
  ladybug: require("../../assets/icons/ladybug.png"),
  lock: require("../../assets/icons/lock.png"),
  menu: require("../../assets/icons/menu.png"),
  more: require("../../assets/icons/more.png"),
  settings: require("../../assets/icons/settings.png"),
  view: require("../../assets/icons/view.png"),
  x: require("../../assets/icons/x.png"),
}

const $imageStyleBase: ImageStyle = {
  resizeMode: "contain",
}

================
File: app/components/index.ts
================
export * from "./AutoImage"
export * from "./Button"
export * from "./Card"
export * from "./Header"
export * from "./Icon"
export * from "./ListItem"
export * from "./ListView"
export * from "./Screen"
export * from "./Text"
export * from "./TextField"
export * from "./Toggle"
export * from "./EmptyState"

================
File: app/components/ListItem.tsx
================
import { forwardRef, ReactElement } from "react"
import {
  StyleProp,
  TextStyle,
  TouchableOpacity,
  TouchableOpacityProps,
  View,
  ViewStyle,
} from "react-native"
import { $styles } from "../theme"
import { Icon, IconTypes } from "./Icon"
import { Text, TextProps } from "./Text"
import type { ThemedStyle } from "@/theme"
import { useAppTheme } from "@/utils/useAppTheme"

export interface ListItemProps extends TouchableOpacityProps {
  /**
   * How tall the list item should be.
   * Default: 56
   */
  height?: number
  /**
   * Whether to show the top separator.
   * Default: false
   */
  topSeparator?: boolean
  /**
   * Whether to show the bottom separator.
   * Default: false
   */
  bottomSeparator?: boolean
  /**
   * Text to display if not using `tx` or nested components.
   */
  text?: TextProps["text"]
  /**
   * Text which is looked up via i18n.
   */
  tx?: TextProps["tx"]
  /**
   * Children components.
   */
  children?: TextProps["children"]
  /**
   * Optional options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  txOptions?: TextProps["txOptions"]
  /**
   * Optional text style override.
   */
  textStyle?: StyleProp<TextStyle>
  /**
   * Pass any additional props directly to the Text component.
   */
  TextProps?: TextProps
  /**
   * Optional View container style override.
   */
  containerStyle?: StyleProp<ViewStyle>
  /**
   * Optional TouchableOpacity style override.
   */
  style?: StyleProp<ViewStyle>
  /**
   * Icon that should appear on the left.
   */
  leftIcon?: IconTypes
  /**
   * An optional tint color for the left icon
   */
  leftIconColor?: string
  /**
   * Icon that should appear on the right.
   */
  rightIcon?: IconTypes
  /**
   * An optional tint color for the right icon
   */
  rightIconColor?: string
  /**
   * Right action custom ReactElement.
   * Overrides `rightIcon`.
   */
  RightComponent?: ReactElement
  /**
   * Left action custom ReactElement.
   * Overrides `leftIcon`.
   */
  LeftComponent?: ReactElement
}

interface ListItemActionProps {
  icon?: IconTypes
  iconColor?: string
  Component?: ReactElement
  size: number
  side: "left" | "right"
}

/**
 * A styled row component that can be used in FlatList, SectionList, or by itself.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/ListItem/}
 * @param {ListItemProps} props - The props for the `ListItem` component.
 * @returns {JSX.Element} The rendered `ListItem` component.
 */
export const ListItem = forwardRef<View, ListItemProps>(function ListItem(
  props: ListItemProps,
  ref,
) {
  const {
    bottomSeparator,
    children,
    height = 56,
    LeftComponent,
    leftIcon,
    leftIconColor,
    RightComponent,
    rightIcon,
    rightIconColor,
    style,
    text,
    TextProps,
    topSeparator,
    tx,
    txOptions,
    textStyle: $textStyleOverride,
    containerStyle: $containerStyleOverride,
    ...TouchableOpacityProps
  } = props
  const { themed } = useAppTheme()

  const $textStyles = [$textStyle, $textStyleOverride, TextProps?.style]

  const $containerStyles = [
    topSeparator && $separatorTop,
    bottomSeparator && $separatorBottom,
    $containerStyleOverride,
  ]

  const $touchableStyles = [$styles.row, $touchableStyle, { minHeight: height }, style]

  return (
    <View ref={ref} style={themed($containerStyles)}>
      <TouchableOpacity {...TouchableOpacityProps} style={$touchableStyles}>
        <ListItemAction
          side="left"
          size={height}
          icon={leftIcon}
          iconColor={leftIconColor}
          Component={LeftComponent}
        />

        <Text {...TextProps} tx={tx} text={text} txOptions={txOptions} style={themed($textStyles)}>
          {children}
        </Text>

        <ListItemAction
          side="right"
          size={height}
          icon={rightIcon}
          iconColor={rightIconColor}
          Component={RightComponent}
        />
      </TouchableOpacity>
    </View>
  )
})

/**
 * @param {ListItemActionProps} props - The props for the `ListItemAction` component.
 * @returns {JSX.Element | null} The rendered `ListItemAction` component.
 */
function ListItemAction(props: ListItemActionProps) {
  const { icon, Component, iconColor, size, side } = props
  const { themed } = useAppTheme()

  const $iconContainerStyles = [$iconContainer]

  if (Component) return Component

  if (icon !== undefined) {
    return (
      <Icon
        size={24}
        icon={icon}
        color={iconColor}
        containerStyle={themed([
          $iconContainerStyles,
          side === "left" && $iconContainerLeft,
          side === "right" && $iconContainerRight,
          { height: size },
        ])}
      />
    )
  }

  return null
}

const $separatorTop: ThemedStyle<ViewStyle> = ({ colors }) => ({
  borderTopWidth: 1,
  borderTopColor: colors.separator,
})

const $separatorBottom: ThemedStyle<ViewStyle> = ({ colors }) => ({
  borderBottomWidth: 1,
  borderBottomColor: colors.separator,
})

const $textStyle: ThemedStyle<TextStyle> = ({ spacing }) => ({
  paddingVertical: spacing.xs,
  alignSelf: "center",
  flexGrow: 1,
  flexShrink: 1,
})

const $touchableStyle: ViewStyle = {
  alignItems: "flex-start",
}

const $iconContainer: ViewStyle = {
  justifyContent: "center",
  alignItems: "center",
  flexGrow: 0,
}
const $iconContainerLeft: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginEnd: spacing.md,
})

const $iconContainerRight: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginStart: spacing.md,
})

================
File: app/components/ListView.tsx
================
import { ForwardedRef, forwardRef, PropsWithoutRef, ReactElement, RefObject } from "react"
import { FlatList } from "react-native"
import { isRTL } from "@/i18n"
import { FlashList, FlashListProps } from "@shopify/flash-list"

export type ListViewRef<T> = FlashList<T> | FlatList<T>

export type ListViewProps<T> = PropsWithoutRef<FlashListProps<T>>

/**
 * This is a Higher Order Component meant to ease the pain of using @shopify/flash-list
 * when there is a chance that a user would have their device language set to an
 * RTL language like Arabic or Persian. This component will use react-native's
 * FlatList if the user's language is RTL or FlashList if the user's language is LTR.
 *
 * Because FlashList's props are a superset of FlatList's, you must pass estimatedItemSize
 * to this component if you want to use it.
 *
 * This is a temporary workaround until the FlashList component supports RTL at
 * which point this component can be removed and we will default to using FlashList everywhere.
 * @see {@link https://github.com/Shopify/flash-list/issues/544|RTL Bug Android}
 * @see {@link https://github.com/Shopify/flash-list/issues/840|Flashlist Not Support RTL}
 * @param {FlashListProps | FlatListProps} props - The props for the `ListView` component.
 * @param {RefObject<ListViewRef>} forwardRef - An optional forwarded ref.
 * @returns {JSX.Element} The rendered `ListView` component.
 */
const ListViewComponent = forwardRef(
  <T,>(props: ListViewProps<T>, ref: ForwardedRef<ListViewRef<T>>) => {
    const ListComponentWrapper = isRTL ? FlatList : FlashList

    return <ListComponentWrapper {...props} ref={ref} />
  },
)

ListViewComponent.displayName = "ListView"

export const ListView = ListViewComponent as <T>(
  props: ListViewProps<T> & {
    ref?: RefObject<ListViewRef<T>>
  },
) => ReactElement

================
File: app/components/Screen.tsx
================
import { useScrollToTop } from "@react-navigation/native"
import { StatusBar, StatusBarProps, StatusBarStyle } from "expo-status-bar"
import { ReactNode, useRef, useState } from "react"
import {
  KeyboardAvoidingView,
  KeyboardAvoidingViewProps,
  LayoutChangeEvent,
  Platform,
  ScrollView,
  ScrollViewProps,
  StyleProp,
  View,
  ViewStyle,
} from "react-native"
import { $styles } from "../theme"
import { ExtendedEdge, useSafeAreaInsetsStyle } from "../utils/useSafeAreaInsetsStyle"
import { KeyboardAwareScrollView } from "react-native-keyboard-controller"
import { useAppTheme } from "@/utils/useAppTheme"

export const DEFAULT_BOTTOM_OFFSET = 50

interface BaseScreenProps {
  /**
   * Children components.
   */
  children?: ReactNode
  /**
   * Style for the outer content container useful for padding & margin.
   */
  style?: StyleProp<ViewStyle>
  /**
   * Style for the inner content container useful for padding & margin.
   */
  contentContainerStyle?: StyleProp<ViewStyle>
  /**
   * Override the default edges for the safe area.
   */
  safeAreaEdges?: ExtendedEdge[]
  /**
   * Background color
   */
  backgroundColor?: string
  /**
   * Status bar setting. Defaults to dark.
   */
  statusBarStyle?: StatusBarStyle
  /**
   * By how much should we offset the keyboard? Defaults to 0.
   */
  keyboardOffset?: number
  /**
   * By how much we scroll up when the keyboard is shown. Defaults to 50.
   */
  keyboardBottomOffset?: number
  /**
   * Pass any additional props directly to the StatusBar component.
   */
  StatusBarProps?: StatusBarProps
  /**
   * Pass any additional props directly to the KeyboardAvoidingView component.
   */
  KeyboardAvoidingViewProps?: KeyboardAvoidingViewProps
}

interface FixedScreenProps extends BaseScreenProps {
  preset?: "fixed"
}
interface ScrollScreenProps extends BaseScreenProps {
  preset?: "scroll"
  /**
   * Should keyboard persist on screen tap. Defaults to handled.
   * Only applies to scroll preset.
   */
  keyboardShouldPersistTaps?: "handled" | "always" | "never"
  /**
   * Pass any additional props directly to the ScrollView component.
   */
  ScrollViewProps?: ScrollViewProps
}

interface AutoScreenProps extends Omit<ScrollScreenProps, "preset"> {
  preset?: "auto"
  /**
   * Threshold to trigger the automatic disabling/enabling of scroll ability.
   * Defaults to `{ percent: 0.92 }`.
   */
  scrollEnabledToggleThreshold?: { percent?: number; point?: number }
}

export type ScreenProps = ScrollScreenProps | FixedScreenProps | AutoScreenProps

const isIos = Platform.OS === "ios"

type ScreenPreset = "fixed" | "scroll" | "auto"

/**
 * @param {ScreenPreset?} preset - The preset to check.
 * @returns {boolean} - Whether the preset is non-scrolling.
 */
function isNonScrolling(preset?: ScreenPreset) {
  return !preset || preset === "fixed"
}

/**
 * Custom hook that handles the automatic enabling/disabling of scroll ability based on the content size and screen size.
 * @param {UseAutoPresetProps} props - The props for the `useAutoPreset` hook.
 * @returns {{boolean, Function, Function}} - The scroll state, and the `onContentSizeChange` and `onLayout` functions.
 */
function useAutoPreset(props: AutoScreenProps): {
  scrollEnabled: boolean
  onContentSizeChange: (w: number, h: number) => void
  onLayout: (e: LayoutChangeEvent) => void
} {
  const { preset, scrollEnabledToggleThreshold } = props
  const { percent = 0.92, point = 0 } = scrollEnabledToggleThreshold || {}

  const scrollViewHeight = useRef<null | number>(null)
  const scrollViewContentHeight = useRef<null | number>(null)
  const [scrollEnabled, setScrollEnabled] = useState(true)

  function updateScrollState() {
    if (scrollViewHeight.current === null || scrollViewContentHeight.current === null) return

    // check whether content fits the screen then toggle scroll state according to it
    const contentFitsScreen = (function () {
      if (point) {
        return scrollViewContentHeight.current < scrollViewHeight.current - point
      } else {
        return scrollViewContentHeight.current < scrollViewHeight.current * percent
      }
    })()

    // content is less than the size of the screen, so we can disable scrolling
    if (scrollEnabled && contentFitsScreen) setScrollEnabled(false)

    // content is greater than the size of the screen, so let's enable scrolling
    if (!scrollEnabled && !contentFitsScreen) setScrollEnabled(true)
  }

  /**
   * @param {number} w - The width of the content.
   * @param {number} h - The height of the content.
   */
  function onContentSizeChange(w: number, h: number) {
    // update scroll-view content height
    scrollViewContentHeight.current = h
    updateScrollState()
  }

  /**
   * @param {LayoutChangeEvent} e = The layout change event.
   */
  function onLayout(e: LayoutChangeEvent) {
    const { height } = e.nativeEvent.layout
    // update scroll-view  height
    scrollViewHeight.current = height
    updateScrollState()
  }

  // update scroll state on every render
  if (preset === "auto") updateScrollState()

  return {
    scrollEnabled: preset === "auto" ? scrollEnabled : true,
    onContentSizeChange,
    onLayout,
  }
}

/**
 * @param {ScreenProps} props - The props for the `ScreenWithoutScrolling` component.
 * @returns {JSX.Element} - The rendered `ScreenWithoutScrolling` component.
 */
function ScreenWithoutScrolling(props: ScreenProps) {
  const { style, contentContainerStyle, children, preset } = props
  return (
    <View style={[$outerStyle, style]}>
      <View style={[$innerStyle, preset === "fixed" && $justifyFlexEnd, contentContainerStyle]}>
        {children}
      </View>
    </View>
  )
}

/**
 * @param {ScreenProps} props - The props for the `ScreenWithScrolling` component.
 * @returns {JSX.Element} - The rendered `ScreenWithScrolling` component.
 */
function ScreenWithScrolling(props: ScreenProps) {
  const {
    children,
    keyboardShouldPersistTaps = "handled",
    keyboardBottomOffset = DEFAULT_BOTTOM_OFFSET,
    contentContainerStyle,
    ScrollViewProps,
    style,
  } = props as ScrollScreenProps

  const ref = useRef<ScrollView>(null)

  const { scrollEnabled, onContentSizeChange, onLayout } = useAutoPreset(props as AutoScreenProps)

  // Add native behavior of pressing the active tab to scroll to the top of the content
  // More info at: https://reactnavigation.org/docs/use-scroll-to-top/
  useScrollToTop(ref)

  return (
    <KeyboardAwareScrollView
      bottomOffset={keyboardBottomOffset}
      {...{ keyboardShouldPersistTaps, scrollEnabled, ref }}
      {...ScrollViewProps}
      onLayout={(e) => {
        onLayout(e)
        ScrollViewProps?.onLayout?.(e)
      }}
      onContentSizeChange={(w: number, h: number) => {
        onContentSizeChange(w, h)
        ScrollViewProps?.onContentSizeChange?.(w, h)
      }}
      style={[$outerStyle, ScrollViewProps?.style, style]}
      contentContainerStyle={[
        $innerStyle,
        ScrollViewProps?.contentContainerStyle,
        contentContainerStyle,
      ]}
    >
      {children}
    </KeyboardAwareScrollView>
  )
}

/**
 * Represents a screen component that provides a consistent layout and behavior for different screen presets.
 * The `Screen` component can be used with different presets such as "fixed", "scroll", or "auto".
 * It handles safe area insets, status bar settings, keyboard avoiding behavior, and scrollability based on the preset.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Screen/}
 * @param {ScreenProps} props - The props for the `Screen` component.
 * @returns {JSX.Element} The rendered `Screen` component.
 */
export function Screen(props: ScreenProps) {
  const {
    theme: { colors },
    themeContext,
  } = useAppTheme()
  const {
    backgroundColor,
    KeyboardAvoidingViewProps,
    keyboardOffset = 0,
    safeAreaEdges,
    StatusBarProps,
    statusBarStyle,
  } = props

  const $containerInsets = useSafeAreaInsetsStyle(safeAreaEdges)

  return (
    <View
      style={[
        $containerStyle,
        { backgroundColor: backgroundColor || colors.background },
        $containerInsets,
      ]}
    >
      <StatusBar
        style={statusBarStyle || (themeContext === "dark" ? "light" : "dark")}
        {...StatusBarProps}
      />

      <KeyboardAvoidingView
        behavior={isIos ? "padding" : "height"}
        keyboardVerticalOffset={keyboardOffset}
        {...KeyboardAvoidingViewProps}
        style={[$styles.flex1, KeyboardAvoidingViewProps?.style]}
      >
        {isNonScrolling(props.preset) ? (
          <ScreenWithoutScrolling {...props} />
        ) : (
          <ScreenWithScrolling {...props} />
        )}
      </KeyboardAvoidingView>
    </View>
  )
}

const $containerStyle: ViewStyle = {
  flex: 1,
  height: "100%",
  width: "100%",
}

const $outerStyle: ViewStyle = {
  flex: 1,
  height: "100%",
  width: "100%",
}

const $justifyFlexEnd: ViewStyle = {
  justifyContent: "flex-end",
}

const $innerStyle: ViewStyle = {
  justifyContent: "flex-start",
  alignItems: "stretch",
}

================
File: app/components/Text.test.tsx
================
import { render } from "@testing-library/react-native"
import { Text } from "./Text"

/* This is an example component test using react-native-testing-library. For more
 * information on how to write your own, see the documentation here:
 * https://callstack.github.io/react-native-testing-library/ */
const testText = "Test string"

describe("Text", () => {
  it("should render the component", () => {
    const { getByText } = render(<Text text={testText} />)
    expect(getByText(testText)).toBeDefined()
  })
})

================
File: app/components/Text.tsx
================
import { TOptions } from "i18next"
import { StyleProp, Text as RNText, TextProps as RNTextProps, TextStyle } from "react-native"
import { isRTL, translate, TxKeyPath } from "@/i18n"
import type { ThemedStyle, ThemedStyleArray } from "@/theme"
import { useAppTheme } from "@/utils/useAppTheme"
import { typography } from "@/theme/typography"
import { ReactNode } from "react"

type Sizes = keyof typeof $sizeStyles
type Weights = keyof typeof typography.primary
type Presets = "default" | "bold" | "heading" | "subheading" | "formLabel" | "formHelper"

export interface TextProps extends RNTextProps {
  /**
   * Text which is looked up via i18n.
   */
  tx?: TxKeyPath
  /**
   * The text to display if not using `tx` or nested components.
   */
  text?: string
  /**
   * Optional options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  txOptions?: TOptions
  /**
   * An optional style override useful for padding & margin.
   */
  style?: StyleProp<TextStyle>
  /**
   * One of the different types of text presets.
   */
  preset?: Presets
  /**
   * Text weight modifier.
   */
  weight?: Weights
  /**
   * Text size modifier.
   */
  size?: Sizes
  /**
   * Children components.
   */
  children?: ReactNode
}

/**
 * For your text displaying needs.
 * This component is a HOC over the built-in React Native one.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Text/}
 * @param {TextProps} props - The props for the `Text` component.
 * @returns {JSX.Element} The rendered `Text` component.
 */
export function Text(props: TextProps) {
  const { weight, size, tx, txOptions, text, children, style: $styleOverride, ...rest } = props
  const { themed } = useAppTheme()

  const i18nText = tx && translate(tx, txOptions)
  const content = i18nText || text || children

  const preset: Presets = props.preset ?? "default"
  const $styles: StyleProp<TextStyle> = [
    $rtlStyle,
    themed($presets[preset]),
    weight && $fontWeightStyles[weight],
    size && $sizeStyles[size],
    $styleOverride,
  ]

  return (
    <RNText {...rest} style={$styles}>
      {content}
    </RNText>
  )
}

const $sizeStyles = {
  xxl: { fontSize: 36, lineHeight: 44 } satisfies TextStyle,
  xl: { fontSize: 24, lineHeight: 34 } satisfies TextStyle,
  lg: { fontSize: 20, lineHeight: 32 } satisfies TextStyle,
  md: { fontSize: 18, lineHeight: 26 } satisfies TextStyle,
  sm: { fontSize: 16, lineHeight: 24 } satisfies TextStyle,
  xs: { fontSize: 14, lineHeight: 21 } satisfies TextStyle,
  xxs: { fontSize: 12, lineHeight: 18 } satisfies TextStyle,
}

const $fontWeightStyles = Object.entries(typography.primary).reduce((acc, [weight, fontFamily]) => {
  return { ...acc, [weight]: { fontFamily } }
}, {}) as Record<Weights, TextStyle>

const $baseStyle: ThemedStyle<TextStyle> = (theme) => ({
  ...$sizeStyles.sm,
  ...$fontWeightStyles.normal,
  color: theme.colors.text,
})

const $presets: Record<Presets, ThemedStyleArray<TextStyle>> = {
  default: [$baseStyle],
  bold: [$baseStyle, { ...$fontWeightStyles.bold }],
  heading: [
    $baseStyle,
    {
      ...$sizeStyles.xxl,
      ...$fontWeightStyles.bold,
    },
  ],
  subheading: [$baseStyle, { ...$sizeStyles.lg, ...$fontWeightStyles.medium }],
  formLabel: [$baseStyle, { ...$fontWeightStyles.medium }],
  formHelper: [$baseStyle, { ...$sizeStyles.sm, ...$fontWeightStyles.normal }],
}
const $rtlStyle: TextStyle = isRTL ? { writingDirection: "rtl" } : {}

================
File: app/components/TextField.tsx
================
import { ComponentType, forwardRef, Ref, useImperativeHandle, useRef } from "react"
import {
  ImageStyle,
  StyleProp,
  TextInput,
  TextInputProps,
  TextStyle,
  TouchableOpacity,
  View,
  ViewStyle,
} from "react-native"
import { isRTL, translate } from "@/i18n"
import type { ThemedStyle, ThemedStyleArray } from "@/theme"
import { $styles } from "../theme"
import { Text, TextProps } from "./Text"
import { useAppTheme } from "@/utils/useAppTheme"

export interface TextFieldAccessoryProps {
  style: StyleProp<ViewStyle | TextStyle | ImageStyle>
  status: TextFieldProps["status"]
  multiline: boolean
  editable: boolean
}

export interface TextFieldProps extends Omit<TextInputProps, "ref"> {
  /**
   * A style modifier for different input states.
   */
  status?: "error" | "disabled"
  /**
   * The label text to display if not using `labelTx`.
   */
  label?: TextProps["text"]
  /**
   * Label text which is looked up via i18n.
   */
  labelTx?: TextProps["tx"]
  /**
   * Optional label options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  labelTxOptions?: TextProps["txOptions"]
  /**
   * Pass any additional props directly to the label Text component.
   */
  LabelTextProps?: TextProps
  /**
   * The helper text to display if not using `helperTx`.
   */
  helper?: TextProps["text"]
  /**
   * Helper text which is looked up via i18n.
   */
  helperTx?: TextProps["tx"]
  /**
   * Optional helper options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  helperTxOptions?: TextProps["txOptions"]
  /**
   * Pass any additional props directly to the helper Text component.
   */
  HelperTextProps?: TextProps
  /**
   * The placeholder text to display if not using `placeholderTx`.
   */
  placeholder?: TextProps["text"]
  /**
   * Placeholder text which is looked up via i18n.
   */
  placeholderTx?: TextProps["tx"]
  /**
   * Optional placeholder options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  placeholderTxOptions?: TextProps["txOptions"]
  /**
   * Optional input style override.
   */
  style?: StyleProp<TextStyle>
  /**
   * Style overrides for the container
   */
  containerStyle?: StyleProp<ViewStyle>
  /**
   * Style overrides for the input wrapper
   */
  inputWrapperStyle?: StyleProp<ViewStyle>
  /**
   * An optional component to render on the right side of the input.
   * Example: `RightAccessory={(props) => <Icon icon="ladybug" containerStyle={props.style} color={props.editable ? colors.textDim : colors.text} />}`
   * Note: It is a good idea to memoize this.
   */
  RightAccessory?: ComponentType<TextFieldAccessoryProps>
  /**
   * An optional component to render on the left side of the input.
   * Example: `LeftAccessory={(props) => <Icon icon="ladybug" containerStyle={props.style} color={props.editable ? colors.textDim : colors.text} />}`
   * Note: It is a good idea to memoize this.
   */
  LeftAccessory?: ComponentType<TextFieldAccessoryProps>
}

/**
 * A component that allows for the entering and editing of text.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/TextField/}
 * @param {TextFieldProps} props - The props for the `TextField` component.
 * @returns {JSX.Element} The rendered `TextField` component.
 */
export const TextField = forwardRef(function TextField(props: TextFieldProps, ref: Ref<TextInput>) {
  const {
    labelTx,
    label,
    labelTxOptions,
    placeholderTx,
    placeholder,
    placeholderTxOptions,
    helper,
    helperTx,
    helperTxOptions,
    status,
    RightAccessory,
    LeftAccessory,
    HelperTextProps,
    LabelTextProps,
    style: $inputStyleOverride,
    containerStyle: $containerStyleOverride,
    inputWrapperStyle: $inputWrapperStyleOverride,
    ...TextInputProps
  } = props
  const input = useRef<TextInput>(null)

  const {
    themed,
    theme: { colors },
  } = useAppTheme()

  const disabled = TextInputProps.editable === false || status === "disabled"

  const placeholderContent = placeholderTx
    ? translate(placeholderTx, placeholderTxOptions)
    : placeholder

  const $containerStyles = [$containerStyleOverride]

  const $labelStyles = [$labelStyle, LabelTextProps?.style]

  const $inputWrapperStyles = [
    $styles.row,
    $inputWrapperStyle,
    status === "error" && { borderColor: colors.error },
    TextInputProps.multiline && { minHeight: 112 },
    LeftAccessory && { paddingStart: 0 },
    RightAccessory && { paddingEnd: 0 },
    $inputWrapperStyleOverride,
  ]

  const $inputStyles: ThemedStyleArray<TextStyle> = [
    $inputStyle,
    disabled && { color: colors.textDim },
    isRTL && { textAlign: "right" as TextStyle["textAlign"] },
    TextInputProps.multiline && { height: "auto" },
    $inputStyleOverride,
  ]

  const $helperStyles = [
    $helperStyle,
    status === "error" && { color: colors.error },
    HelperTextProps?.style,
  ]

  /**
   *
   */
  function focusInput() {
    if (disabled) return

    input.current?.focus()
  }

  useImperativeHandle(ref, () => input.current as TextInput)

  return (
    <TouchableOpacity
      activeOpacity={1}
      style={$containerStyles}
      onPress={focusInput}
      accessibilityState={{ disabled }}
    >
      {!!(label || labelTx) && (
        <Text
          preset="formLabel"
          text={label}
          tx={labelTx}
          txOptions={labelTxOptions}
          {...LabelTextProps}
          style={themed($labelStyles)}
        />
      )}

      <View style={themed($inputWrapperStyles)}>
        {!!LeftAccessory && (
          <LeftAccessory
            style={themed($leftAccessoryStyle)}
            status={status}
            editable={!disabled}
            multiline={TextInputProps.multiline ?? false}
          />
        )}

        <TextInput
          ref={input}
          underlineColorAndroid={colors.transparent}
          textAlignVertical="top"
          placeholder={placeholderContent}
          placeholderTextColor={colors.textDim}
          {...TextInputProps}
          editable={!disabled}
          style={themed($inputStyles)}
        />

        {!!RightAccessory && (
          <RightAccessory
            style={themed($rightAccessoryStyle)}
            status={status}
            editable={!disabled}
            multiline={TextInputProps.multiline ?? false}
          />
        )}
      </View>

      {!!(helper || helperTx) && (
        <Text
          preset="formHelper"
          text={helper}
          tx={helperTx}
          txOptions={helperTxOptions}
          {...HelperTextProps}
          style={themed($helperStyles)}
        />
      )}
    </TouchableOpacity>
  )
})

const $labelStyle: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginBottom: spacing.xs,
})

const $inputWrapperStyle: ThemedStyle<ViewStyle> = ({ colors }) => ({
  alignItems: "flex-start",
  borderWidth: 1,
  borderRadius: 4,
  backgroundColor: colors.palette.neutral200,
  borderColor: colors.palette.neutral400,
  overflow: "hidden",
})

const $inputStyle: ThemedStyle<ViewStyle> = ({ colors, typography, spacing }) => ({
  flex: 1,
  alignSelf: "stretch",
  fontFamily: typography.primary.normal,
  color: colors.text,
  fontSize: 16,
  height: 24,
  // https://github.com/facebook/react-native/issues/21720#issuecomment-532642093
  paddingVertical: 0,
  paddingHorizontal: 0,
  marginVertical: spacing.xs,
  marginHorizontal: spacing.sm,
})

const $helperStyle: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginTop: spacing.xs,
})

const $rightAccessoryStyle: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginEnd: spacing.xs,
  height: 40,
  justifyContent: "center",
  alignItems: "center",
})

const $leftAccessoryStyle: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginStart: spacing.xs,
  height: 40,
  justifyContent: "center",
  alignItems: "center",
})

================
File: app/components/Toggle/Checkbox.tsx
================
import { useEffect, useRef, useCallback } from "react"
import { Image, ImageStyle, Animated, StyleProp, View, ViewStyle } from "react-native"
import { $styles } from "../../theme"
import { iconRegistry, IconTypes } from "../Icon"
import { $inputOuterBase, BaseToggleInputProps, ToggleProps, Toggle } from "./Toggle"
import { useAppTheme } from "@/utils/useAppTheme"

export interface CheckboxToggleProps extends Omit<ToggleProps<CheckboxInputProps>, "ToggleInput"> {
  /**
   * Optional style prop that affects the Image component.
   */
  inputDetailStyle?: ImageStyle
  /**
   * Checkbox-only prop that changes the icon used for the "on" state.
   */
  icon?: IconTypes
}

interface CheckboxInputProps extends BaseToggleInputProps<CheckboxToggleProps> {
  icon?: CheckboxToggleProps["icon"]
}
/**
 * @param {CheckboxToggleProps} props - The props for the `Checkbox` component.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Checkbox}
 * @returns {JSX.Element} The rendered `Checkbox` component.
 */
export function Checkbox(props: CheckboxToggleProps) {
  const { icon, ...rest } = props
  const checkboxInput = useCallback(
    (toggleProps: CheckboxInputProps) => <CheckboxInput {...toggleProps} icon={icon} />,
    [icon],
  )
  return <Toggle accessibilityRole="checkbox" {...rest} ToggleInput={checkboxInput} />
}

function CheckboxInput(props: CheckboxInputProps) {
  const {
    on,
    status,
    disabled,
    icon = "check",
    outerStyle: $outerStyleOverride,
    innerStyle: $innerStyleOverride,
    detailStyle: $detailStyleOverride,
  } = props

  const {
    theme: { colors },
  } = useAppTheme()

  const opacity = useRef(new Animated.Value(0))

  useEffect(() => {
    Animated.timing(opacity.current, {
      toValue: on ? 1 : 0,
      duration: 300,
      useNativeDriver: true,
    }).start()
  }, [on])

  const offBackgroundColor = [
    disabled && colors.palette.neutral400,
    status === "error" && colors.errorBackground,
    colors.palette.neutral200,
  ].filter(Boolean)[0]

  const outerBorderColor = [
    disabled && colors.palette.neutral400,
    status === "error" && colors.error,
    !on && colors.palette.neutral800,
    colors.palette.secondary500,
  ].filter(Boolean)[0]

  const onBackgroundColor = [
    disabled && colors.transparent,
    status === "error" && colors.errorBackground,
    colors.palette.secondary500,
  ].filter(Boolean)[0]

  const iconTintColor = [
    disabled && colors.palette.neutral600,
    status === "error" && colors.error,
    colors.palette.accent100,
  ].filter(Boolean)[0]

  return (
    <View
      style={[
        $inputOuter,
        { backgroundColor: offBackgroundColor, borderColor: outerBorderColor },
        $outerStyleOverride,
      ]}
    >
      <Animated.View
        style={[
          $styles.toggleInner,
          { backgroundColor: onBackgroundColor },
          $innerStyleOverride,
          { opacity: opacity.current },
        ]}
      >
        <Image
          source={icon ? iconRegistry[icon] : iconRegistry.check}
          style={[
            $checkboxDetail,
            !!iconTintColor && { tintColor: iconTintColor },
            $detailStyleOverride,
          ]}
        />
      </Animated.View>
    </View>
  )
}

const $checkboxDetail: ImageStyle = {
  width: 20,
  height: 20,
  resizeMode: "contain",
}

const $inputOuter: StyleProp<ViewStyle> = [$inputOuterBase, { borderRadius: 4 }]

================
File: app/components/Toggle/index.ts
================
export * from "./Checkbox"
export * from "./Radio"
export * from "./Switch"

================
File: app/components/Toggle/Radio.tsx
================
import { useEffect, useRef } from "react"
import { StyleProp, View, ViewStyle, Animated } from "react-native"
import { $styles } from "../../theme"
import { $inputOuterBase, BaseToggleInputProps, ToggleProps, Toggle } from "./Toggle"
import { useAppTheme } from "@/utils/useAppTheme"

export interface RadioToggleProps extends Omit<ToggleProps<RadioInputProps>, "ToggleInput"> {
  /**
   * Optional style prop that affects the dot View.
   */
  inputDetailStyle?: ViewStyle
}

interface RadioInputProps extends BaseToggleInputProps<RadioToggleProps> {}

/**
 * @param {RadioToggleProps} props - The props for the `Radio` component.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Radio}
 * @returns {JSX.Element} The rendered `Radio` component.
 */
export function Radio(props: RadioToggleProps) {
  return <Toggle accessibilityRole="radio" {...props} ToggleInput={RadioInput} />
}

function RadioInput(props: RadioInputProps) {
  const {
    on,
    status,
    disabled,
    outerStyle: $outerStyleOverride,
    innerStyle: $innerStyleOverride,
    detailStyle: $detailStyleOverride,
  } = props

  const {
    theme: { colors },
  } = useAppTheme()

  const opacity = useRef(new Animated.Value(0))

  useEffect(() => {
    Animated.timing(opacity.current, {
      toValue: on ? 1 : 0,
      duration: 300,
      useNativeDriver: true,
    }).start()
  }, [on])

  const offBackgroundColor = [
    disabled && colors.palette.neutral400,
    status === "error" && colors.errorBackground,
    colors.palette.neutral200,
  ].filter(Boolean)[0]

  const outerBorderColor = [
    disabled && colors.palette.neutral400,
    status === "error" && colors.error,
    !on && colors.palette.neutral800,
    colors.palette.secondary500,
  ].filter(Boolean)[0]

  const onBackgroundColor = [
    disabled && colors.transparent,
    status === "error" && colors.errorBackground,
    colors.palette.neutral100,
  ].filter(Boolean)[0]

  const dotBackgroundColor = [
    disabled && colors.palette.neutral600,
    status === "error" && colors.error,
    colors.palette.secondary500,
  ].filter(Boolean)[0]

  return (
    <View
      style={[
        $inputOuter,
        { backgroundColor: offBackgroundColor, borderColor: outerBorderColor },
        $outerStyleOverride,
      ]}
    >
      <Animated.View
        style={[
          $styles.toggleInner,
          { backgroundColor: onBackgroundColor },
          $innerStyleOverride,
          { opacity: opacity.current },
        ]}
      >
        <View
          style={[$radioDetail, { backgroundColor: dotBackgroundColor }, $detailStyleOverride]}
        />
      </Animated.View>
    </View>
  )
}

const $radioDetail: ViewStyle = {
  width: 12,
  height: 12,
  borderRadius: 6,
}

const $inputOuter: StyleProp<ViewStyle> = [$inputOuterBase, { borderRadius: 12 }]

================
File: app/components/Toggle/Switch.tsx
================
import { useEffect, useMemo, useRef, useCallback } from "react"
import {
  Animated,
  Image,
  ImageStyle,
  Platform,
  StyleProp,
  TextStyle,
  View,
  ViewStyle,
} from "react-native"

import { $styles } from "@/theme"
import { iconRegistry } from "@/components/Icon"
import { isRTL } from "@/i18n"
import { $inputOuterBase, BaseToggleInputProps, Toggle, ToggleProps } from "./Toggle"
import { useAppTheme } from "@/utils/useAppTheme"
import type { ThemedStyle } from "@/theme"

export interface SwitchToggleProps extends Omit<ToggleProps<SwitchInputProps>, "ToggleInput"> {
  /**
   * Switch-only prop that adds a text/icon label for on/off states.
   */
  accessibilityMode?: "text" | "icon"
  /**
   * Optional style prop that affects the knob View.
   * Note: `width` and `height` rules should be points (numbers), not percentages.
   */
  inputDetailStyle?: Omit<ViewStyle, "width" | "height"> & { width?: number; height?: number }
}

interface SwitchInputProps extends BaseToggleInputProps<SwitchToggleProps> {
  accessibilityMode?: SwitchToggleProps["accessibilityMode"]
}

/**
 * @param {SwitchToggleProps} props - The props for the `Switch` component.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Switch}
 * @returns {JSX.Element} The rendered `Switch` component.
 */
export function Switch(props: SwitchToggleProps) {
  const { accessibilityMode, ...rest } = props
  const switchInput = useCallback(
    (toggleProps: SwitchInputProps) => (
      <SwitchInput {...toggleProps} accessibilityMode={accessibilityMode} />
    ),
    [accessibilityMode],
  )
  return <Toggle accessibilityRole="switch" {...rest} ToggleInput={switchInput} />
}

function SwitchInput(props: SwitchInputProps) {
  const {
    on,
    status,
    disabled,
    outerStyle: $outerStyleOverride,
    innerStyle: $innerStyleOverride,
    detailStyle: $detailStyleOverride,
  } = props

  const {
    theme: { colors },
    themed,
  } = useAppTheme()

  const animate = useRef(new Animated.Value(on ? 1 : 0)) // Initial value is set based on isActive
  const opacity = useRef(new Animated.Value(0))

  useEffect(() => {
    Animated.timing(animate.current, {
      toValue: on ? 1 : 0,
      duration: 300,
      useNativeDriver: true, // Enable native driver for smoother animations
    }).start()
  }, [on])

  useEffect(() => {
    Animated.timing(opacity.current, {
      toValue: on ? 1 : 0,
      duration: 300,
      useNativeDriver: true,
    }).start()
  }, [on])

  const knobSizeFallback = 2

  const knobWidth = [$detailStyleOverride?.width, $switchDetail?.width, knobSizeFallback].find(
    (v) => typeof v === "number",
  )

  const knobHeight = [$detailStyleOverride?.height, $switchDetail?.height, knobSizeFallback].find(
    (v) => typeof v === "number",
  )

  const offBackgroundColor = [
    disabled && colors.palette.neutral400,
    status === "error" && colors.errorBackground,
    colors.palette.neutral300,
  ].filter(Boolean)[0]

  const onBackgroundColor = [
    disabled && colors.transparent,
    status === "error" && colors.errorBackground,
    colors.palette.secondary500,
  ].filter(Boolean)[0]

  const knobBackgroundColor = (function () {
    if (on) {
      return [
        $detailStyleOverride?.backgroundColor,
        status === "error" && colors.error,
        disabled && colors.palette.neutral600,
        colors.palette.neutral100,
      ].filter(Boolean)[0]
    } else {
      return [
        $innerStyleOverride?.backgroundColor,
        disabled && colors.palette.neutral600,
        status === "error" && colors.error,
        colors.palette.neutral200,
      ].filter(Boolean)[0]
    }
  })()

  const rtlAdjustment = isRTL ? -1 : 1
  const $themedSwitchInner = useMemo(() => themed([$styles.toggleInner, $switchInner]), [themed])

  const offsetLeft = ($innerStyleOverride?.paddingStart ||
    $innerStyleOverride?.paddingLeft ||
    $themedSwitchInner?.paddingStart ||
    $themedSwitchInner?.paddingLeft ||
    0) as number

  const offsetRight = ($innerStyleOverride?.paddingEnd ||
    $innerStyleOverride?.paddingRight ||
    $themedSwitchInner?.paddingEnd ||
    $themedSwitchInner?.paddingRight ||
    0) as number

  const outputRange =
    Platform.OS === "web"
      ? isRTL
        ? [+(knobWidth || 0) + offsetRight, offsetLeft]
        : [offsetLeft, +(knobWidth || 0) + offsetRight]
      : [rtlAdjustment * offsetLeft, rtlAdjustment * (+(knobWidth || 0) + offsetRight)]

  const $animatedSwitchKnob = animate.current.interpolate({
    inputRange: [0, 1],
    outputRange,
  })

  return (
    <View style={[$inputOuter, { backgroundColor: offBackgroundColor }, $outerStyleOverride]}>
      <Animated.View
        style={[
          $themedSwitchInner,
          { backgroundColor: onBackgroundColor },
          $innerStyleOverride,
          { opacity: opacity.current },
        ]}
      />

      <SwitchAccessibilityLabel {...props} role="on" />
      <SwitchAccessibilityLabel {...props} role="off" />

      <Animated.View
        style={[
          $switchDetail,
          $detailStyleOverride,
          { transform: [{ translateX: $animatedSwitchKnob }] },
          { width: knobWidth, height: knobHeight },
          { backgroundColor: knobBackgroundColor },
        ]}
      />
    </View>
  )
}

/**
 * @param {ToggleInputProps & { role: "on" | "off" }} props - The props for the `SwitchAccessibilityLabel` component.
 * @returns {JSX.Element} The rendered `SwitchAccessibilityLabel` component.
 */
function SwitchAccessibilityLabel(props: SwitchInputProps & { role: "on" | "off" }) {
  const { on, disabled, status, accessibilityMode, role, innerStyle, detailStyle } = props

  const {
    theme: { colors },
  } = useAppTheme()

  if (!accessibilityMode) return null

  const shouldLabelBeVisible = (on && role === "on") || (!on && role === "off")

  const $switchAccessibilityStyle: StyleProp<ViewStyle> = [
    $switchAccessibility,
    role === "off" && { end: "5%" },
    role === "on" && { left: "5%" },
  ]

  const color = (function () {
    if (disabled) return colors.palette.neutral600
    if (status === "error") return colors.error
    if (!on) return innerStyle?.backgroundColor || colors.palette.secondary500
    return detailStyle?.backgroundColor || colors.palette.neutral100
  })()

  return (
    <View style={$switchAccessibilityStyle}>
      {accessibilityMode === "text" && shouldLabelBeVisible && (
        <View
          style={[
            role === "on" && $switchAccessibilityLine,
            role === "on" && { backgroundColor: color },
            role === "off" && $switchAccessibilityCircle,
            role === "off" && { borderColor: color },
          ]}
        />
      )}

      {accessibilityMode === "icon" && shouldLabelBeVisible && (
        <Image
          style={[$switchAccessibilityIcon, { tintColor: color }]}
          source={role === "off" ? iconRegistry.hidden : iconRegistry.view}
        />
      )}
    </View>
  )
}

const $inputOuter: StyleProp<ViewStyle> = [
  $inputOuterBase,
  { height: 32, width: 56, borderRadius: 16, borderWidth: 0 },
]

const $switchInner: ThemedStyle<ViewStyle> = ({ colors }) => ({
  borderColor: colors.transparent,
  position: "absolute",
  paddingStart: 4,
  paddingEnd: 4,
})

const $switchDetail: SwitchToggleProps["inputDetailStyle"] = {
  borderRadius: 12,
  position: "absolute",
  width: 24,
  height: 24,
}

const $switchAccessibility: TextStyle = {
  width: "40%",
  justifyContent: "center",
  alignItems: "center",
}

const $switchAccessibilityIcon: ImageStyle = {
  width: 14,
  height: 14,
  resizeMode: "contain",
}

const $switchAccessibilityLine: ViewStyle = {
  width: 2,
  height: 12,
}

const $switchAccessibilityCircle: ViewStyle = {
  borderWidth: 2,
  width: 12,
  height: 12,
  borderRadius: 6,
}

================
File: app/components/Toggle/Toggle.tsx
================
import { ComponentType, FC, useMemo } from "react"
import {
  GestureResponderEvent,
  ImageStyle,
  StyleProp,
  SwitchProps,
  TextInputProps,
  TextStyle,
  TouchableOpacity,
  TouchableOpacityProps,
  View,
  ViewProps,
  ViewStyle,
} from "react-native"
import { $styles } from "../../theme"
import { Text, TextProps } from "../Text"
import { useAppTheme } from "@/utils/useAppTheme"
import type { ThemedStyle } from "@/theme"

export interface ToggleProps<T> extends Omit<TouchableOpacityProps, "style"> {
  /**
   * A style modifier for different input states.
   */
  status?: "error" | "disabled"
  /**
   * If false, input is not editable. The default value is true.
   */
  editable?: TextInputProps["editable"]
  /**
   * The value of the field. If true the component will be turned on.
   */
  value?: boolean
  /**
   * Invoked with the new value when the value changes.
   */
  onValueChange?: SwitchProps["onValueChange"]
  /**
   * Style overrides for the container
   */
  containerStyle?: StyleProp<ViewStyle>
  /**
   * Style overrides for the input wrapper
   */
  inputWrapperStyle?: StyleProp<ViewStyle>
  /**
   * Optional input wrapper style override.
   * This gives the inputs their size, shape, "off" background-color, and outer border.
   */
  inputOuterStyle?: ViewStyle
  /**
   * Optional input style override.
   * This gives the inputs their inner characteristics and "on" background-color.
   */
  inputInnerStyle?: ViewStyle
  /**
   * Optional detail style override.
   * See Checkbox, Radio, and Switch for more details
   */
  inputDetailStyle?: ViewStyle
  /**
   * The position of the label relative to the action component.
   * Default: right
   */
  labelPosition?: "left" | "right"
  /**
   * The label text to display if not using `labelTx`.
   */
  label?: TextProps["text"]
  /**
   * Label text which is looked up via i18n.
   */
  labelTx?: TextProps["tx"]
  /**
   * Optional label options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  labelTxOptions?: TextProps["txOptions"]
  /**
   * Style overrides for label text.
   */
  labelStyle?: StyleProp<TextStyle>
  /**
   * Pass any additional props directly to the label Text component.
   */
  LabelTextProps?: TextProps
  /**
   * The helper text to display if not using `helperTx`.
   */
  helper?: TextProps["text"]
  /**
   * Helper text which is looked up via i18n.
   */
  helperTx?: TextProps["tx"]
  /**
   * Optional helper options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  helperTxOptions?: TextProps["txOptions"]
  /**
   * Pass any additional props directly to the helper Text component.
   */
  HelperTextProps?: TextProps
  /**
   * The input control for the type of toggle component
   */
  ToggleInput: FC<BaseToggleInputProps<T>>
}

export interface BaseToggleInputProps<T> {
  on: boolean
  status: ToggleProps<T>["status"]
  disabled: boolean
  outerStyle: ViewStyle
  innerStyle: ViewStyle
  detailStyle: Omit<ViewStyle & ImageStyle, "overflow">
}

/**
 * Renders a boolean input.
 * This is a controlled component that requires an onValueChange callback that updates the value prop in order for the component to reflect user actions. If the value prop is not updated, the component will continue to render the supplied value prop instead of the expected result of any user actions.
 * @param {ToggleProps} props - The props for the `Toggle` component.
 * @returns {JSX.Element} The rendered `Toggle` component.
 */
export function Toggle<T>(props: ToggleProps<T>) {
  const {
    editable = true,
    status,
    value,
    onPress,
    onValueChange,
    labelPosition = "right",
    helper,
    helperTx,
    helperTxOptions,
    HelperTextProps,
    containerStyle: $containerStyleOverride,
    inputWrapperStyle: $inputWrapperStyleOverride,
    ToggleInput,
    accessibilityRole,
    ...WrapperProps
  } = props

  const {
    theme: { colors },
    themed,
  } = useAppTheme()

  const disabled = editable === false || status === "disabled" || props.disabled

  const Wrapper = useMemo(
    () => (disabled ? View : TouchableOpacity) as ComponentType<TouchableOpacityProps | ViewProps>,
    [disabled],
  )

  const $containerStyles = [$containerStyleOverride]
  const $inputWrapperStyles = [$styles.row, $inputWrapper, $inputWrapperStyleOverride]
  const $helperStyles = themed([
    $helper,
    status === "error" && { color: colors.error },
    HelperTextProps?.style,
  ])

  /**
   * @param {GestureResponderEvent} e - The event object.
   */
  function handlePress(e: GestureResponderEvent) {
    if (disabled) return
    onValueChange?.(!value)
    onPress?.(e)
  }

  return (
    <Wrapper
      activeOpacity={1}
      accessibilityRole={accessibilityRole}
      accessibilityState={{ checked: value, disabled }}
      {...WrapperProps}
      style={$containerStyles}
      onPress={handlePress}
    >
      <View style={$inputWrapperStyles}>
        {labelPosition === "left" && <FieldLabel<T> {...props} labelPosition={labelPosition} />}

        <ToggleInput
          on={!!value}
          disabled={!!disabled}
          status={status}
          outerStyle={props.inputOuterStyle ?? {}}
          innerStyle={props.inputInnerStyle ?? {}}
          detailStyle={props.inputDetailStyle ?? {}}
        />

        {labelPosition === "right" && <FieldLabel<T> {...props} labelPosition={labelPosition} />}
      </View>

      {!!(helper || helperTx) && (
        <Text
          preset="formHelper"
          text={helper}
          tx={helperTx}
          txOptions={helperTxOptions}
          {...HelperTextProps}
          style={$helperStyles}
        />
      )}
    </Wrapper>
  )
}

/**
 * @param {ToggleProps} props - The props for the `FieldLabel` component.
 * @returns {JSX.Element} The rendered `FieldLabel` component.
 */
function FieldLabel<T>(props: ToggleProps<T>) {
  const {
    status,
    label,
    labelTx,
    labelTxOptions,
    LabelTextProps,
    labelPosition,
    labelStyle: $labelStyleOverride,
  } = props

  const {
    theme: { colors },
    themed,
  } = useAppTheme()

  if (!label && !labelTx && !LabelTextProps?.children) return null

  const $labelStyle = themed([
    $label,
    status === "error" && { color: colors.error },
    labelPosition === "right" && $labelRight,
    labelPosition === "left" && $labelLeft,
    $labelStyleOverride,
    LabelTextProps?.style,
  ])

  return (
    <Text
      preset="formLabel"
      text={label}
      tx={labelTx}
      txOptions={labelTxOptions}
      {...LabelTextProps}
      style={$labelStyle}
    />
  )
}

const $inputWrapper: ViewStyle = {
  alignItems: "center",
}

export const $inputOuterBase: ViewStyle = {
  height: 24,
  width: 24,
  borderWidth: 2,
  alignItems: "center",
  overflow: "hidden",
  flexGrow: 0,
  flexShrink: 0,
  justifyContent: "space-between",
  flexDirection: "row",
}

const $helper: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginTop: spacing.xs,
})

const $label: TextStyle = {
  flex: 1,
}

const $labelRight: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginStart: spacing.md,
})

const $labelLeft: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginEnd: spacing.md,
})

================
File: app/config/config.base.ts
================
export interface ConfigBaseProps {
  persistNavigation: "always" | "dev" | "prod" | "never"
  catchErrors: "always" | "dev" | "prod" | "never"
  exitRoutes: string[]
}

export type PersistNavigationConfig = ConfigBaseProps["persistNavigation"]

const BaseConfig: ConfigBaseProps = {
  // This feature is particularly useful in development mode, but
  // can be used in production as well if you prefer.
  persistNavigation: "dev",

  /**
   * Only enable if we're catching errors in the right environment
   */
  catchErrors: "always",

  /**
   * This is a list of all the route names that will exit the app if the back button
   * is pressed while in that screen. Only affects Android.
   */
  exitRoutes: ["Welcome"],
}

export default BaseConfig

================
File: app/config/config.dev.ts
================
/**
 * These are configuration settings for the dev environment.
 *
 * Do not include API secrets in this file or anywhere in your JS.
 *
 * https://reactnative.dev/docs/security#storing-sensitive-info
 */
export default {
  API_URL: "https://api.rss2json.com/v1/",
}

================
File: app/config/config.prod.ts
================
/**
 * These are configuration settings for the production environment.
 *
 * Do not include API secrets in this file or anywhere in your JS.
 *
 * https://reactnative.dev/docs/security#storing-sensitive-info
 */
export default {
  API_URL: "CHANGEME",
}

================
File: app/config/index.ts
================
/**
 * This file imports configuration objects from either the config.dev.js file
 * or the config.prod.js file depending on whether we are in __DEV__ or not.
 *
 * Note that we do not gitignore these files. Unlike on web servers, just because
 * these are not checked into your repo doesn't mean that they are secure.
 * In fact, you're shipping a JavaScript bundle with every
 * config variable in plain text. Anyone who downloads your app can easily
 * extract them.
 *
 * If you doubt this, just bundle your app, and then go look at the bundle and
 * search it for one of your config variable values. You'll find it there.
 *
 * Read more here: https://reactnative.dev/docs/security#storing-sensitive-info
 */
import BaseConfig from "./config.base"
import ProdConfig from "./config.prod"
import DevConfig from "./config.dev"

let ExtraConfig = ProdConfig

if (__DEV__) {
  ExtraConfig = DevConfig
}

const Config = { ...BaseConfig, ...ExtraConfig }

export default Config

================
File: app/devtools/ReactotronClient.ts
================
/**
 * This file is loaded in React Native and exports the RN version
 * of Reactotron's client.
 *
 * Web is loaded from ReactotronClient.web.ts.
 */
import Reactotron from "reactotron-react-native"
export { Reactotron }

================
File: app/devtools/ReactotronClient.web.ts
================
/**
 * This file is loaded in web and exports the React.js version
 * of Reactotron's client.
 *
 * React Native is loaded from ReactotronClient.ts.
 *
 * If your project does not need web support, you can delete this file and
 * remove reactotron-react-js from your package.json dependencies.
 */
import Reactotron from "reactotron-react-js"
export { Reactotron }

================
File: app/devtools/ReactotronConfig.ts
================
/**
 * This file does the setup for integration with Reactotron, which is a
 * free desktop app for inspecting and debugging your React Native app.
 * @see https://github.com/infinitered/reactotron
 */
import { Platform, NativeModules } from "react-native"

import { ArgType } from "reactotron-core-client"
import mmkvPlugin from "reactotron-react-native-mmkv"

import { storage } from "@/utils/storage"
import { goBack, resetRoot, navigate } from "@/navigators/navigationUtilities"

import { Reactotron } from "./ReactotronClient"
import { ReactotronReactNative } from "reactotron-react-native"

const reactotron = Reactotron.configure({
  name: require("../../package.json").name,
  onConnect: () => {
    /** since this file gets hot reloaded, let's clear the past logs every time we connect */
    Reactotron.clear()
  },
})

reactotron.use(mmkvPlugin<ReactotronReactNative>({ storage }))

if (Platform.OS !== "web") {
  reactotron.useReactNative({
    networking: {
      ignoreUrls: /symbolicate/,
    },
  })
}

/**
 * Reactotron allows you to define custom commands that you can run
 * from Reactotron itself, and they will run in your app.
 *
 * Define them in the section below with `onCustomCommand`. Use your
 * creativity -- this is great for development to quickly and easily
 * get your app into the state you want.
 *
 * NOTE: If you edit this file while running the app, you will need to do a full refresh
 * or else your custom commands won't be registered correctly.
 */
reactotron.onCustomCommand({
  title: "Show Dev Menu",
  description: "Opens the React Native dev menu",
  command: "showDevMenu",
  handler: () => {
    Reactotron.log("Showing React Native dev menu")
    NativeModules.DevMenu.show()
  },
})

reactotron.onCustomCommand({
  title: "Reset Navigation State",
  description: "Resets the navigation state",
  command: "resetNavigation",
  handler: () => {
    Reactotron.log("resetting navigation state")
    resetRoot({ index: 0, routes: [] })
  },
})

reactotron.onCustomCommand<[{ name: "route"; type: ArgType.String }]>({
  command: "navigateTo",
  handler: (args) => {
    const { route } = args ?? {}
    if (route) {
      Reactotron.log(`Navigating to: ${route}`)
      navigate(route as any) // this should be tied to the navigator, but since this is for debugging, we can navigate to illegal routes
    } else {
      Reactotron.log("Could not navigate. No route provided.")
    }
  },
  title: "Navigate To Screen",
  description: "Navigates to a screen by name.",
  args: [{ name: "route", type: ArgType.String }],
})

reactotron.onCustomCommand({
  title: "Go Back",
  description: "Goes back",
  command: "goBack",
  handler: () => {
    Reactotron.log("Going back")
    goBack()
  },
})

/**
 * We're going to add `console.tron` to the Reactotron object.
 * Now, anywhere in our app in development, we can use Reactotron like so:
 *
 * ```
 * if (__DEV__) {
 *  console.tron.display({
 *    name: 'JOKE',
 *    preview: 'What's the best thing about Switzerland?',
 *    value: 'I don't know, but the flag is a big plus!',
 *    important: true
 *  })
 * }
 * ```
 *
 * Use this power responsibly! :)
 */
console.tron = reactotron

/**
 * We tell typescript about our dark magic
 *
 * You can also import Reactotron yourself from ./reactotronClient
 * and use it directly, like Reactotron.log('hello world')
 */
declare global {
  interface Console {
    /**
     * Reactotron client for logging, displaying, measuring performance, and more.
     * @see https://github.com/infinitered/reactotron
     * @example
     * if (__DEV__) {
     *  console.tron.display({
     *    name: 'JOKE',
     *    preview: 'What's the best thing about Switzerland?',
     *    value: 'I don't know, but the flag is a big plus!',
     *    important: true
     *  })
     * }
     */
    tron: typeof reactotron
  }
}

/**
 * Now that we've setup all our Reactotron configuration, let's connect!
 */
reactotron.connect()

================
File: app/i18n/ar.ts
================
import { Translations } from "./en"

const ar: Translations = {
  common: {
    ok: "نعم",
    cancel: "حذف",
    back: "خلف",
  },
  welcomeScreen: {
    postscript:
      "ربما لا يكون هذا هو الشكل الذي يبدو عليه تطبيقك مالم يمنحك المصمم هذه الشاشات وشحنها في هذه الحالة",
    readyForLaunch: "تطبيقك تقريبا جاهز للتشغيل",
    exciting: "اوه هذا مثير",
  },
  errorScreen: {
    title: "هناك خطأ ما",
    friendlySubtitle:
      "هذه هي الشاشة التي سيشاهدها المستخدمون في عملية الانتاج عند حدوث خطأ. سترغب في تخصيص هذه الرسالة ( الموجودة في 'ts.en/i18n/app') وربما التخطيط ايضاً ('app/screens/ErrorScreen'). إذا كنت تريد إزالة هذا بالكامل، تحقق من 'app/app.tsp' من اجل عنصر <ErrorBoundary>.",
    reset: "اعادة تعيين التطبيق",
  },
  emptyStateComponent: {
    generic: {
      heading: "فارغة جداً....حزين",
      content: "لا توجد بيانات حتى الآن. حاول النقر فوق الزر لتحديث التطبيق او اعادة تحميله.",
      button: "لنحاول هذا مرّة أخرى",
    },
  },
}

export default ar

================
File: app/i18n/en.ts
================
const en = {
  common: {
    ok: "OK!",
    cancel: "Cancel",
    back: "Back",
  },
  welcomeScreen: {
    postscript:
      "psst  — This probably isn't what your app looks like. (Unless your designer handed you these screens, and in that case, ship it!)",
    readyForLaunch: "Your app, almost ready for launch!",
    exciting: "(ohh, this is exciting!)",
  },
  errorScreen: {
    title: "Something went wrong!",
    friendlySubtitle:
      "This is the screen that your users will see in production when an error is thrown. You'll want to customize this message (located in `app/i18n/en.ts`) and probably the layout as well (`app/screens/ErrorScreen`). If you want to remove this entirely, check `app/app.tsx` for the <ErrorBoundary> component.",
    reset: "RESET APP",
  },
  emptyStateComponent: {
    generic: {
      heading: "So empty... so sad",
      content: "No data found yet. Try clicking the button to refresh or reload the app.",
      button: "Let's try this again",
    },
  },
}

export default en
export type Translations = typeof en

================
File: app/i18n/es.ts
================
import { Translations } from "./en"

const es: Translations = {
  common: {
    ok: "OK",
    cancel: "Cancelar",
    back: "Volver",
  },
  welcomeScreen: {
    postscript:
      "psst — Esto probablemente no es cómo se va a ver tu app. (A menos que tu diseñador te haya enviado estas pantallas, y en ese caso, ¡lánzalas en producción!)",
    readyForLaunch: "Tu app, casi lista para su lanzamiento",
    exciting: "(¡ohh, esto es emocionante!)",
  },
  errorScreen: {
    title: "¡Algo salió mal!",
    friendlySubtitle:
      "Esta es la pantalla que verán tus usuarios en producción cuando haya un error. Vas a querer personalizar este mensaje (que está ubicado en `app/i18n/es.ts`) y probablemente también su diseño (`app/screens/ErrorScreen`). Si quieres eliminarlo completamente, revisa `app/app.tsx` y el componente <ErrorBoundary>.",
    reset: "REINICIA LA APP",
  },
  emptyStateComponent: {
    generic: {
      heading: "Muy vacío... muy triste",
      content:
        "No se han encontrado datos por el momento. Intenta darle clic en el botón para refrescar o recargar la app.",
      button: "Intentemos de nuevo",
    },
  },
}

export default es

================
File: app/i18n/fr.ts
================
import { Translations } from "./en"

const fr: Translations = {
  common: {
    ok: "OK !",
    cancel: "Annuler",
    back: "Retour",
  },
  welcomeScreen: {
    postscript:
      "psst  — Ce n'est probablement pas à quoi ressemble votre application. (À moins que votre designer ne vous ait donné ces écrans, dans ce cas, mettez la en prod !)",
    readyForLaunch: "Votre application, presque prête pour le lancement !",
    exciting: "(ohh, c'est excitant !)",
  },
  errorScreen: {
    title: "Quelque chose s'est mal passé !",
    friendlySubtitle:
      "C'est l'écran que vos utilisateurs verront en production lorsqu'une erreur sera lancée. Vous voudrez personnaliser ce message (situé dans `app/i18n/fr.ts`) et probablement aussi la mise en page (`app/screens/ErrorScreen`). Si vous voulez le supprimer complètement, vérifiez `app/app.tsx` pour le composant <ErrorBoundary>.",
    reset: "RÉINITIALISER L'APPLICATION",
  },
  emptyStateComponent: {
    generic: {
      heading: "Si vide... si triste",
      content:
        "Aucune donnée trouvée pour le moment. Essayez de cliquer sur le bouton pour rafraîchir ou recharger l'application.",
      button: "Essayons à nouveau",
    },
  },
}

export default fr

================
File: app/i18n/hi.ts
================
import { Translations } from "./en"

const hi: Translations = {
  common: {
    ok: "ठीक है!",
    cancel: "रद्द करें",
    back: "वापस",
  },
  welcomeScreen: {
    postscript:
      "psst - शायद आपका ऐप ऐसा नहीं दिखता है। (जब तक कि आपके डिजाइनर ने आपको ये स्क्रीन नहीं दी हों, और उस स्थिति में, इसे लॉन्च करें!)",
    readyForLaunch: "आपका ऐप, लगभग लॉन्च के लिए तैयार है!",
    exciting: "(ओह, यह रोमांचक है!)",
  },
  errorScreen: {
    title: "कुछ गलत हो गया!",
    friendlySubtitle:
      "यह वह स्क्रीन है जो आपके उपयोगकर्ता संचालन में देखेंगे जब कोई त्रुटि होगी। आप इस संदेश को बदलना चाहेंगे (जो `app/i18n/hi.ts` में स्थित है) और शायद लेआउट भी (`app/screens/ErrorScreen`)। यदि आप इसे पूरी तरह से हटाना चाहते हैं, तो `app/app.tsx` में <ErrorBoundary> कंपोनेंट की जांच करें।",
    reset: "ऐप रीसेट करें",
  },
  emptyStateComponent: {
    generic: {
      heading: "इतना खाली... इतना उदास",
      content: "अभी तक कोई डेटा नहीं मिला। रीफ्रेश करने या ऐप को पुनः लोड करने के लिए बटन दबाएं।",
      button: "चलो फिर से कोशिश करते हैं",
    },
  },
}

export default hi

================
File: app/i18n/i18n.ts
================
import * as Localization from "expo-localization"
import { I18nManager } from "react-native"
import i18n from "i18next"
import { initReactI18next } from "react-i18next"
import "intl-pluralrules"

// if English isn't your default language, move Translations to the appropriate language file.
import en, { Translations } from "./en"
import ar from "./ar"
import ko from "./ko"
import es from "./es"
import fr from "./fr"
import ja from "./ja"
import hi from "./hi"

const fallbackLocale = "en-US"

const systemLocales = Localization.getLocales()

const resources = { ar, en, ko, es, fr, ja, hi }
const supportedTags = Object.keys(resources)

// Checks to see if the device locale matches any of the supported locales
// Device locale may be more specific and still match (e.g., en-US matches en)
const systemTagMatchesSupportedTags = (deviceTag: string) => {
  const primaryTag = deviceTag.split("-")[0]
  return supportedTags.includes(primaryTag)
}

const pickSupportedLocale: () => Localization.Locale | undefined = () => {
  return systemLocales.find((locale) => systemTagMatchesSupportedTags(locale.languageTag))
}

const locale = pickSupportedLocale()

export let isRTL = false

// Need to set RTL ASAP to ensure the app is rendered correctly. Waiting for i18n to init is too late.
if (locale?.languageTag && locale?.textDirection === "rtl") {
  I18nManager.allowRTL(true)
  isRTL = true
} else {
  I18nManager.allowRTL(false)
}

export const initI18n = async () => {
  i18n.use(initReactI18next)

  await i18n.init({
    resources,
    lng: locale?.languageTag ?? fallbackLocale,
    fallbackLng: fallbackLocale,
    interpolation: {
      escapeValue: false,
    },
  })

  return i18n
}

/**
 * Builds up valid keypaths for translations.
 */

export type TxKeyPath = RecursiveKeyOf<Translations>

// via: https://stackoverflow.com/a/65333050
type RecursiveKeyOf<TObj extends object> = {
  [TKey in keyof TObj & (string | number)]: RecursiveKeyOfHandleValue<TObj[TKey], `${TKey}`, true>
}[keyof TObj & (string | number)]

type RecursiveKeyOfInner<TObj extends object> = {
  [TKey in keyof TObj & (string | number)]: RecursiveKeyOfHandleValue<TObj[TKey], `${TKey}`, false>
}[keyof TObj & (string | number)]

type RecursiveKeyOfHandleValue<
  TValue,
  Text extends string,
  IsFirstLevel extends boolean,
> = TValue extends any[]
  ? Text
  : TValue extends object
    ? IsFirstLevel extends true
      ? Text | `${Text}:${RecursiveKeyOfInner<TValue>}`
      : Text | `${Text}.${RecursiveKeyOfInner<TValue>}`
    : Text

================
File: app/i18n/index.ts
================
import "./i18n"
export * from "./i18n"
export * from "./translate"

================
File: app/i18n/ja.ts
================
import { Translations } from "./en"

const ja: Translations = {
  common: {
    ok: "OK",
    cancel: "キャンセル",
    back: "戻る",
  },
  welcomeScreen: {
    postscript:
      "注目！ — このアプリはお好みの見た目では無いかもしれません(デザイナーがこのスクリーンを送ってこない限りは。もしそうなら公開しちゃいましょう！)",
    readyForLaunch: "このアプリはもう少しで公開できます！",
    exciting: "(楽しみですね！)",
  },
  errorScreen: {
    title: "問題が発生しました",
    friendlySubtitle:
      "本番では、エラーが投げられた時にこのページが表示されます。もし使うならこのメッセージに変更を加えてください(`app/i18n/jp.ts`)レイアウトはこちらで変更できます(`app/screens/ErrorScreen`)。もしこのスクリーンを取り除きたい場合は、`app/app.tsx`にある<ErrorBoundary>コンポーネントをチェックしてください",
    reset: "リセット",
  },
  emptyStateComponent: {
    generic: {
      heading: "静かだ...悲しい。",
      content:
        "データが見つかりません。ボタンを押してアプリをリロード、またはリフレッシュしてください。",
      button: "もう一度やってみよう",
    },
  },
}

export default ja

================
File: app/i18n/ko.ts
================
import { Translations } from "./en"

const ko: Translations = {
  common: {
    ok: "확인!",
    cancel: "취소",
    back: "뒤로",
  },
  welcomeScreen: {
    postscript:
      "잠깐! — 지금 보시는 것은 아마도 당신의 앱의 모양새가 아닐겁니다. (디자이너분이 이렇게 건내주셨다면 모를까요. 만약에 그렇다면, 이대로 가져갑시다!) ",
    readyForLaunch: "출시 준비가 거의 끝난 나만의 앱!",
    exciting: "(오, 이거 신나는데요!)",
  },
  errorScreen: {
    title: "뭔가 잘못되었습니다!",
    friendlySubtitle:
      "이 화면은 오류가 발생할 때 프로덕션에서 사용자에게 표시됩니다. 이 메시지를 커스터마이징 할 수 있고(해당 파일은 `app/i18n/ko.ts` 에 있습니다) 레이아웃도 마찬가지로 수정할 수 있습니다(`app/screens/error`). 만약 이 오류화면을 완전히 없에버리고 싶다면 `app/app.tsx` 파일에서 <ErrorBoundary> 컴포넌트를 확인하기 바랍니다.",
    reset: "초기화",
  },
  emptyStateComponent: {
    generic: {
      heading: "너무 텅 비어서.. 너무 슬퍼요..",
      content: "데이터가 없습니다. 버튼을 눌러서 리프레쉬 하시거나 앱을 리로드하세요.",
      button: "다시 시도해봅시다",
    },
  },
}

export default ko

================
File: app/i18n/translate.ts
================
import i18n from "i18next"
import type { TOptions } from "i18next"
import { TxKeyPath } from "./i18n"

/**
 * Translates text.
 * @param {TxKeyPath} key - The i18n key.
 * @param {TOptions} options - The i18n options.
 * @returns {string} - The translated text.
 * @example
 * Translations:
 *
 * ```en.ts
 * {
 *  "hello": "Hello, {{name}}!"
 * }
 * ```
 *
 * Usage:
 * ```ts
 * import { translate } from "./i18n"
 *
 * translate("common:ok", { name: "world" })
 * // => "Hello world!"
 * ```
 */
export function translate(key: TxKeyPath, options?: TOptions): string {
  if (i18n.isInitialized) {
    return i18n.t(key, options)
  }
  return key
}

================
File: app/navigators/AppNavigator.tsx
================
/**
 * The app navigator (formerly "AppNavigator" and "MainNavigator") is used for the primary
 * navigation flows of your app.
 * Generally speaking, it will contain an auth flow (registration, login, forgot password)
 * and a "main" flow which the user will use once logged in.
 */
import { NavigationContainer } from "@react-navigation/native"
import { createNativeStackNavigator, NativeStackScreenProps } from "@react-navigation/native-stack"
import * as Screens from "@/screens"
import Config from "../config"
import { navigationRef, useBackButtonHandler } from "./navigationUtilities"
import { useAppTheme, useThemeProvider } from "@/utils/useAppTheme"
import { ComponentProps } from "react"

/**
 * This type allows TypeScript to know what routes are defined in this navigator
 * as well as what properties (if any) they might take when navigating to them.
 *
 * If no params are allowed, pass through `undefined`. Generally speaking, we
 * recommend using your MobX-State-Tree store(s) to keep application state
 * rather than passing state through navigation params.
 *
 * For more information, see this documentation:
 *   https://reactnavigation.org/docs/params/
 *   https://reactnavigation.org/docs/typescript#type-checking-the-navigator
 *   https://reactnavigation.org/docs/typescript/#organizing-types
 */
export type AppStackParamList = {
  Welcome: undefined
  // 🔥 Your screens go here
  // IGNITE_GENERATOR_ANCHOR_APP_STACK_PARAM_LIST
}

/**
 * This is a list of all the route names that will exit the app if the back button
 * is pressed while in that screen. Only affects Android.
 */
const exitRoutes = Config.exitRoutes

export type AppStackScreenProps<T extends keyof AppStackParamList> = NativeStackScreenProps<
  AppStackParamList,
  T
>

// Documentation: https://reactnavigation.org/docs/stack-navigator/
const Stack = createNativeStackNavigator<AppStackParamList>()

const AppStack = () => {
  const {
    theme: { colors },
  } = useAppTheme()

  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
        navigationBarColor: colors.background,
        contentStyle: {
          backgroundColor: colors.background,
        },
      }}
    >
      <Stack.Screen name="Welcome" component={Screens.WelcomeScreen} />
      {/** 🔥 Your screens go here */}
      {/* IGNITE_GENERATOR_ANCHOR_APP_STACK_SCREENS */}
    </Stack.Navigator>
  )
}

export interface NavigationProps extends Partial<ComponentProps<typeof NavigationContainer>> {}

export const AppNavigator = (props: NavigationProps) => {
  const { themeScheme, navigationTheme, setThemeContextOverride, ThemeProvider } =
    useThemeProvider()

  useBackButtonHandler((routeName) => exitRoutes.includes(routeName))

  return (
    <ThemeProvider value={{ themeScheme, setThemeContextOverride }}>
      <NavigationContainer ref={navigationRef} theme={navigationTheme} {...props}>
        <AppStack />
      </NavigationContainer>
    </ThemeProvider>
  )
}

================
File: app/navigators/index.ts
================
export * from "./AppNavigator"
export * from "./navigationUtilities"
// export other navigators from here

================
File: app/navigators/navigationUtilities.ts
================
import { useState, useEffect, useRef } from "react"
import { BackHandler, Linking, Platform } from "react-native"
import {
  NavigationState,
  PartialState,
  createNavigationContainerRef,
} from "@react-navigation/native"
import Config from "../config"
import type { PersistNavigationConfig } from "../config/config.base"
import { useIsMounted } from "../utils/useIsMounted"
import type { AppStackParamList, NavigationProps } from "./AppNavigator"

import * as storage from "../utils/storage"

type Storage = typeof storage

/**
 * Reference to the root App Navigator.
 *
 * If needed, you can use this to access the navigation object outside of a
 * `NavigationContainer` context. However, it's recommended to use the `useNavigation` hook whenever possible.
 * @see [Navigating Without Navigation Prop]{@link https://reactnavigation.org/docs/navigating-without-navigation-prop/}
 *
 * The types on this reference will only let you reference top level navigators. If you have
 * nested navigators, you'll need to use the `useNavigation` with the stack navigator's ParamList type.
 */
export const navigationRef = createNavigationContainerRef<AppStackParamList>()

/**
 * Gets the current screen from any navigation state.
 * @param {NavigationState | PartialState<NavigationState>} state - The navigation state to traverse.
 * @returns {string} - The name of the current screen.
 */
export function getActiveRouteName(state: NavigationState | PartialState<NavigationState>): string {
  const route = state.routes[state.index ?? 0]

  // Found the active route -- return the name
  if (!route.state) return route.name as keyof AppStackParamList

  // Recursive call to deal with nested routers
  return getActiveRouteName(route.state as NavigationState<AppStackParamList>)
}

const iosExit = () => false

/**
 * Hook that handles Android back button presses and forwards those on to
 * the navigation or allows exiting the app.
 * @see [BackHandler]{@link https://reactnative.dev/docs/backhandler}
 * @param {(routeName: string) => boolean} canExit - Function that returns whether we can exit the app.
 * @returns {void}
 */
export function useBackButtonHandler(canExit: (routeName: string) => boolean) {
  // The reason we're using a ref here is because we need to be able
  // to update the canExit function without re-setting up all the listeners
  const canExitRef = useRef(Platform.OS !== "android" ? iosExit : canExit)

  useEffect(() => {
    canExitRef.current = canExit
  }, [canExit])

  useEffect(() => {
    // We'll fire this when the back button is pressed on Android.
    const onBackPress = () => {
      if (!navigationRef.isReady()) {
        return false
      }

      // grab the current route
      const routeName = getActiveRouteName(navigationRef.getRootState())

      // are we allowed to exit?
      if (canExitRef.current(routeName)) {
        // exit and let the system know we've handled the event
        BackHandler.exitApp()
        return true
      }

      // we can't exit, so let's turn this into a back action
      if (navigationRef.canGoBack()) {
        navigationRef.goBack()
        return true
      }

      return false
    }

    // Subscribe when we come to life
    BackHandler.addEventListener("hardwareBackPress", onBackPress)

    // Unsubscribe when we're done
    return () => BackHandler.removeEventListener("hardwareBackPress", onBackPress)
  }, [])
}

/**
 * This helper function will determine whether we should enable navigation persistence
 * based on a config setting and the __DEV__ environment (dev or prod).
 * @param {PersistNavigationConfig} persistNavigation - The config setting for navigation persistence.
 * @returns {boolean} - Whether to restore navigation state by default.
 */
function navigationRestoredDefaultState(persistNavigation: PersistNavigationConfig) {
  if (persistNavigation === "always") return false
  if (persistNavigation === "dev" && __DEV__) return false
  if (persistNavigation === "prod" && !__DEV__) return false

  // all other cases, disable restoration by returning true
  return true
}

/**
 * Custom hook for persisting navigation state.
 * @param {Storage} storage - The storage utility to use.
 * @param {string} persistenceKey - The key to use for storing the navigation state.
 * @returns {object} - The navigation state and persistence functions.
 */
export function useNavigationPersistence(storage: Storage, persistenceKey: string) {
  const [initialNavigationState, setInitialNavigationState] =
    useState<NavigationProps["initialState"]>()
  const isMounted = useIsMounted()

  const initNavState = navigationRestoredDefaultState(Config.persistNavigation)
  const [isRestored, setIsRestored] = useState(initNavState)

  const routeNameRef = useRef<keyof AppStackParamList | undefined>()

  const onNavigationStateChange = (state: NavigationState | undefined) => {
    const previousRouteName = routeNameRef.current
    if (state !== undefined) {
      const currentRouteName = getActiveRouteName(state)

      if (previousRouteName !== currentRouteName) {
        // track screens.
        if (__DEV__) {
          console.log(currentRouteName)
        }
      }

      // Save the current route name for later comparison
      routeNameRef.current = currentRouteName as keyof AppStackParamList

      // Persist state to storage
      storage.save(persistenceKey, state)
    }
  }

  const restoreState = async () => {
    try {
      const initialUrl = await Linking.getInitialURL()

      // Only restore the state if app has not started from a deep link
      if (!initialUrl) {
        const state = (await storage.load(persistenceKey)) as NavigationProps["initialState"] | null
        if (state) setInitialNavigationState(state)
      }
    } finally {
      if (isMounted()) setIsRestored(true)
    }
  }

  useEffect(() => {
    if (!isRestored) restoreState()
    // runs once on mount
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  return { onNavigationStateChange, restoreState, isRestored, initialNavigationState }
}

/**
 * use this to navigate without the navigation
 * prop. If you have access to the navigation prop, do not use this.
 * @see {@link https://reactnavigation.org/docs/navigating-without-navigation-prop/}
 * @param {unknown} name - The name of the route to navigate to.
 * @param {unknown} params - The params to pass to the route.
 */
export function navigate(name: unknown, params?: unknown) {
  if (navigationRef.isReady()) {
    // @ts-expect-error
    navigationRef.navigate(name as never, params as never)
  }
}

/**
 * This function is used to go back in a navigation stack, if it's possible to go back.
 * If the navigation stack can't go back, nothing happens.
 * The navigationRef variable is a React ref that references a navigation object.
 * The navigationRef variable is set in the App component.
 */
export function goBack() {
  if (navigationRef.isReady() && navigationRef.canGoBack()) {
    navigationRef.goBack()
  }
}

/**
 * resetRoot will reset the root navigation state to the given params.
 * @param {Parameters<typeof navigationRef.resetRoot>[0]} state - The state to reset the root to.
 * @returns {void}
 */
export function resetRoot(
  state: Parameters<typeof navigationRef.resetRoot>[0] = { index: 0, routes: [] },
) {
  if (navigationRef.isReady()) {
    navigationRef.resetRoot(state)
  }
}

================
File: app/screens/ErrorScreen/ErrorBoundary.tsx
================
import { Component, ErrorInfo, ReactNode } from "react"
import { ErrorDetails } from "./ErrorDetails"

interface Props {
  children: ReactNode
  catchErrors: "always" | "dev" | "prod" | "never"
}

interface State {
  error: Error | null
  errorInfo: ErrorInfo | null
}

/**
 * This component handles whenever the user encounters a JS error in the
 * app. It follows the "error boundary" pattern in React. We're using a
 * class component because according to the documentation, only class
 * components can be error boundaries.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/concept/Error-Boundary/}
 * @see [React Error Boundaries]{@link https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary}
 * @param {Props} props - The props for the `ErrorBoundary` component.
 * @returns {JSX.Element} The rendered `ErrorBoundary` component.
 */
export class ErrorBoundary extends Component<Props, State> {
  state = { error: null, errorInfo: null }

  // If an error in a child is encountered, this will run
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Only set errors if enabled
    if (!this.isEnabled()) {
      return
    }
    // Catch errors in any components below and re-render with error message
    this.setState({
      error,
      errorInfo,
    })

    // You can also log error messages to an error reporting service here
    // This is a great place to put BugSnag, Sentry, crashlytics, etc:
    // reportCrash(error)
  }

  // Reset the error back to null
  resetError = () => {
    this.setState({ error: null, errorInfo: null })
  }

  // To avoid unnecessary re-renders
  shouldComponentUpdate(nextProps: Readonly<Props>, nextState: Readonly<State>): boolean {
    return nextState.error !== this.state.error
  }

  // Only enable if we're catching errors in the right environment
  isEnabled(): boolean {
    return (
      this.props.catchErrors === "always" ||
      (this.props.catchErrors === "dev" && __DEV__) ||
      (this.props.catchErrors === "prod" && !__DEV__)
    )
  }

  // Render an error UI if there's an error; otherwise, render children
  render() {
    return this.isEnabled() && this.state.error ? (
      <ErrorDetails
        onReset={this.resetError}
        error={this.state.error}
        errorInfo={this.state.errorInfo}
      />
    ) : (
      this.props.children
    )
  }
}

================
File: app/screens/ErrorScreen/ErrorDetails.tsx
================
import { ErrorInfo } from "react"
import { ScrollView, TextStyle, View, ViewStyle } from "react-native"
import { Button, Icon, Screen, Text } from "../../components"
import type { ThemedStyle } from "@/theme"
import { useAppTheme } from "@/utils/useAppTheme"

export interface ErrorDetailsProps {
  error: Error
  errorInfo: ErrorInfo | null
  onReset(): void
}

/**
 * Renders the error details screen.
 * @param {ErrorDetailsProps} props - The props for the `ErrorDetails` component.
 * @returns {JSX.Element} The rendered `ErrorDetails` component.
 */
export function ErrorDetails(props: ErrorDetailsProps) {
  const { themed } = useAppTheme()
  return (
    <Screen
      preset="fixed"
      safeAreaEdges={["top", "bottom"]}
      contentContainerStyle={themed($contentContainer)}
    >
      <View style={$topSection}>
        <Icon icon="ladybug" size={64} />
        <Text style={themed($heading)} preset="subheading" tx="errorScreen:title" />
        <Text tx="errorScreen:friendlySubtitle" />
      </View>

      <ScrollView
        style={themed($errorSection)}
        contentContainerStyle={themed($errorSectionContentContainer)}
      >
        <Text style={themed($errorContent)} weight="bold" text={`${props.error}`.trim()} />
        <Text
          selectable
          style={themed($errorBacktrace)}
          text={`${props.errorInfo?.componentStack ?? ""}`.trim()}
        />
      </ScrollView>

      <Button
        preset="reversed"
        style={themed($resetButton)}
        onPress={props.onReset}
        tx="errorScreen:reset"
      />
    </Screen>
  )
}

const $contentContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  alignItems: "center",
  paddingHorizontal: spacing.lg,
  paddingTop: spacing.xl,
  flex: 1,
})

const $topSection: ViewStyle = {
  flex: 1,
  alignItems: "center",
}

const $heading: ThemedStyle<TextStyle> = ({ colors, spacing }) => ({
  color: colors.error,
  marginBottom: spacing.md,
})

const $errorSection: ThemedStyle<ViewStyle> = ({ colors, spacing }) => ({
  flex: 2,
  backgroundColor: colors.separator,
  marginVertical: spacing.md,
  borderRadius: 6,
})

const $errorSectionContentContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  padding: spacing.md,
})

const $errorContent: ThemedStyle<TextStyle> = ({ colors }) => ({
  color: colors.error,
})

const $errorBacktrace: ThemedStyle<TextStyle> = ({ colors, spacing }) => ({
  marginTop: spacing.md,
  color: colors.textDim,
})

const $resetButton: ThemedStyle<ViewStyle> = ({ colors, spacing }) => ({
  backgroundColor: colors.error,
  paddingHorizontal: spacing.xxl,
})

================
File: app/screens/index.ts
================
export * from "./WelcomeScreen"
export * from "./ErrorScreen/ErrorBoundary"
// export other screens here

================
File: app/screens/WelcomeScreen.tsx
================
import { FC } from "react"
import { Image, ImageStyle, TextStyle, View, ViewStyle } from "react-native"
import { Text, Screen } from "@/components"
import { isRTL } from "@/i18n"
import { AppStackScreenProps } from "../navigators"
import { $styles, type ThemedStyle } from "@/theme"
import { useSafeAreaInsetsStyle } from "../utils/useSafeAreaInsetsStyle"
import { useAppTheme } from "@/utils/useAppTheme"

const welcomeLogo = require("../../assets/images/logo.png")
const welcomeFace = require("../../assets/images/welcome-face.png")

interface WelcomeScreenProps extends AppStackScreenProps<"Welcome"> {}

export const WelcomeScreen: FC<WelcomeScreenProps> = () => {
  const { themed, theme } = useAppTheme()

  const $bottomContainerInsets = useSafeAreaInsetsStyle(["bottom"])

  return (
    <Screen preset="fixed" contentContainerStyle={$styles.flex1}>
      <View style={themed($topContainer)}>
        <Image style={themed($welcomeLogo)} source={welcomeLogo} resizeMode="contain" />
        <Text
          testID="welcome-heading"
          style={themed($welcomeHeading)}
          tx="welcomeScreen:readyForLaunch"
          preset="heading"
        />
        <Text tx="welcomeScreen:exciting" preset="subheading" />
        <Image
          style={$welcomeFace}
          source={welcomeFace}
          resizeMode="contain"
          tintColor={theme.isDark ? theme.colors.palette.neutral900 : undefined}
        />
      </View>

      <View style={themed([$bottomContainer, $bottomContainerInsets])}>
        <Text tx="welcomeScreen:postscript" size="md" />
      </View>
    </Screen>
  )
}

const $topContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  flexShrink: 1,
  flexGrow: 1,
  flexBasis: "57%",
  justifyContent: "center",
  paddingHorizontal: spacing.lg,
})

const $bottomContainer: ThemedStyle<ViewStyle> = ({ colors, spacing }) => ({
  flexShrink: 1,
  flexGrow: 0,
  flexBasis: "43%",
  backgroundColor: colors.palette.neutral100,
  borderTopLeftRadius: 16,
  borderTopRightRadius: 16,
  paddingHorizontal: spacing.lg,
  justifyContent: "space-around",
})

const $welcomeLogo: ThemedStyle<ImageStyle> = ({ spacing }) => ({
  height: 88,
  width: "100%",
  marginBottom: spacing.xxl,
})

const $welcomeFace: ImageStyle = {
  height: 169,
  width: 269,
  position: "absolute",
  bottom: -47,
  right: -80,
  transform: [{ scaleX: isRTL ? -1 : 1 }],
}

const $welcomeHeading: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginBottom: spacing.md,
})

================
File: app/services/api/api.ts
================
/**
 * This Api class lets you define an API endpoint and methods to request
 * data and process it.
 *
 * See the [Backend API Integration](https://docs.infinite.red/ignite-cli/boilerplate/app/services/#backend-api-integration)
 * documentation for more details.
 */
import { ApisauceInstance, create } from "apisauce"
import Config from "../../config"
import type { ApiConfig } from "./api.types"

/**
 * Configuring the apisauce instance.
 */
export const DEFAULT_API_CONFIG: ApiConfig = {
  url: Config.API_URL,
  timeout: 10000,
}

/**
 * Manages all requests to the API. You can use this class to build out
 * various requests that you need to call from your backend API.
 */
export class Api {
  apisauce: ApisauceInstance
  config: ApiConfig

  /**
   * Set up our API instance. Keep this lightweight!
   */
  constructor(config: ApiConfig = DEFAULT_API_CONFIG) {
    this.config = config
    this.apisauce = create({
      baseURL: this.config.url,
      timeout: this.config.timeout,
      headers: {
        Accept: "application/json",
      },
    })
  }
}

// Singleton instance of the API for convenience
export const api = new Api()

================
File: app/services/api/api.types.ts
================
/**
 * These types indicate the shape of the data you expect to receive from your
 * API endpoint, assuming it's a JSON object like we have.
 */
export interface EpisodeItem {
  title: string
  pubDate: string
  link: string
  guid: string
  author: string
  thumbnail: string
  description: string
  content: string
  enclosure: {
    link: string
    type: string
    length: number
    duration: number
    rating: { scheme: string; value: string }
  }
  categories: string[]
}

export interface ApiFeedResponse {
  status: string
  feed: {
    url: string
    title: string
    link: string
    author: string
    description: string
    image: string
  }
  items: EpisodeItem[]
}

/**
 * The options used to configure apisauce.
 */
export interface ApiConfig {
  /**
   * The URL of the api.
   */
  url: string

  /**
   * Milliseconds before we timeout the request.
   */
  timeout: number
}

================
File: app/services/api/apiProblem.test.ts
================
import { getGeneralApiProblem } from "./apiProblem"
import { ApiErrorResponse } from "apisauce"

test("handles connection errors", () => {
  expect(getGeneralApiProblem({ problem: "CONNECTION_ERROR" } as ApiErrorResponse<null>)).toEqual({
    kind: "cannot-connect",
    temporary: true,
  })
})

test("handles network errors", () => {
  expect(getGeneralApiProblem({ problem: "NETWORK_ERROR" } as ApiErrorResponse<null>)).toEqual({
    kind: "cannot-connect",
    temporary: true,
  })
})

test("handles timeouts", () => {
  expect(getGeneralApiProblem({ problem: "TIMEOUT_ERROR" } as ApiErrorResponse<null>)).toEqual({
    kind: "timeout",
    temporary: true,
  })
})

test("handles server errors", () => {
  expect(getGeneralApiProblem({ problem: "SERVER_ERROR" } as ApiErrorResponse<null>)).toEqual({
    kind: "server",
  })
})

test("handles unknown errors", () => {
  expect(getGeneralApiProblem({ problem: "UNKNOWN_ERROR" } as ApiErrorResponse<null>)).toEqual({
    kind: "unknown",
    temporary: true,
  })
})

test("handles unauthorized errors", () => {
  expect(
    getGeneralApiProblem({ problem: "CLIENT_ERROR", status: 401 } as ApiErrorResponse<null>),
  ).toEqual({
    kind: "unauthorized",
  })
})

test("handles forbidden errors", () => {
  expect(
    getGeneralApiProblem({ problem: "CLIENT_ERROR", status: 403 } as ApiErrorResponse<null>),
  ).toEqual({
    kind: "forbidden",
  })
})

test("handles not-found errors", () => {
  expect(
    getGeneralApiProblem({ problem: "CLIENT_ERROR", status: 404 } as ApiErrorResponse<null>),
  ).toEqual({
    kind: "not-found",
  })
})

test("handles other client errors", () => {
  expect(
    getGeneralApiProblem({ problem: "CLIENT_ERROR", status: 418 } as ApiErrorResponse<null>),
  ).toEqual({
    kind: "rejected",
  })
})

test("handles cancellation errors", () => {
  expect(getGeneralApiProblem({ problem: "CANCEL_ERROR" } as ApiErrorResponse<null>)).toBeNull()
})

================
File: app/services/api/apiProblem.ts
================
import { ApiResponse } from "apisauce"

export type GeneralApiProblem =
  /**
   * Times up.
   */
  | { kind: "timeout"; temporary: true }
  /**
   * Cannot connect to the server for some reason.
   */
  | { kind: "cannot-connect"; temporary: true }
  /**
   * The server experienced a problem. Any 5xx error.
   */
  | { kind: "server" }
  /**
   * We're not allowed because we haven't identified ourself. This is 401.
   */
  | { kind: "unauthorized" }
  /**
   * We don't have access to perform that request. This is 403.
   */
  | { kind: "forbidden" }
  /**
   * Unable to find that resource.  This is a 404.
   */
  | { kind: "not-found" }
  /**
   * All other 4xx series errors.
   */
  | { kind: "rejected" }
  /**
   * Something truly unexpected happened. Most likely can try again. This is a catch all.
   */
  | { kind: "unknown"; temporary: true }
  /**
   * The data we received is not in the expected format.
   */
  | { kind: "bad-data" }

/**
 * Attempts to get a common cause of problems from an api response.
 *
 * @param response The api response.
 */
export function getGeneralApiProblem(response: ApiResponse<any>): GeneralApiProblem | null {
  switch (response.problem) {
    case "CONNECTION_ERROR":
      return { kind: "cannot-connect", temporary: true }
    case "NETWORK_ERROR":
      return { kind: "cannot-connect", temporary: true }
    case "TIMEOUT_ERROR":
      return { kind: "timeout", temporary: true }
    case "SERVER_ERROR":
      return { kind: "server" }
    case "UNKNOWN_ERROR":
      return { kind: "unknown", temporary: true }
    case "CLIENT_ERROR":
      switch (response.status) {
        case 401:
          return { kind: "unauthorized" }
        case 403:
          return { kind: "forbidden" }
        case 404:
          return { kind: "not-found" }
        default:
          return { kind: "rejected" }
      }
    case "CANCEL_ERROR":
      return null
  }

  return null
}

================
File: app/services/api/index.ts
================
export * from "./api"
export * from "./api.types"

================
File: app/theme/colors.ts
================
const palette = {
  neutral100: "#FFFFFF",
  neutral200: "#F4F2F1",
  neutral300: "#D7CEC9",
  neutral400: "#B6ACA6",
  neutral500: "#978F8A",
  neutral600: "#564E4A",
  neutral700: "#3C3836",
  neutral800: "#191015",
  neutral900: "#000000",

  primary100: "#F4E0D9",
  primary200: "#E8C1B4",
  primary300: "#DDA28E",
  primary400: "#D28468",
  primary500: "#C76542",
  primary600: "#A54F31",

  secondary100: "#DCDDE9",
  secondary200: "#BCC0D6",
  secondary300: "#9196B9",
  secondary400: "#626894",
  secondary500: "#41476E",

  accent100: "#FFEED4",
  accent200: "#FFE1B2",
  accent300: "#FDD495",
  accent400: "#FBC878",
  accent500: "#FFBB50",

  angry100: "#F2D6CD",
  angry500: "#C03403",

  overlay20: "rgba(25, 16, 21, 0.2)",
  overlay50: "rgba(25, 16, 21, 0.5)",
} as const

export const colors = {
  /**
   * The palette is available to use, but prefer using the name.
   * This is only included for rare, one-off cases. Try to use
   * semantic names as much as possible.
   */
  palette,
  /**
   * A helper for making something see-thru.
   */
  transparent: "rgba(0, 0, 0, 0)",
  /**
   * The default text color in many components.
   */
  text: palette.neutral800,
  /**
   * Secondary text information.
   */
  textDim: palette.neutral600,
  /**
   * The default color of the screen background.
   */
  background: palette.neutral200,
  /**
   * The default border color.
   */
  border: palette.neutral400,
  /**
   * The main tinting color.
   */
  tint: palette.primary500,
  /**
   * The inactive tinting color.
   */
  tintInactive: palette.neutral300,
  /**
   * A subtle color used for lines.
   */
  separator: palette.neutral300,
  /**
   * Error messages.
   */
  error: palette.angry500,
  /**
   * Error Background.
   */
  errorBackground: palette.angry100,
} as const

================
File: app/theme/colorsDark.ts
================
const palette = {
  neutral900: "#FFFFFF",
  neutral800: "#F4F2F1",
  neutral700: "#D7CEC9",
  neutral600: "#B6ACA6",
  neutral500: "#978F8A",
  neutral400: "#564E4A",
  neutral300: "#3C3836",
  neutral200: "#191015",
  neutral100: "#000000",

  primary600: "#F4E0D9",
  primary500: "#E8C1B4",
  primary400: "#DDA28E",
  primary300: "#D28468",
  primary200: "#C76542",
  primary100: "#A54F31",

  secondary500: "#DCDDE9",
  secondary400: "#BCC0D6",
  secondary300: "#9196B9",
  secondary200: "#626894",
  secondary100: "#41476E",

  accent500: "#FFEED4",
  accent400: "#FFE1B2",
  accent300: "#FDD495",
  accent200: "#FBC878",
  accent100: "#FFBB50",

  angry100: "#F2D6CD",
  angry500: "#C03403",

  overlay20: "rgba(25, 16, 21, 0.2)",
  overlay50: "rgba(25, 16, 21, 0.5)",
} as const

export const colors = {
  palette,
  transparent: "rgba(0, 0, 0, 0)",
  text: palette.neutral800,
  textDim: palette.neutral600,
  background: palette.neutral200,
  border: palette.neutral400,
  tint: palette.primary500,
  tintInactive: palette.neutral300,
  separator: palette.neutral300,
  error: palette.angry500,
  errorBackground: palette.angry100,
} as const

================
File: app/theme/index.ts
================
import type { StyleProp } from "react-native"
import { colors as colorsLight } from "./colors"
import { colors as colorsDark } from "./colorsDark"
import { spacing as spacingLight } from "./spacing"
import { spacing as spacingDark } from "./spacingDark"
import { timing } from "./timing"
import { typography } from "./typography"

// This supports "light" and "dark" themes by default. If undefined, it'll use the system theme
export type ThemeContexts = "light" | "dark" | undefined

// Because we have two themes, we need to define the types for each of them.
// colorsLight and colorsDark should have the same keys, but different values.
export type Colors = typeof colorsLight | typeof colorsDark
// The spacing type needs to take into account the different spacing values for light and dark themes.
export type Spacing = typeof spacingLight | typeof spacingDark

// These two are consistent across themes.
export type Timing = typeof timing
export type Typography = typeof typography

// The overall Theme object should contain all of the data you need to style your app.
export interface Theme {
  colors: Colors
  spacing: Spacing
  typography: Typography
  timing: Timing
  isDark: boolean
}

// Here we define our themes.
export const lightTheme: Theme = {
  colors: colorsLight,
  spacing: spacingLight,
  typography,
  timing,
  isDark: false,
}
export const darkTheme: Theme = {
  colors: colorsDark,
  spacing: spacingDark,
  typography,
  timing,
  isDark: true,
}

/**
 * Represents a function that returns a styled component based on the provided theme.
 * @template T The type of the style.
 * @param theme The theme object.
 * @returns The styled component.
 *
 * @example
 * const $container: ThemedStyle<ViewStyle> = (theme) => ({
 *   flex: 1,
 *   backgroundColor: theme.colors.background,
 *   justifyContent: "center",
 *   alignItems: "center",
 * })
 * // Then use in a component like so:
 * const Component = () => {
 *   const { themed } = useAppTheme()
 *   return <View style={themed($container)} />
 * }
 */
export type ThemedStyle<T> = (theme: Theme) => T
export type ThemedStyleArray<T> = (
  | ThemedStyle<T>
  | StyleProp<T>
  | (StyleProp<T> | ThemedStyle<T>)[]
)[]

// Export the theme objects with backwards compatibility for the old theme structure.
export { colorsLight as colors }
export { colorsDark }
export { spacingLight as spacing }

export * from "./styles"
export * from "./typography"
export * from "./timing"

================
File: app/theme/spacing.ts
================
/**
  Use these spacings for margins/paddings and other whitespace throughout your app.
 */
export const spacing = {
  xxxs: 2,
  xxs: 4,
  xs: 8,
  sm: 12,
  md: 16,
  lg: 24,
  xl: 32,
  xxl: 48,
  xxxl: 64,
} as const

================
File: app/theme/spacingDark.ts
================
const SPACING_MULTIPLIER = 1.0

// This is an example of how you can have different spacing values for different themes.
export const spacing = {
  xxxs: 2 * SPACING_MULTIPLIER,
  xxs: 4 * SPACING_MULTIPLIER,
  xs: 8 * SPACING_MULTIPLIER,
  sm: 12 * SPACING_MULTIPLIER,
  md: 16 * SPACING_MULTIPLIER,
  lg: 24 * SPACING_MULTIPLIER,
  xl: 32 * SPACING_MULTIPLIER,
  xxl: 48 * SPACING_MULTIPLIER,
  xxxl: 64 * SPACING_MULTIPLIER,
} as const

================
File: app/theme/styles.ts
================
import { ViewStyle } from "react-native"

/* Use this file to define styles that are used in multiple places in your app. */
export const $styles = {
  row: { flexDirection: "row" } as ViewStyle,
  flex1: { flex: 1 } as ViewStyle,
  flexWrap: { flexWrap: "wrap" } as ViewStyle,

  toggleInner: {
    width: "100%",
    height: "100%",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
  } as ViewStyle,
}

================
File: app/theme/timing.ts
================
export const timing = {
  /**
   * The duration (ms) for quick animations.
   */
  quick: 300,
}

================
File: app/theme/typography.ts
================
// TODO: write documentation about fonts and typography along with guides on how to add custom fonts in own
// markdown file and add links from here

import { Platform } from "react-native"
import {
  SpaceGrotesk_300Light as spaceGroteskLight,
  SpaceGrotesk_400Regular as spaceGroteskRegular,
  SpaceGrotesk_500Medium as spaceGroteskMedium,
  SpaceGrotesk_600SemiBold as spaceGroteskSemiBold,
  SpaceGrotesk_700Bold as spaceGroteskBold,
} from "@expo-google-fonts/space-grotesk"

export const customFontsToLoad = {
  spaceGroteskLight,
  spaceGroteskRegular,
  spaceGroteskMedium,
  spaceGroteskSemiBold,
  spaceGroteskBold,
}

const fonts = {
  spaceGrotesk: {
    // Cross-platform Google font.
    light: "spaceGroteskLight",
    normal: "spaceGroteskRegular",
    medium: "spaceGroteskMedium",
    semiBold: "spaceGroteskSemiBold",
    bold: "spaceGroteskBold",
  },
  helveticaNeue: {
    // iOS only font.
    thin: "HelveticaNeue-Thin",
    light: "HelveticaNeue-Light",
    normal: "Helvetica Neue",
    medium: "HelveticaNeue-Medium",
  },
  courier: {
    // iOS only font.
    normal: "Courier",
  },
  sansSerif: {
    // Android only font.
    thin: "sans-serif-thin",
    light: "sans-serif-light",
    normal: "sans-serif",
    medium: "sans-serif-medium",
  },
  monospace: {
    // Android only font.
    normal: "monospace",
  },
}

export const typography = {
  /**
   * The fonts are available to use, but prefer using the semantic name.
   */
  fonts,
  /**
   * The primary font. Used in most places.
   */
  primary: fonts.spaceGrotesk,
  /**
   * An alternate font used for perhaps titles and stuff.
   */
  secondary: Platform.select({ ios: fonts.helveticaNeue, android: fonts.sansSerif }),
  /**
   * Lets get fancy with a monospace font!
   */
  code: Platform.select({ ios: fonts.courier, android: fonts.monospace }),
}

================
File: app/utils/crashReporting.ts
================
/**
 * If you're using Sentry
 *   Expo https://docs.expo.dev/guides/using-sentry/
 */
// import * as Sentry from "@sentry/react-native"

/**
 * If you're using Crashlytics: https://rnfirebase.io/crashlytics/usage
 */
// import crashlytics from "@react-native-firebase/crashlytics"

/**
 * If you're using Bugsnag:
 *   RN   https://docs.bugsnag.com/platforms/react-native/)
 *   Expo https://docs.bugsnag.com/platforms/react-native/expo/
 */
// import Bugsnag from "@bugsnag/react-native"
// import Bugsnag from "@bugsnag/expo"

/**
 *  This is where you put your crash reporting service initialization code to call in `./app/app.tsx`
 */
export const initCrashReporting = () => {
  // Sentry.init({
  //   dsn: "YOUR DSN HERE",
  //   debug: true, // If `true`, Sentry will try to print out useful debugging information if something goes wrong with sending the event. Set it to `false` in production
  // })
  // Bugsnag.start("YOUR API KEY")
}

/**
 * Error classifications used to sort errors on error reporting services.
 */
export enum ErrorType {
  /**
   * An error that would normally cause a red screen in dev
   * and force the user to sign out and restart.
   */
  FATAL = "Fatal",
  /**
   * An error caught by try/catch where defined using Reactotron.tron.error.
   */
  HANDLED = "Handled",
}

/**
 * Manually report a handled error.
 */
export const reportCrash = (error: Error, type: ErrorType = ErrorType.FATAL) => {
  if (__DEV__) {
    // Log to console and Reactotron in development
    const message = error.message || "Unknown"
    console.error(error)
    console.log(message, type)
  } else {
    // In production, utilize crash reporting service of choice below:
    // RN
    // Sentry.captureException(error)
    // crashlytics().recordError(error)
    // Bugsnag.notify(error)
  }
}

================
File: app/utils/delay.ts
================
/**
 * A "modern" sleep statement.
 *
 * @param ms The number of milliseconds to wait.
 */
export const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))

================
File: app/utils/formatDate.ts
================
// Note the syntax of these imports from the date-fns library.
// If you import with the syntax: import { format } from "date-fns" the ENTIRE library
// will be included in your production bundle (even if you only use one function).
// This is because react-native does not support tree-shaking.
import { type Locale } from "date-fns/locale"
import { format } from "date-fns/format"
import { parseISO } from "date-fns/parseISO"
import i18n from "i18next"

type Options = Parameters<typeof format>[2]

let dateFnsLocale: Locale
export const loadDateFnsLocale = () => {
  const primaryTag = i18n.language.split("-")[0]
  switch (primaryTag) {
    case "en":
      dateFnsLocale = require("date-fns/locale/en-US").default
      break
    case "ar":
      dateFnsLocale = require("date-fns/locale/ar").default
      break
    case "ko":
      dateFnsLocale = require("date-fns/locale/ko").default
      break
    case "es":
      dateFnsLocale = require("date-fns/locale/es").default
      break
    case "fr":
      dateFnsLocale = require("date-fns/locale/fr").default
      break
    case "hi":
      dateFnsLocale = require("date-fns/locale/hi").default
      break
    case "ja":
      dateFnsLocale = require("date-fns/locale/ja").default
      break
    default:
      dateFnsLocale = require("date-fns/locale/en-US").default
      break
  }
}

export const formatDate = (date: string, dateFormat?: string, options?: Options) => {
  const dateOptions = {
    ...options,
    locale: dateFnsLocale,
  }
  return format(parseISO(date), dateFormat ?? "MMM dd, yyyy", dateOptions)
}

================
File: app/utils/gestureHandler.native.ts
================
// Only import react-native-gesture-handler on native platforms
// https://reactnavigation.org/docs/drawer-navigator/#installation
import "react-native-gesture-handler"

================
File: app/utils/gestureHandler.ts
================
// Don't import react-native-gesture-handler on web
// https://reactnavigation.org/docs/drawer-navigator/#installation

// This however is needed at the moment
// https://github.com/software-mansion/react-native-gesture-handler/issues/2402
import "setimmediate"

================
File: app/utils/ignoreWarnings.ts
================
/**
 * Ignore some yellowbox warnings. Some of these are for deprecated functions
 * that we haven't gotten around to replacing yet.
 */
import { LogBox } from "react-native"

// prettier-ignore
LogBox.ignoreLogs([
  "Require cycle:",
  "Overriding previous layout animation with new one before the first began:",
])

================
File: app/utils/openLinkInBrowser.ts
================
import { Linking } from "react-native"

/**
 * Helper for opening a give URL in an external browser.
 */
export function openLinkInBrowser(url: string) {
  Linking.canOpenURL(url).then((canOpen) => canOpen && Linking.openURL(url))
}

================
File: app/utils/storage/index.ts
================
export * from "./storage"

================
File: app/utils/storage/storage.test.ts
================
import { load, loadString, save, saveString, clear, remove, storage } from "./storage"

const VALUE_OBJECT = { x: 1 }
const VALUE_STRING = JSON.stringify(VALUE_OBJECT)

describe("MMKV Storage", () => {
  beforeEach(() => {
    storage.clearAll()
    storage.set("string", "string")
    storage.set("object", JSON.stringify(VALUE_OBJECT))
  })

  it("should be defined", () => {
    expect(storage).toBeDefined()
  })

  it("should have default keys", () => {
    expect(storage.getAllKeys()).toEqual(["string", "object"])
  })

  it("should load data", () => {
    expect(load<object>("object")).toEqual(VALUE_OBJECT)
    expect(loadString("object")).toEqual(VALUE_STRING)

    expect(load<string>("string")).toEqual("string")
    expect(loadString("string")).toEqual("string")
  })

  it("should save strings", () => {
    saveString("string", "new string")
    expect(loadString("string")).toEqual("new string")
  })

  it("should save objects", () => {
    save("object", { y: 2 })
    expect(load<object>("object")).toEqual({ y: 2 })
    save("object", { z: 3, also: true })
    expect(load<object>("object")).toEqual({ z: 3, also: true })
  })

  it("should save strings and objects", () => {
    saveString("object", "new string")
    expect(loadString("object")).toEqual("new string")
  })

  it("should remove data", () => {
    remove("object")
    expect(load<object>("object")).toBeNull()
    expect(storage.getAllKeys()).toEqual(["string"])

    remove("string")
    expect(load<string>("string")).toBeNull()
    expect(storage.getAllKeys()).toEqual([])
  })

  it("should clear all data", () => {
    expect(storage.getAllKeys()).toEqual(["string", "object"])
    clear()
    expect(storage.getAllKeys()).toEqual([])
  })
})

================
File: app/utils/storage/storage.ts
================
import { MMKV } from "react-native-mmkv"
export const storage = new MMKV()

/**
 * Loads a string from storage.
 *
 * @param key The key to fetch.
 */
export function loadString(key: string): string | null {
  try {
    return storage.getString(key) ?? null
  } catch {
    // not sure why this would fail... even reading the RN docs I'm unclear
    return null
  }
}

/**
 * Saves a string to storage.
 *
 * @param key The key to fetch.
 * @param value The value to store.
 */
export function saveString(key: string, value: string): boolean {
  try {
    storage.set(key, value)
    return true
  } catch {
    return false
  }
}

/**
 * Loads something from storage and runs it thru JSON.parse.
 *
 * @param key The key to fetch.
 */
export function load<T>(key: string): T | null {
  let almostThere: string | null = null
  try {
    almostThere = loadString(key)
    return JSON.parse(almostThere ?? "") as T
  } catch {
    return (almostThere as T) ?? null
  }
}

/**
 * Saves an object to storage.
 *
 * @param key The key to fetch.
 * @param value The value to store.
 */
export function save(key: string, value: unknown): boolean {
  try {
    saveString(key, JSON.stringify(value))
    return true
  } catch {
    return false
  }
}

/**
 * Removes something from storage.
 *
 * @param key The key to kill.
 */
export function remove(key: string): void {
  try {
    storage.delete(key)
  } catch {}
}

/**
 * Burn it all to the ground.
 */
export function clear(): void {
  try {
    storage.clearAll()
  } catch {}
}

================
File: app/utils/useAppTheme.ts
================
import { createContext, useCallback, useContext, useEffect, useMemo, useState } from "react"
import { StyleProp, useColorScheme } from "react-native"
import { DarkTheme, DefaultTheme, useTheme as useNavTheme } from "@react-navigation/native"
import {
  type Theme,
  type ThemeContexts,
  type ThemedStyle,
  type ThemedStyleArray,
  lightTheme,
  darkTheme,
} from "@/theme"
import * as SystemUI from "expo-system-ui"

type ThemeContextType = {
  themeScheme: ThemeContexts
  setThemeContextOverride: (newTheme: ThemeContexts) => void
}

// create a React context and provider for the current theme
export const ThemeContext = createContext<ThemeContextType>({
  themeScheme: undefined, // default to the system theme
  setThemeContextOverride: (_newTheme: ThemeContexts) => {
    console.error("Tried to call setThemeContextOverride before the ThemeProvider was initialized")
  },
})

const themeContextToTheme = (themeContext: ThemeContexts): Theme =>
  themeContext === "dark" ? darkTheme : lightTheme

const setImperativeTheming = (theme: Theme) => {
  SystemUI.setBackgroundColorAsync(theme.colors.background)
}

export const useThemeProvider = (initialTheme: ThemeContexts = undefined) => {
  const colorScheme = useColorScheme()
  const [overrideTheme, setTheme] = useState<ThemeContexts>(initialTheme)

  const setThemeContextOverride = useCallback((newTheme: ThemeContexts) => {
    setTheme(newTheme)
  }, [])

  const themeScheme = overrideTheme || colorScheme || "light"
  const navigationTheme = themeScheme === "dark" ? DarkTheme : DefaultTheme

  useEffect(() => {
    setImperativeTheming(themeContextToTheme(themeScheme))
  }, [themeScheme])

  return {
    themeScheme,
    navigationTheme,
    setThemeContextOverride,
    ThemeProvider: ThemeContext.Provider,
  }
}

interface UseAppThemeValue {
  // The theme object from react-navigation
  navTheme: typeof DefaultTheme
  // A function to set the theme context override (for switching modes)
  setThemeContextOverride: (newTheme: ThemeContexts) => void
  // The current theme object
  theme: Theme
  // The current theme context "light" | "dark"
  themeContext: ThemeContexts
  // A function to apply the theme to a style object.
  // See examples in the components directory or read the docs here:
  // https://docs.infinite.red/ignite-cli/boilerplate/app/utils/
  themed: <T>(styleOrStyleFn: ThemedStyle<T> | StyleProp<T> | ThemedStyleArray<T>) => T
}

/**
 * Custom hook that provides the app theme and utility functions for theming.
 *
 * @returns {UseAppThemeReturn} An object containing various theming values and utilities.
 * @throws {Error} If used outside of a ThemeProvider.
 */
export const useAppTheme = (): UseAppThemeValue => {
  const navTheme = useNavTheme()
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error("useTheme must be used within a ThemeProvider")
  }

  const { themeScheme: overrideTheme, setThemeContextOverride } = context

  const themeContext: ThemeContexts = useMemo(
    () => overrideTheme || (navTheme.dark ? "dark" : "light"),
    [overrideTheme, navTheme],
  )

  const themeVariant: Theme = useMemo(() => themeContextToTheme(themeContext), [themeContext])

  const themed = useCallback(
    <T>(styleOrStyleFn: ThemedStyle<T> | StyleProp<T> | ThemedStyleArray<T>) => {
      const flatStyles = [styleOrStyleFn].flat(3)
      const stylesArray = flatStyles.map((f) => {
        if (typeof f === "function") {
          return (f as ThemedStyle<T>)(themeVariant)
        } else {
          return f
        }
      })

      // Flatten the array of styles into a single object
      return Object.assign({}, ...stylesArray) as T
    },
    [themeVariant],
  )

  return {
    navTheme,
    setThemeContextOverride,
    theme: themeVariant,
    themeContext,
    themed,
  }
}

================
File: app/utils/useHeader.tsx
================
import { useEffect, useLayoutEffect } from "react"
import { useNavigation } from "@react-navigation/native"
import { Header, HeaderProps } from "../components"
import { Platform } from "react-native"

/**
 * A hook that can be used to easily set the Header of a react-navigation screen from within the screen's component.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/utility/useHeader/}
 * @param {HeaderProps} headerProps - The props for the `Header` component.
 * @param {any[]} deps - The dependencies to watch for changes to update the header.
 */
export function useHeader(
  headerProps: HeaderProps,
  deps: Parameters<typeof useLayoutEffect>[1] = [],
) {
  const navigation = useNavigation()

  /**
   * We need to have multiple implementations of this hook for web and mobile.
   * Web needs to use useEffect to avoid a rendering loop.
   * In mobile and also to avoid a visible header jump when navigating between screens, we use
   * `useLayoutEffect`, which will apply the settings before the screen renders.
   */
  const usePlatformEffect = Platform.OS === "web" ? useEffect : useLayoutEffect

  // To avoid a visible header jump when navigating between screens, we use
  // `useLayoutEffect`, which will apply the settings before the screen renders.
  usePlatformEffect(() => {
    navigation.setOptions({
      headerShown: true,
      header: () => <Header {...headerProps} />,
    })
    // intentionally created API to have user set when they want to update the header via `deps`
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [...deps, navigation])
}

================
File: app/utils/useIsMounted.ts
================
import { useEffect, useCallback, useRef } from "react"

/**
 * A common react custom hook to check if the component is mounted.
 * @returns {() => boolean} - A function that returns true if the component is mounted.
 */
export function useIsMounted() {
  const isMounted = useRef(false)

  useEffect(() => {
    isMounted.current = true

    return () => {
      isMounted.current = false
    }
  }, [])

  return useCallback(() => isMounted.current, [])
}

================
File: app/utils/useSafeAreaInsetsStyle.ts
================
import { Edge, useSafeAreaInsets } from "react-native-safe-area-context"

export type ExtendedEdge = Edge | "start" | "end"

const propertySuffixMap = {
  top: "Top",
  bottom: "Bottom",
  left: "Start",
  right: "End",
  start: "Start",
  end: "End",
}

const edgeInsetMap: Record<string, Edge> = {
  start: "left",
  end: "right",
}

export type SafeAreaInsetsStyle<
  Property extends "padding" | "margin" = "padding",
  Edges extends Array<ExtendedEdge> = Array<ExtendedEdge>,
> = {
  [K in Edges[number] as `${Property}${Capitalize<K>}`]: number
}

/**
 * A hook that can be used to create a safe-area-aware style object that can be passed directly to a View.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/utils/useSafeAreaInsetsStyle.ts/}
 * @param {ExtendedEdge[]} safeAreaEdges - The edges to apply the safe area insets to.
 * @param {"padding" | "margin"} property - The property to apply the safe area insets to.
 * @returns {SafeAreaInsetsStyle<Property, Edges>} - The style object with the safe area insets applied.
 */
export function useSafeAreaInsetsStyle<
  Property extends "padding" | "margin" = "padding",
  Edges extends Array<ExtendedEdge> = [],
>(
  safeAreaEdges: Edges = [] as unknown as Edges,
  property: Property = "padding" as Property,
): SafeAreaInsetsStyle<Property, Edges> {
  const insets = useSafeAreaInsets()

  return safeAreaEdges.reduce((acc, e) => {
    const value = edgeInsetMap[e] ?? e
    return { ...acc, [`${property}${propertySuffixMap[e]}`]: insets[value] }
  }, {}) as SafeAreaInsetsStyle<Property, Edges>
}

================
File: babel.config.js
================
/** @type {import('@babel/core').TransformOptions} */
module.exports = function (api) {
  api.cache(true)
  return {
    presets: ["babel-preset-expo"],
  }
}

================
File: docs/boilerplate/android.md
================
---
title: android
sidebar_position: 5
---

# `android`

If you choose the `manual` workflow option when spinning up a new app (or you run `yarn prebuild:clean`) you'll get an `android` (and probably [`ios`](./ios.md)) folder in your project root. This folder contains your native Android / Android Studio project, which has been pre-configured to work with React Native.

We generally recommend using the [Expo CNG (continuous native generation)](../expo/CNG.md) workflow, but if you need to customize your native code manually, you can do so here.

Just like any React Native project, you can open this folder in Android Studio and run your app on an emulator or device. Learn more here: [https://reactnative.dev/docs/native-debugging#debugging-native-code](https://reactnative.dev/docs/native-debugging#debugging-native-code)

================
File: docs/boilerplate/app.json.md
================
---
title: app.json / app.config.js
sidebar_position: 60
---

# app.json / app.config.js

The app.json & app.config.js files are used to configure your React Native / Expo project.

Ignite has already configured several things for us:

- App Icons - configured for iOS, Android, and Web. Check out [App Icon Generators](../../concept/Generators#app-icon-generator) to update your App Icon.
- Splash Screen colors and images - configured for iOS, Android, and Web. Check out [Splash Screen Generators](../../concept/Generators#splash-screen-generator) to update your Splash Screen.
- Expo plugins for things like localization and splash screens

See [Expo's Documentation on App.json Configuration](https://docs.expo.dev/workflow/configuration/) for more details.

================
File: docs/boilerplate/app/app.md
================
---
title: app
---

# `app` folder

The vast majority of your code will live in the `app` folder. This is where you'll spend most of your time.

In this folder, there's only one file ([app.tsx](./app.tsx.md)). The rest are folders for containing components, models, screens, and more.

- [app.tsx](./app.tsx.md) - The main entry point for your app
- [components](./components/Components.md) - Reusable components
- [config](./config/Config.md) - Configuration files
- [devtools](./devtools/Devtools.md) - Configuration/setup for Reactotron and other dev tools
- [i18n](./i18n/Internationalization.md) - Internationalization setup
- [models](./models/Models.md) - MobX-State-Tree models
- [navigators](./navigators/Navigation.md) - React Navigation navigators
- [screens](./screens/Screens.md) - The main screens of your app
- [services](./services/Services.md) - Services, such as API clients
- [theme](./theme/Theming.md) - Theme files
- [utils](./utils/Utils.md) - Utility functions and hooks

================
File: docs/boilerplate/app/app.tsx.md
================
# app.tsx

The `app/app.tsx` file is the main entry point for your app.

:::tip
Don't confuse this `app/app.tsx` file with the `index.tsx` component in the root of your project -- that's the entry point for Expo/React Native itself and just immediately loads this one after setting up the splash screen.
:::

Most of this file is boilerplate and you shouldn't need to modify it very often. But take some time to look through and understand what is going on.

Things that this file is responsible for:

- Loading fonts
- Setting up internationalization
- Initializing the root MST store
- Initializing the root navigator
- Ensuring everything is loaded and then hiding the splash screen
- Setting up the safe area provider
- Rendering error boundaries and error screen
- Enabling deep linking

================
File: docs/boilerplate/app/components/AutoImage.md
================
---
sidebar_position: 30
---

# AutoImage

Ignite's `AutoImage` Component is an enhanced version of the built-in React Native [Image](https://reactnative.dev/docs/image) component. It automatically resizes the image view to fit a max width or height constraint

![autoimage-component](https://github.com/user-attachments/assets/8fba1f1d-81d2-4f0d-84bb-8286b048ff16)

```tsx
<AutoImage
  source={{ uri: "https://pbs.twimg.com/profile_images/845384502067159040/pqF2RQ2q_400x400.jpg" }}
  maxWidth={200}
/>
```

`AutoImage` uses a `useAutoImage` hook to calculate the image's dimensions when you have a specific values you need to constrain the image within. This hook is also available for use in your own components.

```tsx
const { width, height } = useAutoImage(uri, maxWidth, maxHeight)
```

## Props

Ignite's `AutoImage` component has these props of its own:

### `maxWidth` and `maxHeight`

These props are used to constrain the image to a specific size. Use `maxWidth` or `maxHeight` to set the maximum width or height of the image, and it will resize to whichever dimension you specify without skewing the aspect ratio. e.g. If the image is 300w x 200h, and you set `maxWidth={200}`, the image will be resized to 200w x 133h.

```tsx
<AutoImage
  source={{ uri: "https://pbs.twimg.com/profile_images/845384502067159040/pqF2RQ2q_400x400.jpg" }}
  maxWidth={200}
  maxHeight={200}
/>
```

### `headers`

This props let you use the image with additional headers

```tsx
<AutoImage
  source={{ uri: "https://pbs.twimg.com/profile_images/845384502067159040/pqF2RQ2q_400x400.jpg" }}
  headers: {
    Authorization: `Bearer abc123`,
  }
/>
```

## Default Image props

As `AutoImage` is a wrapper around React Native's `Image` component, it also accepts all of the props that `Image` accepts. See the [React Native Image documentation](https://reactnative.dev/docs/image) for more information.

### `source`

As with React Native's built in Image component, the `source` prop is always required. This can be _almost_ anything that conforms to ReactNative's [ImageSource](https://reactnative.dev/docs/image#imagesource) type. (See [Notes](#Notes) below for caveats.)

```tsx
<AutoImage source={logoIgnite} />
```

### `style`

Setting the `style` prop will override the default styles. With `AutoImage`, you generally only need to specify width _or_ height with dynamically loaded images. Setting both will override the resizing of `AutoImage` altogether, and if that is needed it's best to just use the default React Native `Image` component.

```tsx
<AutoImage source={logoIgnite} style={{ width: 200 }} />
```

```tsx
<AutoImage source={logoIgnite} style={{ height: 200 }} />
```

## Notes

As noted above, the `source` prop can be almost anything, the one exception being an array of objects, which `AutoImage` doesn't support. See the React Native [Image#source](https://reactnative.dev/docs/image#source) documentation for more information.

================
File: docs/boilerplate/app/components/Button.md
================
---
sidebar_position: 31
---

# Button

The `Button` component is a wrapper around the [`Pressable`](https://reactnative.dev/docs/pressable) component. Any prop that can be passed to `Pressable` can be passed to `Button` and it will be forwarded. `Button` renders a button with given text in a [`Text`](./Text.md) component or children. It allows you to specify the preset style of the button, you can override both the `Pressable` and `Text` styles.

![button-component](https://github.com/user-attachments/assets/485e0fe9-caba-4477-ae29-39bd30107809)

```tsx
<Button
  text="Click It"
  tx="button:clickIt"
  preset="default"
  onPress={() => Alert.alert("pressed")}
  style={[{ paddingVertical: 100 }, { borderRadius: 0 }]}
  pressedStyle={[{ backgroundColor: "red" }, { borderRadius: 0 }]}
  textStyle={[{ fontSize: 20 }, { color: "#a511dc" }]}
  pressedTextStyle={[{ fontSize: 20 }, { color: "#a51111" }]}
  RightAccessory={(props) => <Icon icon="check" />}
  LeftAccessory={(props) => <Icon icon="close" />}
/>
```

## Props

### `text`

The `text` prop is required if `tx` or `children` are not provided. This is the text to be rendered in the button.

```tsx
<Button text="Click me" />
```

### `tx`

The `tx` prop is required if `text` or `children` are not provided. This is the translation key to be used to translate the text.

```tsx
<Button tx="button:clickMe" />
```

### `children`

The `children` prop is required if no `tx` or `text` prop is passed. This is the content to be rendered in the button in place of the default `Text` component.

```tsx
<Button>
  <Text>Click me</Text>
</Button>
```

### `preset`

The `preset` prop is optional. This is the preset style of the button. It can be one of the following built-in options: `default`, `filled`, `reversed`

```tsx
<Button preset="default" tx="button:clickMe" />
```

To make a custom preset, add a key to the `$viewPresets`, `$textPresets`, `$pressedViewPresets` and `$pressedTextPresets` objects in `app/components/Button.tsx` and then pass the name of the preset to the `preset` prop.

```tsx
const $viewPresets = {
  // ...
  danger: [$baseViewStyle, { backgroundColor: colors.palette.angry500 }] as StyleProp<ViewStyle>,
}

const $textPresets: Record<Presets, StyleProp<TextStyle>> = {
  // ...
  danger: [$baseTextStyle, { color: colors.palette.angry500 }] as StyleProp<TextStyle>,
}

const $pressedViewPresets: Record<Presets, StyleProp<ViewStyle>> = {
  // ...
  danger: { backgroundColor: colors.palette.angry500 },
}

const $pressedTextPresets: Record<Presets, StyleProp<TextStyle>> = {
  angry: { opacity: 0.7 },
}
```

```tsx
<Button preset="danger" text="Delete" />
```

### `textStyle`

The `textStyle` prop is optional. This can be used to style text in the button. Values passed here will override anything set in the preset.

```tsx
<Button textStyle={{ fontSize: 20, color: "#a511dc" }} />
```

### `pressedTextStyle`

The `pressedTextStyle` prop is optional. This can be used to style text in the button when it is pressed. Values passed here will override anything set in the preset.

```tsx
<Button pressedTextStyle={{ fontSize: 20, color: "#a51111" }} />
```

### `disabledTextStyle`

The `disabledTextStyle` prop is optional. It can be used to style text in the button when the `disabled` prop is set. Values here will override anything set in the preset.

```tsx
<Button disabled disabledTextStyle={{ fontSize: 20, color: "#000000" }} />
```

### `style`

The `style` prop is optional. This can be used to style the `Pressable` component of the `Button`. Values passed here will override anything set in the preset.

```tsx
<Button style={{ paddingVertical: 20, borderRadius: 10 }}>
```

### `pressedStyle`

The `pressedStyle` prop is optional. This can be used to style the `Pressable` component of the `Button` when it is pressed. Values passed here will override anything set in the preset.

```tsx
<Button pressedStyle={{ backgroundColor: "red" }} />
```

### `disabledStyle`

The `disabledStyle` prop is optional. This can be used to style the `Pressable` component of the `Button` when the `disabled` prop is truthy. Values passed here will override anything set in the preset.

```tsx
<Button disabledStyle={{ opacity: 0.5 }} />
```

### `LeftAccessory` and `RightAccessory`

The `LeftAccessory` and `RightAccessory` props are optional. They can be used to render an accessory on the left or right side of the button. It can be a React component or a function that returns a React component. The accessory component will receive the pressed state of the `Pressable` via the `pressableState` prop, so you can make a custom accessory component render differently when pressed. Additionally, you can utilize the default accessory styles via the `style` prop.

```tsx
<Button
  LeftAccessory={(props) => (
    <Icon containerStyle={props.style} size={props.pressableState.pressed ? 50 : 40} icon="check" />
  )}
/>
```

```tsx
<Button
  RightAccessory={(props) => (
    <Icon containerStyle={props.style} size={props.pressableState.pressed ? 50 : 40} icon="check" />
  )}
/>
```

If the accessories flicker when some prop or state changes, you can memoize the accessory with `useMemo`.

```tsx
<Button
  LeftAccessory={useMemo(
    () =>
      function LeftIcon(props: ButtonAccessoryProps) {
        return <Icon icon={props.pressableState.pressed ? "view" : "hidden"} />
      },
    [],
  )}
/>
```

### `disabled`

The `disabled` prop is optional. It gets passed to the underlying `Pressable` component. When truthy, it will [disable the press behavior on the pressable](https://reactnative.dev/docs/pressable#disabled). It will also update the [`accessibilityState`](https://reactnative.dev/docs/0.72/touchablewithoutfeedback#accessibilitystate) of the `Pressable` when set.

This prop will be passed down to the `LeftAccessory` and `RightAccessory` components, if they exist, and will cause the `disabledStyle` and `disabledTextStyle` props to be used, if they have been set.

================
File: docs/boilerplate/app/components/Card.md
================
---
sidebar_position: 32
---

# Card

The `Card` component is intended to be used for vertically aligned related content. It is a container that can hold a heading, content, and footer. It can also hold a left and right component that will be aligned to the left and right of the card body.

## Props

```tsx
<Card
  preset="reversed"
  verticalAlignment="space-between"
  LeftComponent={<Text>Left</Text>}
  RightComponent={<Text>Right</Text>}
  heading="Card Heading"
  headingStyle={{ color: "#a511dc" }}
  HeadingTextProps={{ weight: "bold" }}
  content="Card Content"
  contentStyle={{ color: "#a511dc" }}
  ContentTextProps={{ weight: "light" }}
  footer="Card Footer"
  footerStyle={{ color: "#a511dc" }}
  FooterTextProps={{ weight: "medium" }}
/>
```

### `preset`

The `preset` prop is used to set the preset container style of the card. This affects the border and background color of the container. There are two preconfigured presets: `default` and `reversed`.

![card-component-01](https://github.com/user-attachments/assets/e5a19ec9-b426-428e-ae19-a1086dc2e4bc)

```tsx
<Card preset="reversed" heading="Card Heading" content="Card Content" footer="Card Footer" />
```

### `verticalAlignment`

The `verticalAlignment` prop is used to set the vertical alignment of the card's content. This affects the alignment of the heading, content, and footer. There are four preconfigured alignments: `top`, `center`, `space-between`, and `force-footer-bottom`. `force-footer-bottom` behaves like `top`, but will force the footer to the bottom of the card.

![card-component-02](https://github.com/user-attachments/assets/e5e9f331-6c4d-4ce3-833d-a00fdf7244f1)

```tsx
<Card
  verticalAlignment="space-between"
  heading="Card Heading"
  content="Card Content"
  footer="Card Footer"
/>
```

### `LeftComponent` & `RightComponent`

The `LeftComponent` and `RightComponent` props are used to set the component that will be aligned to the left or right of the card body, respectively.

![card-component-03](https://github.com/user-attachments/assets/68df8495-ee9b-452f-b86f-b39ee76a052c)

```tsx
<Card
  LeftComponent={
    <AutoImage
      maxWidth={80}
      maxHeight={60}
      style={{ alignSelf: "center" }}
      source={{
        uri: "https://user-images.githubusercontent.com/1775841/184508739-f90d0ce5-7219-42fd-a91f-3382d016eae0.png",
      }}
    />
  }
  RightComponent={
    <Button preset="default" text="Click It" onPress={() => Alert.alert("pressed")} />
  }
  heading="Card Heading"
  content="Card Content"
  footer="Card Footer"
/>
```

### `heading`

The `heading` prop is used to set the heading text of the card.

```tsx
<Card heading="Card Heading" content="Card Content" footer="Card Footer" />
```

### `headingTx`

The `headingTx` prop is used to set the heading text of the card using a translation key.

```tsx
<Card headingTx="card:heading" content="Card Content" footer="Card Footer" />
```

### `headingTxOptions`

The `headingTxOptions` prop is used to set the options for the translation key used by the `headingTx` prop.

```tsx
<Card
  headingTx="card:heading"
  headingTxOptions={{ count: 2 }}
  content="Card Content"
  footer="Card Footer"
/>
```

### `headingStyle`

The `headingStyle` prop is used to set the style of the heading text.

```tsx
<Card
  heading="Card Heading"
  headingStyle={{ color: "red" }}
  content="Card Content"
  footer="Card Footer"
/>
```

### `HeadingTextProps`

The `HeadingTextProps` prop is used to pass any additional props to the heading `Text` component. It will accept any prop that the [`Text`](./Text.md) component accepts.

```tsx
<Card
  heading="Card Heading"
  HeadingTextProps={{ size: "lg" }}
  content="Card Content"
  footer="Card Footer"
/>
```

### `HeadingComponent`

The `HeadingComponent` prop is used to set the component that will be used for the heading. This can be used to set a custom heading component.

```tsx
<Card
  HeadingComponent={<Button preset="reversed" text="HeadingComponent" icon="ladybug" />}
  content="Card Content"
  footer="Card Footer"
/>
```

### `content`

The `content` prop is used to set the content text of the card.

```tsx
<Card heading="Card Heading" content="Card Content" footer="Card Footer" />
```

### `contentTx`

The `contentTx` prop is used to set the content text of the card using a translation key.

```tsx
<Card heading="Card Heading" contentTx="card:content" footer="Card Footer" />
```

### `contentTxOptions`

The `contentTxOptions` prop is used to set the options for the translation key used by the `contentTx` prop.

```tsx
<Card
  heading="Card Heading"
  contentTx="card:content"
  contentTxOptions={{ count: 2 }}
  footer="Card Footer"
/>
```

### `contentStyle`

The `contentStyle` prop is used to set the style of the content text.

```tsx
<Card
  heading="Card Heading"
  content="Card Content"
  contentStyle={{ backgroundColor: colors.error, color: colors.palette.neutral100 }}
  footer="Card Footer"
/>
```

### `ContentTextProps`

The `ContentTextProps` prop is used to pass any additional props to the content `Text` component. It will accept any prop that the [`Text`](./Text.md) component accepts.

```tsx
<Card
  heading="Card Heading"
  content="Card Content"
  ContentTextProps={{ size: "lg" }}
  footer="Card Footer"
/>
```

### `ContentComponent`

The `ContentComponent` prop is used to set the component that will be used for the content. This can be used to set a custom content component.

```tsx
<Card
  heading="Card Heading"
  ContentComponent={<Button preset="reversed" text="ContentComponent" icon="ladybug" />}
  footer="Card Footer"
/>
```

### `footer`

The `footer` prop is used to set the footer text of the card.

```tsx
<Card heading="Card Heading" content="Card Content" footer="Card Footer" />
```

### `footerTx`

The `footerTx` prop is used to set the footer text of the card using a translation key.

```tsx
<Card heading="Card Heading" content="Card Content" footerTx="card:footer" />
```

### `footerTxOptions`

The `footerTxOptions` prop is used to set the options for the translation key used by the `footerTx` prop.

```tsx
<Card
  heading="Card Heading"
  content="Card Content"
  footerTx="card:footer"
  footerTxOptions={{ count: 2 }}
/>
```

### `footerStyle`

The `footerStyle` prop is used to set the style of the footer text.

```tsx
<Card
  heading="Card Heading"
  content="Card Content"
  footer="Card Footer"
  footerStyle={{ color: "red" }}
/>
```

### `FooterTextProps`

The `FooterTextProps` prop is used to pass any additional props to the footer `Text` component. It will accept any prop that the [`Text`](./Text.md) component accepts.

```tsx
<Card
  heading="Card Heading"
  content="Card Content"
  footer="Card Footer"
  FooterTextProps={{ size: "lg" }}
/>
```

### `FooterComponent`

The `FooterComponent` prop is used to set the component that will be used for the footer. This can be used to set a custom footer component.

```tsx
<Card
  heading="Card Heading"
  content="Card Content"
  FooterComponent={<Button preset="reversed" text="FooterComponent" icon="ladybug" />}
/>
```

================
File: docs/boilerplate/app/components/Checkbox.md
================
---
sidebar_position: 32
---

import ToggleProps from './\_toggle_props.mdx';

# Checkbox

The `Checkbox` component provides a simple way to collect user input for a boolean value.

## Checkbox Props

### `icon`

The `icon` is a prop for the checkbox variant that allows you to customize the icon used for the "on" state.

```tsx
<Checkbox icon="ladybug" />
```

<ToggleProps componentName="Checkbox" />

================
File: docs/boilerplate/app/components/Components.md
================
---
sidebar_position: 3
---

# Ignite Built-in Components

Ignite comes with a number of customizable built-in React Native components -- sort of a lightweight design system, in a way. It's the system we (at Infinite Red) tend to use the most often with our own custom mobile designs, and is designed to emphasize flexibility and customizability _over_ out-of-the-box power.

There are a number of other options out there that work great with Ignite -- [UI Kitten](https://akveo.github.io/react-native-ui-kitten/), [RN Elements](https://reactnativeelements.com/), and more. But if you're building something with a totally custom design, Ignite's built-in components work great.

## Components

Here's a summary of each component. Click through to view detailed documentation and code examples!

### AutoImage

This is a wrapper around React Native's [Image](https://reactnative.dev/docs/image) component, which automatically resizes the image to fit the container.

```tsx
<AutoImage
  source={{ uri: "https://pbs.twimg.com/profile_images/845384502067159040/pqF2RQ2q_400x400.jpg" }}
/>
```

[Full AutoImage Component Documentation](./AutoImage.md)

### Button

This is a component that renders a [`TouchableOpacity`](https://reactnative.dev/docs/touchableopacity) with given text or children.

```tsx
<Button
  text="Click It"
  tx="button:clickIt"
  preset="primary"
  onPress={() => Alert.alert("pressed")}
  style={[{ paddingVertical: 100 }, { borderRadius: 0 }]}
  textStyle={[{ fontSize: 20 }, { color: "#a511dc" }]}
/>
```

```tsx
<Button onPress={() => Alert.alert("pressed")}>
  <Text>Click It</Text>
</Button>
```

[Full Button Component Documentation](./Button.md)

### Card

The `Card` component is useful for displaying related information in a contained way. Where you'll use `ListItem` for horizontal information, `Card` can be used for vertical information.

```tsx
<Card
  preset="reversed"
  verticalAlignment="space-between"
  LeftComponent={<Text>Left</Text>}
  RightComponent={<Text>Right</Text>}
  heading="Card Heading"
  headingStyle={{ color: "#a511dc" }}
  HeadingTextProps={{ weight: "bold" }}
  content="Card Content"
  contentStyle={{ color: "#a511dc" }}
  ContentTextProps={{ weight: "light" }}
  footer="Card Footer"
  footerStyle={{ color: "#a511dc" }}
  FooterTextProps={{ weight: "medium" }}
/>
```

[Full Card Component Documentation](./Card.md)

### Checkbox

The `Checkbox` component is useful for displaying a user's choice for a boolean value.

```tsx
<Checkbox
  value={value}
  icon="check"
  onValueChange={setValue}
  labelTx="signup:rememberMe"
  labelStyle={{ color: "#a511dc" }}
  containerStyle={{ backgroundColor: "#fff" }}
/>
```

[Full Checkbox Component Documentation](./Checkbox.md)

### EmptyState

The `EmptyState` component can be used when there is no data to display and direct the user on how to proceed.

```tsx
<EmptyState
  preset="default"
  style={{ padding: 10 }}
  imageSource={require("../../assets/images/sad-face.png")}
  imageStyle={{ height: 400, width: 400 }}
  ImageProps={{ resizeMode: "contain" }}
  heading="EmptyState Heading"
  headingStyle={{ color: "#a511dc" }}
  HeadingTextProps={{ weight: "bold" }}
  content="EmptyState Content"
  contentStyle={{ color: "#a511dc" }}
  ContentTextProps={{ weight: "light" }}
  button="Press here"
  buttonOnPress={handleButtonPress}
/>
```

[Full EmptyState Component Documentation](./EmptyState.md)

### Header

The `Header` component is a component that will appear at the top of your screen. It is used to hold navigation buttons and the screen title.

```tsx
<Header
  headerTx="header:title"
  headerText="Header Title"
  leftIcon="back"
  rightIcon="bullet"
  onLeftPress={() => navigation.goBack()}
  onRightPress={() => Alert.alert("pressed")}
  style={{ backgroundColor: "purple" }}
  titleStyle={{ color: "white" }}
/>
```

[Full Header Component Documentation](./Header.md)

### Icon

This is a component that renders an icon.

```tsx
<Icon
  icon="back"
  color="#a511dc"
  size={30}
  containerStyle={{ backgroundColor: "#fff" }}
  style={{ resizeMode: "contain" }}
  onPress={() => Alert.alert("pressed")}
/>
```

[Full Icon Component Documentation](./Icon.md)

### Radio

The `Radio` component is useful for displaying a user's choice for a boolean value.

```tsx
<Radio
  value={value}
  onValueChange={setValue}
  labelTx="signup:rememberMe"
  labelStyle={{ color: "#a511dc" }}
  containerStyle={{ backgroundColor: "#fff" }}
/>
```

[Full Radio Component Documentation](./Radio.md)

### Screen

This is a component that renders a screen. It is used to wrap your entire screen, and handles scrolling, [safe areas](https://reactnavigation.org/docs/handling-safe-area/), and keyboard avoiding behavior.

```tsx
<Screen preset="scroll">
  <Header headerTitle="screen" />
  // ... content here ...
</Screen>
```

[Full Screen Component Documentation](./Screen.md)

### Switch

The `Switch` component is useful for displaying a user's choice for a boolean value.

```tsx
<Switch
  value={value}
  accessibilityMode="icon"
  onValueChange={setValue}
  labelTx="signup:rememberMe"
  labelStyle={{ color: "#a511dc" }}
  containerStyle={{ backgroundColor: "#fff" }}
/>
```

[Full Switch Component Documentation](./Switch.md)

### Text

This is an enhanced version of the built-in React Native Text component. It adds internationalization and property presets.

```tsx
<Text
  preset="header"
  tx="welcome:header"
  txOptions={{
    name: rootStore.currentUser.name,
  }}
  style={$header}
/>
```

[Full Text Component Documentation](./Text.md)

### TextField

This component renders a View with a [`TextInput`](https://reactnative.dev/docs/textinput) and a text label.

```tsx
const [input, setInput] = useState("")
const inputRef = useRef()
<TextField
  value={input}
  onChangeText={setInput}
  labelTx="signup:name"
  placeholderTx="signup:nameplaceholder"
  style={$header}
  inputStyle={$inputStyle}
  preset="default"
  forwardedRef={inputRef}
/>
```

[Full Text Component Documentation](./TextField.md)

## Custom Components

Ignite includes a generator for creating custom components. If the built in components don't fit your needs, you can create your own.

`npx ignite-cli generate component MyCustomButton`

Running the generator will create a new component in the `components` directory.

```
-- app
  -- components
    -- MyCustomButton.tsx
```

================
File: docs/boilerplate/app/components/EmptyState.md
================
---
sidebar_position: 33
---

# EmptyState

The `EmptyState` component is to be used when there is no data to display, usually after attempting to load some content from an external API. It is a container that can hold a heading and content. It can also display an image and provide a button to interact with.

## Props

```tsx
<EmptyState
  preset="generic"
  style={{ padding: 10 }}
  imageSource={require("../../assets/images/sad-face.png")}
  imageStyle={{ height: 400, width: 400 }}
  ImageProps={{ resizeMode: "contain" }}
  heading="EmptyState Heading"
  headingStyle={{ color: "#a511dc" }}
  HeadingTextProps={{ weight: "bold" }}
  content="EmptyState Content"
  contentStyle={{ color: "#a511dc" }}
  ContentTextProps={{ weight: "light" }}
  button="Press here"
  buttonOnPress={handleButtonPress}
/>
```

### `preset`

The `preset` prop is used to set the preset container style of the EmptyState. This affects the default image, heading, content and button. Currently, only one preconfigured preset exists: `generic`.
![empty-state](https://github.com/user-attachments/assets/aa8bca01-24f2-45e5-977d-5f6ac949d580)

```tsx
<EmptyState preset="generic" heading="EmptyState Heading" content="EmptyState Content" />
```

### `style`

The `style` prop is used to set the style override for the container.

```tsx
<EmptyState
  style={{ padding: 10, marginTop: 20 }}
  heading="EmptyState Heading"
  content="EmptyState Content"
/>
```

### `imageSource`

The `imageSource` prop is used to set the Image source to be displayed above the heading.

```tsx
<EmptyState
  imageSource={require("../../assets/images/empty-state.png")}
  heading="EmptyState Heading"
  content="EmptyState Content"
/>
```

### `imageStyle`

The `imageStyle` prop is used to set any style overrides to be applied to the image about the heading.

```tsx
<EmptyState
  imageSource={require("../../assets/images/empty-state.png")}
  imageStyle={{ borderRadius: 5 }}
  heading="EmptyState Heading"
  content="EmptyState Content"
/>
```

### `ImageProps`

The `ImageProps` prop is used to pass any additional props directly to the `Image` component. It will accept any prop that the `Image` component accepts.

```tsx
<EmptyState
  imageSource={require("../../assets/images/empty-state.png")}
  ImageProps={{ onLoad: handleImageLoaded }}
  heading="EmptyState Heading"
  content="EmptyState Content"
/>
```

### `heading`

The `heading` prop is used to set the heading text of the EmptyState.

```tsx
<EmptyState heading="EmptyState Heading" content="EmptyState Content" button="EmptyState Button" />
```

### `headingTx`

The `headingTx` prop is used to set the heading text of the EmptyState using a translation key.

```tsx
<EmptyState
  headingTx="EmptyState:heading"
  content="EmptyState Content"
  button="EmptyState Button"
/>
```

### `headingTxOptions`

The `headingTxOptions` prop is used to set the options for the translation key used by the `headingTx` prop.

```tsx
<EmptyState
  headingTx="EmptyState:heading"
  headingTxOptions={{ count: 2 }}
  content="EmptyState Content"
  button="EmptyState Button"
/>
```

### `headingStyle`

The `headingStyle` prop is used to set the style of the heading text.

```tsx
<EmptyState
  heading="EmptyState Heading"
  headingStyle={{ color: "red" }}
  content="EmptyState Content"
  button="EmptyState Button"
/>
```

### `HeadingTextProps`

The `HeadingTextProps` prop is used to pass any additional props to the heading `Text` component. It will accept any prop that the [`Text`](./Text.md) component accepts.

```tsx
<EmptyState
  heading="EmptyState Heading"
  HeadingTextProps={{ size: "lg" }}
  content="EmptyState Content"
  button="EmptyState Button"
/>
```

### `content`

The `content` prop is used to set the content text of the EmptyState.

```tsx
<EmptyState heading="EmptyState Heading" content="EmptyState Content" button="EmptyState Button" />
```

### `contentTx`

The `contentTx` prop is used to set the content text of the EmptyState using a translation key.

```tsx
<EmptyState
  heading="EmptyState Heading"
  contentTx="EmptyState:content"
  button="EmptyState Button"
/>
```

### `contentTxOptions`

The `contentTxOptions` prop is used to set the options for the translation key used by the `contentTx` prop.

```tsx
<EmptyState
  heading="EmptyState Heading"
  contentTx="EmptyState:content"
  contentTxOptions={{ count: 2 }}
  button="EmptyState Button"
/>
```

### `contentStyle`

The `contentStyle` prop is used to set the style of the content text.

```tsx
<EmptyState
  heading="EmptyState Heading"
  content="EmptyState Content"
  contentStyle={{ backgroundColor: colors.error, color: colors.palette.neutral100 }}
  button="EmptyState Button"
/>
```

### `ContentTextProps`

The `ContentTextProps` prop is used to pass any additional props to the content `Text` component. It will accept any prop that the [`Text`](./Text.md) component accepts.

```tsx
<EmptyState
  heading="EmptyState Heading"
  content="EmptyState Content"
  ContentTextProps={{ size: "lg" }}
  button="EmptyState Button"
/>
```

### `button`

The `button` prop is used to set the button text of the EmptyState.

```tsx
<EmptyState heading="EmptyState Heading" content="EmptyState Content" button="EmptyState Button" />
```

### `buttonTx`

The `buttonTx` prop is used to set the button text of the EmptyState using a translation key.

```tsx
<EmptyState
  heading="EmptyState Heading"
  content="EmptyState Content"
  buttonTx="EmptyState:button"
/>
```

### `buttonTxOptions`

The `buttonTxOptions` prop is used to set the options for the translation key used by the `buttonTx` prop.

```tsx
<EmptyState
  heading="EmptyState Heading"
  content="EmptyState Content"
  buttonTx="EmptyState:button"
  buttonTxOptions={{ count: 2 }}
/>
```

### `buttonStyle`

The `buttonStyle` prop is used to set the style overrides of the button.

```tsx
<EmptyState
  heading="EmptyState Heading"
  content="EmptyState Content"
  button="EmptyState Button"
  buttonStyle={{ backgroundColor: "red" }}
/>
```

### `buttonTextStyle`

The `buttonTextStyle` prop is used to set the style of the button text.

```tsx
<EmptyState
  heading="EmptyState Heading"
  content="EmptyState Content"
  button="EmptyState Button"
  buttonTextStyle={{ color: "red" }}
/>
```

### `ButtonProps`

The `ButtonProps` prop is used to pass any additional props to the `Button` component. It will accept any prop that the [`Button`](./Button.md) component accepts.

```tsx
<EmptyState
  heading="EmptyState Heading"
  content="EmptyState Content"
  ButtonProps={{ preset: "reversed" }}
/>
```

================
File: docs/boilerplate/app/components/Header.md
================
---
sidebar_position: 34
---

# Header

The `Header` component is a component that will appear at the top of your screen. It is used to hold navigation buttons and the screen title.

![header-component](https://github.com/user-attachments/assets/ab308ec1-21e8-41dc-a7f3-bbc6cac866e0)

```tsx
<Header
  titleTx="header:title"
  title="Header Title"
  leftIcon="back"
  rightIcon="bullet"
  onLeftPress={() => navigation.goBack()}
  onRightPress={() => Alert.alert("pressed")}
  style={{ height: 60 }}
  backgroundColor="purple"
  titleStyle={{ color: "white" }}
/>
```

## Props

### `titleMode`

The layout of the title relative to the action components.

`center` will force the title to always be centered relative to the header. If the title or the action buttons are too long, the title will be cut off.
`flex` will attempt to center the title relative to the action buttons. If the action buttons are different widths, the title will be off-center relative to the header.

### `titleStyle`

The `titleStyle` prop is an optional prop that is used to set the style of the header title. This is a [`StyleProp<TextStyle>`](https://reactnative.dev/docs/text-style-props) object.

```tsx
<Header title="Header Title" titleStyle={{ color: "white" }} />
```

### `titleContainerStyle`

The `titleContainerStyle` prop is an optional prop that is used to set the style of the header title's outer container. This is a [`StyleProp<ViewStyle>`](https://reactnative.dev/docs/view-style-props) object.

```tsx
<Header title="Header Title" titleContainerStyle={{ backgroundColor: "purple" }} />
```

### `containerStyle`

The `containerStyle` prop is an optional prop that is used to set the style of the header's outer container. This is useful specifically on notched devices to override insets. This is a [`StyleProp<ViewStyle>`](https://reactnative.dev/docs/view-style-props) object.

```tsx
<Header title="Header Title" containerStyle={{ backgroundColor: "purple" }} />
```

### `style`

The `style` prop is an optional prop that is used to set the style of the header's inner container. You can use this to override the header's height. This is a [`StyleProp<ViewStyle>`](https://reactnative.dev/docs/view-style-props) object.

```tsx
<Header title="Header Title" style={{ height: 50 }} />
```

### `backgroundColor`

The `backgroundColor` prop is an optional prop that is used to set the background color of the header's outer container.

```tsx
<Header title="Header Title" onLeftPress={() => navigation.goBack()} backgroundColor="purple" />
```

### `title`

The `title` is an optional prop that is used to set the header title. If this is not set, the `titleTx` prop must be present to set the title. If both are set, the `title` value will be used.

```tsx
<Header title="Header Title" leftIcon="back" onLeftPress={() => navigation.goBack()} />
```

### `titleTx`

The `titleTx` is an optional prop that is used to lookup the translation for the header title. If this is not set, the `title` prop must be present to set the header title. If both are set, the `title` value will be used.

```tsx
<Header titleTx="header:title" leftIcon="back" onLeftPress={() => navigation.goBack()} />
```

### `titleTxOptions`

The `titleTxOptions` is an optional prop that is used to pass props to the translation lookup for the header title. This is useful if you need to pass in dynamic values to the translation.

```tsx
<Header
  titleTx="header:title"
  titleTxOptions={{ name: "John" }}
  leftIcon="back"
  onLeftPress={() => navigation.goBack()}
/>
```

### `leftIcon`

The `leftIcon` is an optional prop that is used to set the icon for the left navigation button. Options are 'back', 'bullet', and 'bug'. Custom icons can be created by using the [`Icon` component](./Icon.md#custom-icons). Once you create a custom icon, just pass the string name of the icon to the `leftIcon` prop.

```tsx
<Header titleTx="header:title" leftIcon="back" onLeftPress={() => navigation.goBack()} />
```

### `leftIconColor`

The `leftIconColor` is an optional prop that is used to set the tint color of the left navigation icon.

```tsx
<Header
  titleTx="header:title"
  leftIcon="back"
  leftIconColor="white"
  onLeftPress={() => navigation.goBack()}
/>
```

### `leftText`

The `leftText` is an optional prop that is used to set the text for the left navigation button. Overrides the `leftIcon` prop.

```tsx
<Header titleTx="header:title" leftText="Back" onLeftPress={() => navigation.goBack()} />
```

### `leftTx`

The `leftTx` is an optional prop that is used to lookup the translation for the left navigation button. Overrides the `leftIcon` and `leftText` prop`.

```tsx
<Header titleTx="header:title" leftTx="header:back" onLeftPress={() => navigation.goBack()} />
```

### `leftTxOptions`

The `leftTxOptions` is an optional prop that is used to pass props to the translation lookup for the left navigation button. This is useful if you need to pass in dynamic values to the translation.

```tsx
<Header
  titleTx="header:title"
  leftTx="header:back"
  leftTxOptions={{ name: "John" }}
  onLeftPress={() => navigation.goBack()}
/>
```

### `LeftActionComponent`

The `LeftActionComponent` is an optional `ReactElement` prop that is used to set a custom component for the left navigation button. Overrides the `leftIcon`, `leftText`, `leftTx`, and `onLeftText` props (since the passed component is completely customizable).

```tsx
<Header titleTx="header:title" LeftActionComponent={<Text>Back</Text>} />
```

### `onLeftPress`

The `onLeftPress` is an optional prop that is used to set the function to be called when the left navigation button is pressed.

```tsx
<Header titleTx="header:title" leftIcon="back" onLeftPress={() => navigation.goBack()} />
```

### `rightIcon`

The `rightIcon` is an optional prop that is used to set the icon for the right navigation button. Custom icons can be created by using the [`Icon` component](./Icon.md#custom-icons). Once you create a custom icon, just pass the string name of the icon to the `rightIcon` prop.

```tsx
<Header titleTx="header:title" rightIcon="back" onRightPress={() => navigation.goBack()} />
```

### `rightIconColor`

The `rightIconColor` is an optional prop that is used to set the tint color of the right navigation icon.

```tsx
<Header
  titleTx="header:title"
  rightIcon="back"
  onRightPress={() => navigation.goBack()}
  rightIconColor="white"
/>
```

### `rightText`

The `rightText` is an optional prop that is used to set the text for the right navigation button. Overrides the `rightIcon` prop.

```tsx
<Header titleTx="header:title" rightText="Back" onRightPress={() => navigation.goBack()} />
```

### `rightTx`

The `rightTx` is an optional prop that is used to lookup the translation for the right navigation button. Overrides the `rightIcon` and `rightText` prop`.

```tsx
<Header titleTx="header:title" rightTx="header:back" onRightPress={() => navigation.goBack()} />
```

### `rightTxOptions`

The `rightTxOptions` is an optional prop that is used to pass props to the translation lookup for the right navigation button. This is useful if you need to pass in dynamic values to the translation.

```tsx
<Header
  titleTx="header:title"
  rightTx="header:back"
  rightTxOptions={{ name: "John" }}
  onRightPress={() => navigation.goBack()}
/>
```

### `RightActionComponent`

The `RightActionComponent` is an optional `ReactElement` prop that is used to set a custom component for the right navigation button. Overrides the `rightIcon`, `rightText`, `rightTx`, and `onRightPress` props (since the right action component can customize all that).

```tsx
<Header titleTx="header:title" RightActionComponent={<Text>Back</Text>} />
```

### `onRightPress`

The `onRightPress` is an optional prop that is used to set the function to be called when the right navigation button is pressed.

```tsx
<Header titleTx="header:title" rightIcon="back" onRightPress={() => navigation.goBack()} />
```

### `safeAreaEdges`

The `safeAreaEdges` optional prop can be used to override the default safe area edges. By default, the header will use the `top` safe area edge. If you want to not account for the safe area edges, you can pass in `[]` to the `safeAreaEdges` prop.

```tsx
<Header titleTx="header:title" safeAreaEdges={[]} />
```

## Usage

The Header is a flexible component that can be integrated within your application using a few different methods:

### Method 1 (recommended) - Using `navigation.setOptions()` method in your screen component or `useHeader()` hook.

This method gives you the most control over your Header and co-locates the logic inside of your screen while preserving react-navigation's optimizations by keeping it outside of the screen component's render lifecycle.

```tsx
function AccountScreen(props) {
  const { navigation } = props

  useLayoutEffect(() => {
    navigation.setOptions({
      headerShown: true,
      header: () => <Header title="Hello" />,
    })
  }, [])

  return <Screen />
}
```

A convenience [`useHeader`](../utils/useHeader.tsx.md) hook is provided that abstracts and cleans up some of this logic.

```tsx
function AccountScreen(props) {
  useHeader({
    title: "Hello",
  })

  return <Screen />
}
```

### Method 2 - Directly in the render of you screen component.

The Header can be rendered directly in your screen's body. This gives you the most control over the Header component at the expense of performance as it is now a part of the screen's render lifecycle.

```tsx
function AccountScreen(props) {
  return (
    <View>
      <Header title="Hello" />
    </View>
  )
}
```

If you prefer this method, it might be a good idea to memoize the component to prevent unnecessary re-renders.

### Method 3 - Defining the header in your navigator/screen config.

If your Header shares a lot of the same logic within a navigator, it might be a better solution to set the Header inside the navigator config or navigator's screen config. For any customization between screens, you will still need to set the Header props using `navigation.setOptions()`. Additionally, the Header might need to be updated/refactored to use react-navigation's header properties as it isn't very compatible out-of-the-box.

```tsx
<Stack.Navigator
  screenOptions={{
    header: (props) => <Header title={props.options.headerTitle ?? props.route.name} />,
  }}
/>
```

Or, you can define it on the screen config.

```tsx
<Stack.Navigator screenOptions={{ headerShown: false }}>
  <Stack.Screen
    name="Welcome"
    component={WelcomeScreen}
    options={{ headerShown: true, header: () => <Header title="Hello" /> }}
  />
</Stack.Navigator>
```

================
File: docs/boilerplate/app/components/Icon.md
================
---
sidebar_position: 35
---

# Icon

Ignite's `Icon` Component renders an icon using predefined icon images. You can use those, override them, or customize this component to create any number of image based icons. If `onPress` is passed, it will wrap the icon in a [`TouchableOpacity`](https://reactnative.dev/docs/touchableopacity) component, otherwise it will use a [`View`](https://reactnative.dev/docs/view) component.

![icon-component](https://github.com/user-attachments/assets/25888c72-8bd9-4cbd-b55f-909b0f6b0bca)

```tsx
<Icon icon="ladybug" onPress={() => Alert.alert("Hello")} />
```

## Props

Other than these props, you can pass any props that `TouchableOpacity` or `View` support and they will be forwarded to the respective wrapper component.

### `icon`

The `icon` prop is required. This is the string name of the icon to be rendered. The options are:

- back
- bell
- caretLeft
- caretRight
- check
- community
- components
- debug
- heart
- hidden
- ladybug
- lock
- menu
- more
- pin
- settings
- view
- x

```tsx
<Icon icon="bell" />
```

You can easily change or add [custom icons](#custom-icons) to the `Icon` component.

### `color`

The `color` optional prop is a string that will be used to set the [`tintColor`](https://reactnative.dev/docs/image-style-props#tintcolor) of the icon image.

```tsx
<Icon icon="x" color="#7C7C7C">
```

### `size`

The `size` optional prop is a number that is used to set the dimensions of the icon image.

```tsx
<Icon icon="x" size={24} />
```

### `style`

The `style` prop is optional. This is an object that overrides the default style of the icon, and is of the type `StyleProp<ImageStyle>`. By default this just sets the image's `resizeMode` to `contain`. See React Native docs on [ImageStyle](https://reactnative.dev/docs/image#style) for more information.

```tsx
<Icon icon="ladybug" style={{ width: 20, height: 20 }} />
```

### `containerStyle`

The `containerStyle` is an optional prop that sets the style of the icon container, and is of the type `StyleProp<ViewStyle>`. See React Native docs on [ViewStyle](https://reactnative.dev/docs/view-style-props) for more information.

```tsx
<Icon icon="bug" containerStyle={{ backgroundColor: "red" }} />
```

### `onPress`

The `onPress` optional prop is a function that will be called when the icon is pressed. Note that when this prop is passed, the icon will be wrapped in a `TouchableOpacity` component rather than a `View` component.

```tsx
<Icon icon="ladybug" onPress={() => Alert.alert("Hello")} />
```

## Custom Icons

To create your own custom icon, add your icon image(s) to the `assets/icons/` directory and then add it with its own name to the `iconRegistry` object in `app/components/Icon.tsx`.

```
-- icon/
  -- icons/
    -- index.ts
    -- my-custom-icon.png
```

```tsx
export const iconRegistry = {
  // ...
  custom: require("./myCustomIcon.png"),
}
```

You can then use your custom icon by passing its name through the `icon` prop.

```tsx
<Icon icon="custom" />
```

================
File: docs/boilerplate/app/components/ListItem.md
================
---
sidebar_position: 36
---

# ListItem

The `ListItem` component is a component that is used to display a single item in a list. It provides a lot of flexibility in terms of what you can do with it. It can be used to display a simple piece text, or a complex component with multiple actionable and custom styled elements inside.

![listitem-component](https://github.com/user-attachments/assets/009aed59-5597-4d0b-b861-972608ddb8ea)

```tsx
<ListItem height={50} />
```

## Props

As the `ListItem` component is interactable, it includes a `TouchableOpacity` component, which means that in addition to the custom props listed here, you can pass any props that are valid for a `TouchableOpacity` component.

### `height`

The `height` prop is used to set the height of the `ListItem` component. The default is `56`.

```tsx
<ListItem height={50} />
```

### `topSeparator` and `bottomSeparator`

The `topSeparator` and `bottomSeparator` props are used to display a separator above or below the `ListItem` component. The default is `false`.

```tsx
<ListItem topSeparator={true} bottomSeparator={true} />
```

### `text`

The `text` prop is used to display a simple piece of text inside the `ListItem` component.

```tsx
<ListItem text="Hello World" />
```

### `tx`

The `tx` prop is used to display a simple piece of text inside the `ListItem` component. It is used to display a localized string.

```tsx
<ListItem tx="example:helloWorld" />
```

### `children`

The `children` prop is used to display components inside the `ListItem` component. Note that these will be nested inside a [`Text`](./Text.md) component.

```tsx
<ListItem height={100}>
  <Text>Subtext</Text>
</ListItem>
```

### `txOptions`

The `txOptions` prop is used to pass options to the `tx` prop. It is used to display a localized string.

```tsx
<ListItem tx="example:helloWorld" txOptions={{ name: "John" }} />
```

### `textStyle`

The `textStyle` prop is used to pass a style to the `Text` component that is used to display the text inside the `ListItem` component.

```tsx
<ListItem text="Hello World" textStyle={{ color: "red" }} />
```

### `TextProps`

The `TextProps` prop is used to pass any additional props directly to the [`Text`](./Text.md) component.

```tsx
<ListItem text="Hello World" TextProps={{ weight: "bold" }} />
```

### `containerStyle`

The `containerStyle` prop is used to pass a style to the `View` component that is used to display the `ListItem` component.

```tsx
<ListItem text="Hello World" containerStyle={{ backgroundColor: "red" }} />
```

### `style`

The `style` prop is used to pass a style to the `TouchableOpacity` component that is used to display the `ListItem` component.

```tsx
<ListItem text="Hello World" style={{ backgroundColor: "red" }} />
```

### `leftIcon` and `rightIcon`

The `leftIcon` and `rightIcon` props are used to display an icon on the left or right side of the `ListItem` component, respectively.

```tsx
<ListItem text="Hello World" leftIcon="bell" rightIcon="bell" />
```

### `leftIconColor` and `rightIconColor`

The `leftIconColor` and `rightIconColor` props are used to set the color of the icon on the left or right side of the `ListItem` component, respectively.

```tsx
<ListItem
  text="Hello World"
  leftIcon="bell"
  leftIconColor="red"
  rightIcon="bell"
  rightIconColor="red"
/>
```

### `RightComponent` and `LeftComponent`

The `RightComponent` and `LeftComponent` props are `ReactElement` objects used to display a component on the left or right side of the `ListItem` component, respectively.

```tsx
<ListItem
  text="Hello World"
  LeftComponent={<Text>Left</Text>}
  RightComponent={<Text>Right</Text>}
/>
```

================
File: docs/boilerplate/app/components/ListView.md
================
---
sidebar_position: 37
---

# ListView

The `ListView` component is a Higher Order Component that uses [Shopify's FlashList](https://shopify.github.io/flash-list/) component to display a list unless the user's preferred language is RTL (right-to-left). This is because FlashList has [known](https://github.com/Shopify/flash-list/issues/544) [issues](https://github.com/Shopify/flash-list/issues/840) with RTL support. Once these issues with FlashList are resolved, this component will be deprecated and FlashList will be used directly.

## Props

The `ListView` component uses props from `FlashList` because they are a superset of `FlatList` and only require one extra prop to work for both component types.

> [Please see the FlashList documentation for more information on the props that are available.](https://shopify.github.io/flash-list/docs/usage)

### `estimatedItemSize`

> [Please see the FlashList documentation for more information on this prop.](https://shopify.github.io/flash-list/docs/estimated-item-size)

================
File: docs/boilerplate/app/components/Radio.md
================
---
sidebar_position: 37
---

import ToggleProps from './\_toggle_props.mdx';

# Radio

The `Radio` component provides a simple way to collect user input for a boolean value.

<ToggleProps componentName="Radio" />

================
File: docs/boilerplate/app/components/Screen.md
================
---
sidebar_position: 38
---

# Screen

This is a component that renders a screen. It is used to wrap your entire screen, and handles scrolling, [safe areas insets](https://reactnavigation.org/docs/handling-safe-area/), and keyboard avoiding behavior.

```tsx
<Screen preset="scroll">{/* ... content here ... */}</Screen>
```

## Props

### `children`

As the `Screen` component is a top level wrapper component, it is expected that you will pass in your screen's content as children.

```tsx
<Screen preset="scroll">{/* ... content here ... */}</Screen>
```

### `style`

The `style` prop is an optional `StyleProp<ViewStyle>` object that applies to the outer content `View` component. This is useful for applying styles such as `margin` and `padding`.

```tsx
<Screen style={{ padding: 10 }}>{/* ... content here ... */}</Screen>
```

### `contentContainerStyle`

The `contentContainerStyle` prop is an optional `StyleProp<ViewStyle>` object that applies to the inner content `View` component that wraps the `children`. This is useful for applying styles to the innermost component, such as `margin` and `padding`.

```tsx
<Screen contentContainerStyle={{ margin: 10 }}>{/* ... content here ... */}</Screen>
```

### `safeAreaEdges`

The `safeAreaEdges` prop is an an array of `SafeAreaEdges` that determines which edges of the screen should be considered safe areas. This is useful for handling the notch on iPhone X and other devices. Usage of this prop depends on how the Screen is used. If you have a Header above the screen, the "top" Edge can be omitted. If you have a TabBar, the "bottom" edge can be omitted. In other cases, a value of `["top", "bottom"]` is recommended. The default value is `undefined`.

```tsx
<Screen safeAreaEdges={["top", "bottom"]}>{/* ... content here ... */}</Screen>
```

### `backgroundColor`

The `backgroundColor` prop is an optional `string` that determines the background color of the outer wrapper component. The default value is `colors.background`.

```tsx
<Screen backgroundColor="red">{/* ... content here ... */}</Screen>
```

### `statusBarStyle`

The `statusBarStyle` prop is a prop that determines the style of the status bar. It can be either `"light"` or `"dark"`. The default value is `"dark"`.

```tsx
<Screen statusBarStyle="light">{/* ... content here ... */}</Screen>
```

### `keyboardOffset`

The `keyboardOffset` prop is an optional `number` that determines the offset of the keyboard when it is shown. It is passed to the `keyboardVerticalOffset` of the `KeyboardAvoidingView`. The default value is `0`.

```tsx
<Screen keyboardOffset={10}>{/* ... content here ... */}</Screen>
```

### `StatusBarProps`

The `StatusBarProps` prop is an object that is passed as props to the `expo-status-bar` [`StatusBar`](https://docs.expo.io/versions/latest/sdk/status-bar/) component.

```tsx
<Screen StatusBarProps={{ animated: false }}>{/* ... content here ... */}</Screen>
```

### `KeyboardAvoidingViewProps`

The `KeyboardAvoidingViewProps` prop is an object that is passed as props to the [`KeyboardAvoidingView`](https://reactnative.dev/docs/keyboardavoidingview).

```tsx
<Screen KeyboardAvoidingViewProps={{ behavior: "padding" }}>{/* ... content here ... */}</Screen>
```

### `preset`

The `preset` prop is an optional enum that applies to the outer `KeyboardAvoidingView` component. The predefined presets with ignite deal with different use cases for scroll behavior and keyboard avoiding behavior. It defaults to `scroll` behavior if not set.

The predefined presets are:

- `scroll` - A preset that applies a scroll behavior to the screen. This is useful for forms or other screens which require a keyboard.
- `fixed` - A preset that applies a fixed behavior to the screen. i.e. The screen will not scroll. This is useful if you have a component such as a `FlashList` that has its own scrolling behavior.
- `auto` - A preset that applies an automatic behavior to the screen. i.e. The screen will scroll if the content is larger than the screen, but not otherwise.

```tsx
<Screen preset="scroll">{/* ... content here ... */}</Screen>
```

### `keyboardShouldPersistTaps`

The `keyboardShouldPersistTaps` optional prop is a enum that determines if the keyboard should persist taps. It defaults to `"handled"`. This only applies for the `scroll` preset, because it is passed into the React Native [`ScrollView`](https://facebook.github.io/react-native/docs/scrollview.html) component under its `keyboardShouldPersistTaps` prop.

The valid values for this prop are: `"handled"`, `"always"`,and `"never"`.

```tsx
<Screen preset="scroll" keyboardShouldPersistTaps="never">
  {/* ... content here ... */}
</Screen>
```

### `ScrollViewProps`

The `ScrollViewProps` prop is an object that is passed as props to the React Native [`ScrollView`](https://facebook.github.io/react-native/docs/scrollview.html) component. This only applies for the `scroll` preset.

```tsx
<Screen preset="scroll" ScrollViewProps={{ contentContainerStyle: { padding: 10 } }}>
  {/* ... content here ... */}
</Screen>
```

### `scrollEnabledToggleThreshold`

The `scrollEnabledToggleThreshold` prop is an optional `number` that determines the threshold at which the `scrollEnabled` prop of the `ScrollView` is toggled. This only applies for the `auto` preset. The default value is `{ percent: 0.92 }`. You can pass a point value in lieu of a percentage, e.g. `{ point: 100 }` will enable scrolling when the scroll view height is less than 100 points larger than the scroll view content height.

```tsx
<Screen preset="scroll" scrollEnabledToggleThreshold={{ percent: 0.95 }}>
  {/* ... content here ... */}
</Screen>
```

================
File: docs/boilerplate/app/components/Switch.md
================
---
sidebar_position: 38
---

import ToggleProps from './\_toggle_props.mdx';

# Switch

The `Switch` component provides a simple way to collect user input for a boolean value.

## Switch Props

### `accessibilityMode`

The `accessibilityMode` is a special prop for the switch variant that adds a text/icon label for on/off states. Options are `text` and `icon`

```tsx
<Switch value={value} onValueChange={setValue} accessibilityMode="icon" />
```

<ToggleProps componentName="Switch" />

================
File: docs/boilerplate/app/components/Text.md
================
---
sidebar_position: 39
---

# Text

Ignite's `Text` Component is an enhanced version of the built-in React Native [`Text`](https://reactnative.dev/docs/text) component. It adds internationalization and several useful (and customizable) property presets. You shouldn't need the built-in React Native Text component if you use this. It does everything the built-in one does and more.

By enhancing the Ignite Text component and using it across your app, you can make sure the right fonts, font weight, and other styles and behaviors are shared across your whole app.

![text-component](https://github.com/user-attachments/assets/61277e64-c530-4043-93fe-5da41c9e9351)

## Props

### `text`

The `text` optional prop is the text of the component. We encourage you to not use this but rather use the `tx` prop instead.

```tsx
<Text text="My Text" />
```

### `tx`

The `tx` optional prop is the string key used to look up the translated text for the user's locale. Ignite uses [`i18next`](https://www.i18next.com/) for internationalization.

````tsx

```tsx
<Text tx="welcomeScreen:readyForLaunch" />
````

### `txOptions`

The `txOptions` optional prop is an object of options to pass to i18n. Useful for [interpolation](https://www.i18next.com/) as well as explicitly setting locale or translation fallbacks. You'll be defining these in the `app/i18n/*.json` files, and can use `{{variableName}}` for interpolation.

```tsx
// in en.json
profile: {
  details: "{{name}} who is {{age}} years old"
}
```

```tsx
// in your component
<Text
  tx="profile:details"
  txOptions={{
    name: "Jamon",
    age: 40,
  }}
/>
```

### `style`

The `style` optional prop is an object with overrides for this particular component. You can use `style` overrides with presets.

```tsx
<Text tx="welcome:title" style={{ fontSize: 40 }} />
```

### `weight`

The `weight` optional prop is the font weight to use for the text. It utilizes the fonts defined in the `app/theme/typography.tsx` file.

```tsx
<Text tx="welcome:title" weight="medium" />
```

### `size`

The `size` optional prop is the font size to use for the text. The options are defined as `$sizeStyles` in `app/components/Text.tsx`. You can add sizes as you need to the `$sizeStyles` object and use them in your `Text` component.

```tsx
<Text tx="welcome:title" size="lg" />
```

### `preset`

The `preset` optional prop specifies the string of the preset style you want to use. You can use style overrides with presets.

```tsx
<Text preset="bold" text="This is bold" />
```

## Presets

Presets allow you to have a consistent look and feel across your app without having to redefine the styles all the time.

```tsx
<View preset="heading" text="My Header" />
```

You'll want to customize these presets and add more. You can do this in the `text.presets.ts` file.

If you find yourself overriding styles with the `style` prop a lot, you probably need a new preset for that use case.

### Available Presets

`default`: The default text styles.

`bold`: A bold version of the default text.

`heading`: Large headers.

`subheading`: A smaller piece of secondary information.

`formLabel`: Form input label.

`formHelper`: Form assistive information.

### Custom Presets

Feel free to add your own presets by emulating the style you see with the provided presets. In a typical Infinite Red project, we will have a dozen or more presets that we use across the project. Simply add a new key to the `$presets` object in `app/components/Text.tsx` and then pass the name of the preset to the `preset` prop.

```tsx
$presets = {
  label: [$baseStyle, $sizeStyles.md, $fontWeightStyles.medium],
}
```

```tsx
<Text preset="label" text="Email" />
```

================
File: docs/boilerplate/app/components/TextField.md
================
---
sidebar_position: 40
---

# TextField

Ignite's `TextField` Component is an enhanced version of the built-in React Native [`TextInput`](https://reactnative.dev/docs/textinput) component. It consists of TextInput and a Text(./Text.md) label.

With this component you will be able to standardize TextInput component across your app.

![textfield-component](https://github.com/user-attachments/assets/cfdc97dc-5692-4286-8682-9243ee0e7650)

```tsx
import { TextField } from '../components';

const [input, setInput] = useState("")
<TextField
  value={input}
  onChangeText={(value) => setInput(value)}
  status="error"
  label="Name"
  labelTx="login.nameLabel"
  labelTxOptions={{ name: "John" }}
  LabelTextProps={{ style: { color: "#FFFFFF" } }}
  placeholder="John Doe"
  placeholderTx="login.namePlaceholder"
  placeholderTxOptions={{ name: "John" }}
  helper="Enter your name"
  helperTx="login.nameHelper"
  helperTxOptions={{ name: "John" }}
  HelperTextProps={{ style: { color: "#FFFFFF" } }}
  style={{ backgroundColor: "#BFBFBF" }}
  containerStyle={{ backgroundColor: "#BFBFBF" }}
  inputWrapperStyle={{ backgroundColor: "#BFBFBF" }}
  RightAccessory={() => <Icon icon="check" />}
  LeftAccessory={() => <Icon icon="bell" />}
/>

```

## Props

The `TextField` component accepts all the props of the built-in React Native [`TextInput`](https://reactnative.dev/docs/textinput) component which will be forwarded to the `TextInput` component, as well as the following props:

### `status`

The `status` prop is used to set an `'error'` or `'disabled'` state on the component. The default value is `null`. You can use it to show an error style for validations or to disable the component. By default the `'error'` status will set the `borderColor` on the input wrapper to whatever `colors.error` is set to. Setting the status to `'disabled'` will disable editing on the `TextInput` component.

```tsx
<TextField value={input} onChangeText={(value) => setInput(value)} status="error" />
```

### `label`

The `label` optional prop is a string that is used to set the label. If this is not set, the `labelTx` prop must be present to set the label. If both are set, the `label` value will be used.

```tsx
<TextField value={input} onChangeText={(value) => setInput(value)} label="Name" />
```

### `labelTx`

The `labelTx` optional prop is the string key used to look up the translated text for the user's locale. Ignite uses [`i18next`](https://www.i18next.com/) for internationalization. If this is not set, the `label` prop must be present to set the label. If both are set, the `label` value will be used.

```tsx
<TextField value={input} onChangeText={(value) => setInput(value)} labelTx="signup.name" />
```

### `labelTxOptions`

The `labelTxOptions` is an optional prop that is used to pass props to the translation lookup for the header title. This is useful if you need to pass in dynamic values to the translation.

```tsx
<TextField
  value={input}
  labelTx="signup.name"
  labelTxOptions={{ name: "John" }}
  onChangeText={(value) => setInput(value)}
/>
```

### `LabelTextProps`

The `LabelTextProps` is an optional prop that is used to pass props to the [`Text`](./Text.md) component that renders the label.

```tsx
<TextField
  value={input}
  labelTx="signup.name"
  onChangeText={(value) => setInput(value)}
  LabelTextProps={{ style: { color: "red" } }}
/>
```

### `helper`

The `helper` optional prop is a string that is used to set the helper text. If this is not set, the `helperTx` prop must be present to set the helper text. If both are set, the `helper` value will be used. The helper text is rendered with a [`Text`](./Text.md) component.

```tsx
<TextField value={input} onChangeText={(value) => setInput(value)} helper="This is a helper text" />
```

### `helperTx`

The `helperTx` optional prop is the string key used to look up the translated text for the user's locale. Ignite uses [`i18next`](https://www.i18next.com/) for internationalization. If this is not set, the `helper` prop must be present to set the helper text. If both are set, the `helper` value will be used.

```tsx
<TextField value={input} onChangeText={(value) => setInput(value)} helperTx="signup.name" />
```

### `helperTxOptions`

The `helperTxOptions` is an optional prop that is used to pass props to the translation lookup for the helper text. This is useful if you need to pass in dynamic values to the translation.

```tsx
<TextField
  value={input}
  helperTx="login.name"
  helperTxOptions={{ name: "John" }}
  onChangeText={(value) => setInput(value)}
/>
```

### `HelperTextProps`

The `HelperTextProps` is an optional prop that is used to pass props to the [`Text`](./Text.md) component that renders the helper text.

```tsx
<TextField
  value={input}
  helper="Name"
  onChangeText={(value) => setInput(value)}
  HelperTextProps={{ style: { color: "red" } }}
/>
```

### `placeholder`

The `placeholder` optional prop is a string that is used to set the placeholder. If this is not set, the `placeholderTx` prop must be present to set the placeholder. If both are set, the `placeholder` value will be used.

```tsx
<TextField value={input} onChangeText={(value) => setInput(value)} placeholder="Name" />
```

### `placeholderTx`

The `placeholderTx` optional prop is the string key used to look up the translated text for the user's locale. Ignite uses [`i18next`](https://www.i18next.com/) for internationalization. If this is not set, the `placeholder` prop must be present to set the placeholder. If both are set, the `placeholder` value will be used.

```tsx
<TextField value={input} onChangeText={(value) => setInput(value)} placeholderTx="signup.name" />
```

### `placeholderTxOptions`

The `placeholderTxOptions` is an optional prop that is used to pass props to the translation lookup for the placeholder text. This is useful if you need to pass in dynamic values to the translation.

```tsx
<TextField value={input} onChangeText={(value) => setInput(value)} />
```

### `style`

The `style` optional prop is an object used to override the input style.

```tsx
<TextField
  value={input}
  onChangeText={(value) => setInput(value)}
  style={{ backgroundColor: "red" }}
/>
```

### `containerStyle`

The `containerStyle` optional prop is an object used to override the container style.

```tsx
<TextField
  value={input}
  onChangeText={(value) => setInput(value)}
  containerStyle={{ backgroundColor: "red" }}
/>
```

### `inputWrapperStyle`

The `inputWrapperStyle` optional prop is an object used to override the input wrapper style.

```tsx
<TextField
  value={input}
  onChangeText={(value) => setInput(value)}
  inputWrapperStyle={{ backgroundColor: "red" }}
/>
```

### `RightAccessory` and `LeftAccessory`

The `RightAccessory` and `LeftAccessory` optional props are components that are rendered on the right and left sides of the input, respectively. This is useful for rendering icons or buttons. The [`status`](#status), `multiline` from the `TextInputProps`, `editable` (negation of `disabled` status), and a default `style` attribute are passed into it via props for custom usage.

```tsx
<TextField
  value={input}
  onChangeText={(value) => setInput(value)}
  RightAccessory={(props) => (
    // props has `multiline`, `status`, `disabled`, and `style` attributes
    {disabled, status} = props

    if (!!disabled) return <Icon icon="lock" color="gray" />
    if (status === 'error') return <Icon icon="x" color="red" />

    return <Icon icon="check" color="green" />
  )}
/>
```

It's also recommended to use `useMemo` on accessories to prevent flickering, as without `useMemo` they will rerender whenever the input value changes.

```tsx
const PasswordRightAccessory = useMemo(
  () =>
    function PasswordRightAccessory(props: TextFieldAccessoryProps) {
      return (
        <Icon
          icon={isAuthPasswordHidden ? "view" : "hidden"}
          color={colors.palette.neutral800}
          containerStyle={props.style}
          onPress={() => setIsAuthPasswordHidden(!isAuthPasswordHidden)}
        />
      )
    },
  [isAuthPasswordHidden],
)
```

This could then be passed to the `TextField` component directly.

```tsx
<TextField
  value={password}
  onChangeText={(value) => setPassword(password)}
  RightAccessory={PasswordRightAccessory}
/>
```

================
File: docs/boilerplate/app/config/Config.md
================
# Config folder

This file imports configuration objects from either the config.dev.js file or the config.prod.js file depending on whether we are in `__DEV__` mode or not.

Note that we do not gitignore these files. Unlike on web servers, just because these are not checked into your repo doesn't mean that they are secure. In fact, you're shipping a JavaScript bundle with every config variable in plain text. Anyone who downloads your app can easily extract them.

If you doubt this, just bundle your app, and then go look at the bundle and search it for one of your config variable values. You'll find it there.

Read more here: https://reactnative.dev/docs/security#storing-sensitive-info

## config.base.js

This file contains configuration variables that are shared between development and production. For example, we set a `exitRoutes` setting to tell the app which routes should be considered "exit routes" (i.e. routes that the user can exit the app from).

## config.dev.js

This file contains configuration variables that are specific to development. For example, you might want to use a different API URL for development than you do for production.

## config.prod.js

This file contains configuration variables that are specific to production.

================
File: docs/boilerplate/app/devtools/Devtools.md
================
# Devtools Folder

## Reactotron

Ignite comes with Reactotron support for debugging your app.
By default, Reactotron is configured to work with web and mobile apps and is configured with a few plugins and commands we think are useful.

### ReactotronConfig.ts

The `reactotron-mst` plugin is included for MobX-State-Tree support.

```typescript
import { mst } from "reactotron-mst"
const reactotron = Reactotron.configure({
    ...
}).use(
  mst({
    /** ignore some chatty `mobx-state-tree` actions  */
    filter: (event) => /postProcessSnapshot|@APPLY_SNAPSHOT/.test(event.name) === false,
  }),
)
```

There are also a few custom commands included. You can use `reactotron.onCustomCommand` to add your own own custom debugging tools to Reactotron. Here is an example:

```typescript
reactotron.onCustomCommand({
  title: "Reset Navigation State",
  description: "Resets the navigation state",
  command: "resetNavigation",
  handler: () => {
    Reactotron.log("resetting navigation state")
    resetRoot({ index: 0, routes: [] })
  },
})
```

For more info check out the [Reactotron Documentation](https://docs.infinite.red/reactotron/)

================
File: docs/boilerplate/app/i18n/Internationalization.md
================
---
sidebar_position: 160
---

# Internationalization in Ignite Apps

Ignite is currently set up to support Internationalization in English, Arabic, Korean, French, Japanese and Hindi. This is detected on app load and will set your app to that language.

## Right to Left languages (RTL)

Since Ignite already comes with an RTL language, Arabic, adding any new ones would work by default.

### Removing RTL Support

To remove RTL support, follow the following steps:

1. In `/app/i18n/i18n.ts`

- Remove your RTL language imports
- Remove references to those language objects
- Remove lines where we allow and force RTL on the native layer

```ts
I18nManager.allowRTL(isRTL)
I18nManager.forceRTL(isRTL)
```

2. Remove all other associated logic that uses the exported `isRTL` variable
3. Remove any `tx="some:i18n.key"` from your components and use `text="Some Text"` instead
   (e.g. `<Text text="Some Text" />`

## Adding more languages

See the [i18next Documentation](https://www.i18next.com/how-to/add-or-load-translations) to add languages to `app/i18n/i18n.ts`.

================
File: docs/boilerplate/app/models/Models.md
================
# Models folder

Ignite's perhaps most distinctive feature is its use of [MobX-State-Tree](https://mobx-state-tree.js.org/) (MST). This is a powerful and full-featured state management library that allows you to create strongly-typed observable models that can be used throughout your app and rerender on update intelligently without using selectors.

We have [very good reasons](../../../concept/MobX-State-Tree.md) for using MST, but if after reading that doc you're still not keen on using it, we also have an [Ignite Cookbook recipe](https://ignitecookbook.com/docs/recipes/Redux) for removing MST and using Redux or Zustand instead.

## RootStore

The root of your MST tree is a single store (although you can create more if you want!). This usually contains high-level data that is used throughout your app, such as the user's authentication status, their locale, and more. It often contains other stores, such as AuthenticationStore, UserStore, ArticleStore, OrderStore, and so on.

```typescript
import { AuthenticationStoreModel } from "./AuthenticationStore"
import { EpisodeStoreModel } from "./EpisodeStore"

export const RootStoreModel = types.model("RootStore", {
  authenticationStore: types.optional(AuthenticationStoreModel, {}),
  episodeStore: types.optional(EpisodeStoreModel, {}),
})
```

Each "store" is then made up of "models" (see below). (Note: In MST, "stores" and "models" are often used interchangeably, but we generally think of stores as being containers of multiple different models.)

## Models

You can [generate](../../../concept/Generators.md) models using the `npx ignite-cli generate model` command. This will create a new file in the `app/models` folder. You can also create models manually if you prefer.

```typescript
import { types } from "mobx-state-tree"

/**
 * This represents an episode of React Native Radio.
 */
export const EpisodeModel = types.model("Episode", {
  guid: types.identifier,
  title: "",
  link: "",
  author: "",
  thumbnail: "",
  description: "",
  content: "",
  categories: types.array(types.string),
})
```

You will be able to create instances and use them in observed components like this:

```typescript
import { useStores } from "../models/root-store"
import { observer } from "mobx-react-lite"

export const EpisodeScreen = observer(() => {
  const { episodeStore } = useStores()

  // automatically re-renders when the episode title changes
  // or if you change the current episode to a different one
  return <Text>{episodeStore.currentEpisode.title}</Text>
})
```

Explore the existing models in your models folder (if you left demo code in) to see how they work. You can also read the [MST docs](https://mobx-state-tree.js.org/) for more information.

And of course, you can always ask questions in the [Infinite Red Community Slack](http://community.infinite.red) or the [MobX-State-Tree GitHub Discussions group](https://github.com/mobxjs/mobx-state-tree/discussions).

================
File: docs/boilerplate/app/navigators/AppNavigator.tsx.md
================
# AppNavigator.tsx

If you open the file `app/navigators/AppNavigator.tsx` up, you'll find the AppNavigator and the AppStack.

The AppNavigator is the root navigator for your whole app. It will have the navigation container and wrap the AppStack.

The AppStack is a native stack navigator (via [React Navigation](https://reactnavigation.org/docs/hello-react-navigation#creating-a-native-stack-navigator)) and contains all the screens and subnavigators of your app.

In the case of Ignite's demo code, it is prepared with an example flow for an app requiring authentication. The screens included within the AppStack are dependent on value of `isAuthenticated` from `authenticationStore`. If in an unauthenticated state, the only screen to be shown will be the `LoginScreen`. Otherwise, that screen is left out of the navigator and the user is presented with the `WelcomeScreen` and screens that fall under the `DemoNavigator`

================
File: docs/boilerplate/app/navigators/Navigation.md
================
---
sidebar_position: 90
---

# Navigation in Ignite

We use [React Navigation v6](https://reactnavigation.org/docs/getting-started/) in the current version of Ignite. You'll find any navigators in `./app/navigators`, with the `AppNavigator.tsx` being the primary one.

There's also a `navigationUtilities.tsx` file which provides some utility functions we find useful in building apps, such as `getActiveRouteName`, `useBackButtonHandler` and `useNavigationPersistence`.

There's a provided Ignite CLI generator for creating new navigators. Learn more in the [Generator docs](../../../concept/Generators.md#navigator-generator).

## General Structure

```tsx
<AppNavigator initialState={initialNavigationState} onStateChange={onNavigationStateChange} />
```

See the [AppNavigator.tsx](./AppNavigator.tsx.md) docs for more info on how the app navigator is set up.

## Useful Patterns

We've found that there are some useful patterns for building navigators in React Native.

### Authentication Flow

We recommend following the guidance of [React Navigation's Authentication Flows](https://reactnavigation.org/docs/auth-flow/) and Ignite comes bootstrapped with this pattern in its demo code.

```tsx
const AppStack = observer(function AppStack() {
  const {
    authenticationStore: { isAuthenticated },
  } = useStores()

  return (
    <Stack.Navigator
      screenOptions={{ headerShown: false }}
      initialRouteName={isAuthenticated ? "Welcome" : "Login"}
    >
      {isAuthenticated ? (
        <>
          <Stack.Screen name="Welcome" component={WelcomeScreen} />
          <Stack.Screen name="Demo" component={DemoNavigator} />
        </>
      ) : (
        <>
          <Stack.Screen name="Login" component={LoginScreen} />
        </>
      )}
    </Stack.Navigator>
  )
})
```

The screens included within the AppStack are dependent on value of `isAuthenticated` from `authenticationStore`. If the user hasn't been authenticated yet, the only screen to be shown will be the `LoginScreen`.

When authenticated, `LoginScreen` is left out of the navigator and the user is presented with the `WelcomeScreen` and screens that fall under the `DemoNavigator`

### Tab Navigation

We recommend using the [React Navigation Tabs](https://reactnavigation.org/docs/tab-based-navigation/) for tabs.

Inside `./app/navigators/DemoNavigator.tsx` you'll see the definition of the bottom tab navigator. Here is where you can customize the style and behavior of the tab bar itself, as well as each individual tab.

In addition to the user pressing the tab buttons, you may also navigate from tab to tab programmatically via the same familiar navigation API:

```tsx
// currently on the DemoShowroom tab, navigate to the DemoDebug tab
navigation.navigate("DemoDebug")
```

Tabs can jump to a single screen (as seen in Ignite's demo code) or another stack navigator comprised of many screens the user could navigate through within the same tab. Let's use a message inbox as an example:

```tsx
const InboxStack = createNativeStackNavigator()

function InboxStackScreen() {
  return (
    <InboxStack.Navigator>
      <InboxStack.Screen name="List" component={ListScreen} />
      <InboxStack.Screen name="MessageDetails" component={MessageDetailsScreen} />
    </InboxStack.Navigator>
  )
}
```

A tab could be added to the tab navigator as a child component.

`<Tab.Screen name="Inbox" component={InboxStackScreen} />`

This would initially display the `ListScreen` with all of the messages and if the user happened to press a list item, the app would then navigate to a `MessageDetailsScreen`.

### Sidebar Navigation

Ignite comes with an example sidebar navigation, aka "drawer" navigator. It is implemented using the `DrawerLayout` from [React Native Gesture Handler](https://docs.swmansion.com/react-native-gesture-handler/docs/api/components/drawer-layout/), a cross-platform replacement for [React Native's DrawerLayoutAndroid](https://reactnative.dev/docs/drawerlayoutandroid.html).

The view passed via `renderNavigationView` prop is the content rendered to the side of the screen, which can be pulled in or opened by the toggle button press. Here is where you can render header information (perhaps a company logo or logged in user avatar along with labels), menu items, logout or settings functionality and more.

`DrawerLayout` also allows you to customize the behavior (open/close speed, overlay position), style and even has events to track the progress and states of the drawer transitioning. See more info at the [documentation](https://docs.swmansion.com/react-native-gesture-handler/docs/api/components/drawer-layout/).

Ignite's navigation setup also comes with some very useful [navigation utilities](./navigationUtilities.ts.md) to help you with common tasks such as getting the current route name, handling the back button, and persisting navigation state.

## A note about Expo Router

We are currently evaluating [Expo Router](https://docs.expo.dev/router/introduction/) to power Ignite's navigation system. It's a very promising project (built on React Navigation), but our philosophy is that nothing makes it into Ignite unless we've proven it in a full project (or two...or three...) first. In the meantime we've added an experimental option to switch to Expo Router when igniting your project. We'll update this section when we have more information.

================
File: docs/boilerplate/app/navigators/navigationUtilities.ts.md
================
## `navigationUtilities.ts`

### `getActiveRouteName`

This helper allows you to fetch the active route name from your navigator. It will recursively dive into nested routers. It takes the current navigation state (via `navigation.getState()`) and returns a string.

Example:

```tsx
// nested navigators, 2-deep
const NestedStack = () => {
  return (
    <Stack.Navigator>
      <Stack.Screen name="myScreen" component={MyScreen} />
    </Stack.Navigator>
  )
}

const AppStack = () => {
  return (
    <Stack.Navigator>
      <Stack.Screen name="nestedNav" component={NestedStack} />
    </Stack.Navigator>
  )
}

// getActiveRouteName usage
function MyScreen({ navigation }) {
  const routeName = getActiveRouteName(navigation.getState())
  // => "myScreen"
}
```

### `useBackButtonHandler`

This helper custom hook allows you to easily specify what routes you want to exit the app from, when the "back" button is pressed on Android. It has no effect on iOS.

We recommend using this in your root AppNavigator.

Example:

```tsx
export const AppNavigator = (props) => {
  // What route names do we allow the back button to exit the app from?
  const exitRoutes = ["welcome"]
  useBackButtonHandler((routeName) => exitRoutes.includes(routeName))

  // ...
}
```

### `useNavigationPersistence`

This helper custom hook persists app navigation state between app loads. This is only enabled in dev by default, but can be enabled in production as well by editing the hook in `navigationUtilities.tsx`.

```tsx
import * as storage from "./utils/storage"

function App(props: AppProps) {
  const persistence = useNavigationPersistence(storage, "my-persistence-key")
  const { initialNavigationState, onNavigationStateChange, isRestored } = persistence

  // wait for the navigation state to restore
  // `null` will show the background color
  // can replace with <LoadingScreen /> or similar if you want
  if (!isRestored) return null

  return (
    <AppNavigator
      // initial navigation state is fetched from storage
      initialState={initialNavigationState}
      // persist changes to storage
      onStateChange={onNavigationStateChange}
    />
  )
}
```

================
File: docs/boilerplate/app/screens/Screens.md
================
# Screens folder

The `screens` folder contains the main screens of your app. Each screen is a file ending in `Screen.tsx`, such as `LoginScreen.tsx`. They are optionally contained in folders (but we recommend keeping it fairly flat).

Explore the included screens (if you left the demo code in place) to see how they work.

Screens are the central point of interaction within your app. They are responsible for rendering the UI / state, styling, handling user input, and initiating navigation to other screens.

We also tend to co-locate specific components for screens within the same folder. For example, if a login screen has a "LoginForm" component that is only used by that screen, we might put it in `app/screens/login/LoginForm.tsx` (alongside `LoginScreen.tsx`). If it's a component that is used by multiple screens, we'll put it in the `components` folder.

================
File: docs/boilerplate/app/services/api.ts.md
================
# api.ts

This is the API service. It is a singleton class and contains the code for making API calls to your backend. You can use it like this:

```typescript
import { api } from "../services/api"

// ...
const response = await api.getEpisodes()

if (response.kind === "ok") {
  // do something with response.episodes
} else {
  console.error(`Error fetching episodes: ${JSON.stringify(response)}`)
}
```

You can add more methods to this class to call other endpoints.

There are lots of other ways to handle API calls, such as using [React Query](https://tanstack.com/query/latest/), [SWR](https://swr.vercel.app/), or [Apollo Client](https://www.apollographql.com/docs/react/) and others. We've used all of these in production apps and they're all really good in different ways. We've chosen to use a simple, custom API client in this boilerplate to keep things flexible.

================
File: docs/boilerplate/app/services/Services.md
================
# Services folder

The `services` folder contains services, such as API clients.

"Services" is a somewhat broad term, but we use it to refer to code that is responsible for a specific task, such as making API calls, interacting with the file system, or handling push notifications and so on.

Ignite's boilerplate only comes with one service, the API client. However, you can add as many services as you like in this folder.

## Backend API Integration

Most apps need to communicate with a backend service of some sort. Some may have a REST API, some a GraphQL API, others might use Firebase/Firestore, Hasura, tRPC, Supabase, AWS/Amplify, or any number of different back end solutions.

Ignite purposely does not make any major decisions about what backend system we expect you to use. As a consultancy, we've integrated apps with all kinds of back ends (ask us about the _Coldfusion_ backend we integrated with a few years ago!), and can't be locked into one solution.

Ignite does come with a basic API setup which we'll describe here. Feel free to rip it out and use your own solution if this doesn't fit.

With that said, we've built large React Native apps using this pattern, and it works pretty well.

## HTTP Client

While React Native comes standard with a pretty good built-in `fetch` client library, it's not quite a smooth enough developer experience for us to recommend out of the box. So we include an HTTP client library called `apisauce`.

### apisauce

Ignite comes with [apisauce](https://github.com/infinitered/apisauce), which is a lightweight wrapper around the popular [Axios](https://axios-http.com/docs/intro) HTTP client library. We maintain this library at Infinite Red and it's a pretty battle-tested, solid HTTP library.

### The Api class

In `./app/services/api`, you'll find the [Api class](./api.ts.md). This class is the place to add methods to call when you want to fetch data from your backend. Check out the file for examples of fetching data.

### A note about React Query (aka TanStack Query)

Note that we are currently exploring [TanStack Query](https://tanstack.com/query/) for use in Ignite. We need a few more projects under our belt before we can comfortably include it with Ignite (if we do at all). However, it's a popular solution, so it's worth mentioning here.

================
File: docs/boilerplate/app/theme/colors.ts.md
================
---
title: colors.ts
---

# Colors & Palettes

In `app/theme/colors.ts`, we define a palette of colors and the semantic names to be used in the app. The palette is meant to be a simple list of colors, and the semantic names are meant to be used throughout the app. This matches how designers often think of colors & palettes, and lets us match designs which define these easily.

The palette color names are meant to be semantically neutral names matching the color. For example, `neutral100` defines a neutral color, but has no specific semantic meaning for its use. If you find yourself using a color in multiple places for the same purpose (e.g. background, border, text), define a semantic color and replace the palette color usage with the semantic one. For example, if you are styling all your text field components with a border of `colors.accent100`, define a semantic color such as `textFieldBorder` that is set to `accent100`. You would then use `colors.textFieldBorder` in your components in place of the `colors.accent100` color.

```tsx
<TextField style={{ borderColor: colors.border }} />
```

================
File: docs/boilerplate/app/theme/spacing.ts.md
================
---
title: spacing.ts
---

# Spacing

Spacing refers to the whitespace in between the elements in your app.

Spacing should be consistent and thought of as a first class technique right alongside [colors](./colors.ts.md) and [typography](./typography.ts.md).

Anytime you add margins, or padding, they should come from this spacing scale, with relatively few exceptions.

Spacings are defined in `app/theme/spacing.ts`. The scale we use in Ignite is:

```ts
export const spacing = {
  micro: 2,
  tiny: 4,
  extraSmall: 8,
  small: 12,
  medium: 16,
  large: 24,
  extraLarge: 32,
  huge: 48,
  massive: 64,
}
```

Example:

```ts
import { spacing } from "../theme"

$containerStyle = {
  margin: spacing.small,
}
```

Which type of scale you use is based on the design.

If you've got simpler app, you may only need 6 items. Or maybe you need lots of items.

Whatever you choose, try to stick with your scale and not use custom values if possible, as consistent spacing will give your app a very polished look and feel.

================
File: docs/boilerplate/app/theme/Theming.md
================
---
sidebar_position: 70
---

# Theming Ignite Apps

Theming involves creating a consistent look & feel across your application. It's a collection of style attributes and building blocks that are used everywhere.

If you're looking for customizing the look of an individual component, look at the [Styling](../../../concept/Styling.md) documentation.

Theming involves a few different things: palettes, colors, animation timings, fonts, typography, and spacing. You can find everything that we use for theming in the `app/theme` folder. When we at Infinite Red receive a custom design, one of the first places we start is in this directory matching the values to the design. It's a great idea to match the design language used by the designers with the semantic names you will be providing in these files.

## Colors & Palettes

Colors are defined in `app/theme/colors.ts` (and `colorsDark.ts` for the dark theme). We use a palette-based approach to colors, which means that we define the set of colors used in the app. We then use these colors to define semantic color names to be used throughout the app. This allows us to have a consistent color palette across the app, and also allows us to change the palette easily.

[Colors & Palettes](./colors.ts.md)

## Fonts & Typography

Fonts are defined in `app/theme/fonts.ts`. We use a similar approach to colors, defining a set of fonts and then using those fonts to define semantic font names to be used throughout the app. This allows us to have a consistent font usage across the app, and also allows us to change the fonts easily.

[Fonts & Typography](./typography.ts.md)

## Timings

Timings are defined in `app/theme/timing.ts`. They can be used for consistent animation timings throughout the app.

## Spacing

Spacing is a first class citizen in Ignite. We use a spacing scale to define the spacing between elements in the app. This allows us to have a consistent spacing scale across the app, and also allows us to change the spacing easily. It is recommended to use the spacing scale for all spacing in the app if possible.

[Spacing](./spacing.ts.md)

# Multiple Themes (a.k.a "Dark Mode")

The Ignite boilerplate ships with color palette definitions and support for multiple themes! By default we define two themes, but you can easily add more using our generic theming system.

:::tip

Head on over to the [Ignite Cookbook](https://ignitecookbook.com/) to find recipes for how to integrate Ignite's theming system with other popular styling and component libraries!

:::

**New in Ignite 10**: the `useAppTheme` hook allows you to create dynamically-themed styles, right out of the box. Here's an example:

```tsx
import { type ViewStyle, View } from 'react-native'
import {
  type ThemedStyle,
  useAppTheme,
  ThemeProvider,
  useThemeProvider
} from 'app/theme'

const $container: ThemedStyle<ViewStyle> = (theme) => ({
  flex: 1,
  backgroundColor: theme.colors.background,
  justifyContent: "center",
  alignItems: "center",
})
const $normalStyle: ViewStyle = {
  width: 100,
  height: 100,
}

// Then use in a component like so:
const Component = () => {
  const { themed } = useAppTheme()
  return (
    <View style={themed($container)}>
      <View style={$normalStyle}>
    </View>
  )
}

const App = () => {
  const { themeScheme, navigationTheme, setThemeContextOverride, ThemeProvider } =
    useThemeProvider()
  return (
    <ThemeProvider value={{ themeScheme, setThemeContextOverride }}>
      <Component />
    </ThemeProvider>
  )
}
```

For more information on the `useAppTheme()` hook, [check out its documentation](../utils/useAppTheme.tsx.md).

## Switching Between Themes

Theme support would be useless if there wasn't a built-in way to switch the theme at will. Ignite's theming system will automatically pick the theme that matches the user's system configuration (light mode or dark mode) but you can override this using the `

```tsx
// In your component:
const {
  setThemeContextOverride, // Function to set the theme
  themeContext, // The current theme context ("light" | "darK")
} = useAppTheme()

// Then hook it up to a user interaction:
const onThemeButtonPress = () => {
  // This will toggle between light and dark mode.
  setThemeContextOverride(themeContext === "dark" ? "light" : "dark")
}

// Or you can let them use their deice's system setting: light/dark
const resetThemeContextOverride = () => {
  setThemeContextOverride(undefined)
}
```

You could also hook it up to a switch if that's more your style:

```tsx
// In your component:
const {
  setThemeContextOverride, // Function to set the theme
  themeContext, // The current theme context ("light" | "darK")
} = useAppTheme()

// Then implement the switching button:
<Toggle
  label="Dark Mode"
  variant="switch"
  value={themeContext === "dark"}
  onValueChange={(value: boolean) => {
    setThemeContextOverride(value ? "dark" : "light")
  }}
/>
```

Once you have set an explicit theme override, the app will not respect the user's system setting, allowing you to lock the app to dark mode or light mode even when the user's system setting is different.

To have your app go back to respecting the user's device system setting, you can call `setThemeContextOverride(undefined)`.

## Hooking up the navigation theme

Ignite uses `react-navigation` so it's already hooked up for use with your `NavigationController`! The `navigationTheme` variable returned from `useThemeProvider()` is a `react-navigation` theme object you can pass to the root `NavigationController`.

```tsx
const { navigationTheme } = useThemeProvider()
return <NavigationContainer theme={navigationTheme} {...props} />
```

## Integrating other styling and component libraries

There are many component libraries that offer light/dark modes to their components. Here's an example of how to use `react-native-elements` with Ignite's theming system by extending their own `ThemeProvider`:

```tsx
import { colorsDark, colorsLight, customFontsToLoad } from "src/theme"
import { createTheme as createRNEUITheme, ThemeProvider as RNEUIThemeProvider } from "@rneui/themed"

export const ThemedRNEUIProvider = ({ children }) => {
  const { themeScheme } = useThemeProvider()
  const themeColors = themeScheme === "light" ? colorsLight : colorsDark
  const RNEUITheme = createRNEUITheme({
    mode: themeScheme,
    lightColors: {
      primary: colorsLight.palette.secondary500,
    },
    darkColors: {
      primary: colorsDark.palette.secondary500,
    },
    components: {
      Text: {
        style: {
          color: themeColors.text,
        },
      },
      // ...etc
    },
  })

  return <RNEUIThemeProvider theme={RNEUITheme}>{children}</RNEUIThemeProvider>
}
```

================
File: docs/boilerplate/app/theme/typography.ts.md
================
---
title: typography.ts
---

# Fonts & Typography

Fonts are defined in `app/theme/typography.ts`. We use a similar approach to [colors](./colors.ts.md), defining a set of fonts and then using those fonts to define semantic font names to be used throughout the app. This allows us to have a consistent font usage across the app, and also allows us to change the fonts easily.

## Fonts

We define the fonts used in `app/theme/typography.ts`. The custom fonts are loaded using the `useFonts` hook from [`expo-fonts`](https://docs.expo.dev/guides/using-custom-fonts/) to load the fonts.

To add additional custom fonts to your project, obtain the proper OTF/TTF file(s) or install the desired Google Font package. Make the necessary additions to the `customFontsToLoad` object in `app/theme/typography.ts` and `fonts` object to reference the font family in the typography theming object.

```tsx
export const customFontsToLoad = {
  spaceGroteskLight,
  spaceGroteskRegular,
  spaceGroteskMedium,
  spaceGroteskSemiBold,
  spaceGroteskBold,
  myCustomFont: require("./assets/fonts/custom-font.otf"),
}

const fonts = {
  // ...
  myCustomFont: {
    normal: "myCustomFont",
  },
}
```

Keep in mind that when utilizing custom fonts, it is a better user experience to wait on rendering anything within the app until the fonts are loaded (this will prevent any text from changing in front of the user's eyes). This functionality is baked into Ignite for you! Check out `app/app.tsx` to see it in action.

## Typography

Since we use the [`Text`](../components/Text.md) component to encapsulate almost all text within an ignite app, the semantic names are essentially presets. As with all presets, they should only be created where there's a consistent pattern of usage across the app. To do this you'd add a new preset to the `Text` component with the associated styles. For one-off cases, it's recommended to use the [`size`](../components/Text.md#size) and [`weight`](../components/Text.md#weight) props on the `Text` component.

================
File: docs/boilerplate/app/utils/useAppTheme.tsx.md
================
---
sidebar_position: 10
---

# useAppTheme

The `useAppTheme()` hook returns various properties and tools relating to theming your app.

Generally, you'll only need a few properties from this hook, with the most important being `theme` and `themed`.

Example usage:

```tsx
import { View, type ViewStyle } from "react-native"
import { useAppTheme } from "@/utils/useAppTheme"

const MyComponent = () => {
  const {
    // Any styles you create with the type ThemedStyle<T> must be wrapped with
    // themed($styleName) before passing it along to the component's style property.
    themed,
    // This is the current theme object.
    theme,
    // themeContext is what theme you are actually using: "light" | "dark"
    themeContext,
  } = useAppTheme()

  return (
    <View style={themed($container)}>
      <View style={$plainObjectStyle}>
        {/* An Example of direct theme color usage in a component: */}
        <View
          style={{
            backgroundColor: theme.colors.error,
          }}
        >
          {/* This will output "light" or "dark" */}
          <Text>{themeContext}</Text>
        </View>
      </View>
    </View>
  )
}

// This is an ignite ThemedStyle. It's just like a ViewStyle but
// is wrapped with a function that will be called with a theme parameter.
const $container: ThemedStyle<ViewStyle> = (theme) => ({
  // You can access theme named colors:
  backgroundColor: theme.colors.background,
  // Accessing the color palette is not generally recommended.
  color: theme.colors.palette.angry500,
  // Spacing can be changed on a per-theme basis as well.
  paddingHorizontal: theme.spacing.small,
})

// We haven't abandoned plain style objects as the preferred way
// to style your components, but it can't use dynamic themes.
const $plainObjectStyle: ViewStyle = {
  marginBottom: 20,
}
```

## Properties:

### `navTheme`

A `react-navigation` [theme object](https://reactnavigation.org/docs/themes#built-in-themes). This is the same object you would pass to a `NavigationContainer` component.

### `setThemeContextOverride`

A function that allows you to override the theme context. This is useful for allowing users to switch between light and dark mode.

The default behavior is to use the system theme, but you can override this by calling `setThemeContextOverride("light" | "dark")`.

Calling `setThemeContextOverride(undefined)` will reset the theme to the user's system preference.

### `theme`

A `Theme` object that contains all the colors, spacing, and other theme-related properties of the current theme context. You can edit these values in the `app/theme` folder.

### `themeContext`

A string that represents the current theme context. This will almost always be either "light" or "dark".

:::info

When resetting the theme context to the system preference with `setThemeContextOverride(undefined)`, the `themeContext` will not be undefined. It will be the return value of `react-native`'s `useColorScheme()` hook.

:::

### `themed`

`themed()` is a simple function with complex types. You can pass a plain style object to it, a `ThemedStyle` function, or an array of either.

:::note

When passing an array of styles or `ThemedStyle` functions to `themed()`, it will return a single style object with last properties overriding any properties previously set.

In the example below, the last `<View>` would be yellow even though `$themedStyle` specifies red because the background color property was modified by a later style in the array.

:::

```tsx
const $plainStyle: ViewStyle = {
  padding: 10,
  backgroundColor: "black",
  width: 25,
  height: 25,
}

const $themedStyle: ThemedStyle<ViewStyle> = (theme) => ({
  backgroundColor: theme.colors.errorBackground,
  height: theme.spacing.xl,
  width: theme.spacing.xl
})

<View style={$plainStyle} />
// <View style={$themedStyle} /> // This won't work
<View style={themed($themedStyle)} />
// <View style={themed($plainStyle)} /> // You can, but why would you?
<View style={themed([$themedStyle, $plainStyle])} />
<View style={themed([
  $themedStyle,
  $plainStyle,
  // A plain style object
  { width: 7, backgroundColor: 'yellow'}
])} />
```

Make sure you don't pass any `Animated` styles to `themed()`. It will not work as expected! Keep them in separate style array objects: `<Animated.View style={[$animatedStyle, themed($myThemedStyle)]}>`.

================
File: docs/boilerplate/app/utils/useHeader.tsx.md
================
---
sidebar_position: 30
---

# useHeader

The `useHeader()` hook that can be used to easily set the Header of a react-navigation screen from within the screen's component.

```tsx
function AccountScreen() {
  useHeader({
    rightTx: "common.logOut",
    onRightPress: logout,
  })

  return <Screen />
}
```

## Parameters

### `headerProps: HeaderProps`

The first parameter is an object representing the props that will be passed directly to the [Header](../components/Header.md) component.

```tsx
useHeader({
  rightTx: "common.logOut",
  leftTx: "common.back",
  onRightPress: logout,
  onLeftPress: goBack,
})
```

### `deps: any[]`

The second parameter is a list of dependencies passed to the `useLayoutEffect` that will cause the Header to be updated. Use this to control a dynamic header.

```tsx
const [count, setCount] = useState(1)

useEffect(() => {
  setTimeout(() => setCount(count + 1), 1000)
}, [count])

useHeader(
  {
    title: `Count: ${count}`,
  },
  [count],
)
```

================
File: docs/boilerplate/app/utils/useSafeAreaInsetsStyle.ts.md
================
---
sidebar_position: 20
---

# useSafeAreaInsetsStyle

The `useSafeAreaInsetsStyle()` hook can be used to create a safe-area-aware style object that can be passed directly to a View.

```tsx
<View style={useSafeAreaInsetsStyle(["top"], "padding")} />
```

## Parameters

### `safeAreaEdges: ExtendedEdge[]`

The first parameter is a list of edges that need to be safe-area-aware. In order for the hook to return an object with values, at least one edge needs to be provided. Default is `[]`.

```tsx
const $insetsStyle = useSafeAreaInsetsStyle(["top", "left"])

console.log($insetsStyle) // { paddingTop: 47, paddingStart: 0 }
```

### `property: "padding" | "margin"`

The second parameter specifies the property prefix that will be used to compose the style object. Default is `padding`.

```tsx
const $insetsPaddingStyle = useSafeAreaInsetsStyle(["bottom"], "padding")
const $insetsMarginStyle = useSafeAreaInsetsStyle(["bottom"], "margin")

console.log($insetsPaddingStyle) // { paddingBottom: 28 }
console.log($insetsMarginStyle) // { marginBottom: 28 }
```

## Types

### `ExtendedEdge`

A safe-area edge:

- top
- bottom
- left
- right
- start
- end

Note: "start" maps to the "left" value. "end" maps to "right.

================
File: docs/boilerplate/app/utils/Utils.md
================
---
title: utils
sidebar_position: 60
---

# `utils` folder

Every app needs a junk drawer. Here you can find a library of utilities that are used often within your application. This could includes hooks, helper functions, and various tools.

## Hooks

:::tip
We sometimes create a separate `app/hooks` folder just for hooks. This is a matter of preference.
:::

### useAppTheme

A hook that returns various properties and tools relating to theming your app.

```tsx
const { themed, themeContext } = useAppTheme()

const $themedStyle: ThemedStyle<ViewStyle> = (theme) =({
  backgroundColor: theme.colors.background
})

<View style={themed($themedStyle)}>
  <Text>{themeContext}</Text>
</View>
```

[Full `useAppTheme`](./useAppTheme.tsx.md)

### useSafeAreaInsetsStyle

A hook can be used to create a safe-area-aware style object that can be passed directly to a View.

```tsx
const $insetStyle = useSafeAreaInsetsStyle(["top"], "padding")

<View style={$insetStyle} />
```

[Full `useSafeAreaInsetsStyle`](./useSafeAreaInsetsStyle.ts.md)

### useHeader

A hook that can be used to easily set the Header of a react-navigation screen from within the screen's component.

```tsx
function AccountScreen() {
  useHeader({
    rightTx: "common.logOut",
    onRightPress: logout,
  })

  return <Screen />
}
```

[Full `useHeader`](./useHeader.tsx.md)

================
File: docs/boilerplate/assets.md
================
---
title: assets
sidebar_position: 20
---

# Assets Folder

The `assets` folder is for icons, images, fonts, and other static assets used in your app.

### App Icons

For your App Icon, use [Ignite's App Icon Generator](../../concept/Generators/#app-icon-generator) to automatically generate image assets, which get put in `assets/images`.

### Splash Screen

To update your Splash Screen, use [Ignite's Splash Screen Generator](../../concept/Generators/#splash-screen-generator) to generate images and update `assets/images`.

================
File: docs/boilerplate/Boilerplate.md
================
---
sidebar_position: 1
---

# Ignite's Boilerplate

:::tip
A "boilerplate" project is one that you can use as a starting point for your own project.
:::

At its heart, Ignite is a boilerplate. Rather than using a basic template from something like react-native-cli or Expo, Ignite is more full-featured and opinionated. However, it still really customizable -- after all, we have many different types of projects we work on and don't want to be painted into a corner either.

When you [spin up a new Ignite project](../Guide.md), you'll get a project with several folders. Feel free to explore each one and see what's inside.

## Explanation of the Ignite folder structure

A new Ignite boilerplate project's structure looks similar to this:

```
your-project
├── .maestro
├── android
├── app
│   ├── components
│   ├── config
│   ├── devtools
│   ├── i18n
│   ├── models
│   ├── navigators
│   ├── screens
│   ├── services
│   ├── theme
│   ├── utils
│   ├── app.tsx
├── assets
├── ignite
│   └── templates
├── ios
├── plugins
│   └── withSplashScreen.ts
├── test
│   ├── i18n.test.ts
│   ├── mockFile.ts
│   ├── setup.ts
│   ├── test-tsconfig.json
├── app.config.ts
├── app.json
├── index.tsx
├── eas.json
├── package.json
└── README.md
```

### ./app directory

The vast majority of your code will live in the [/app folder](./app/app.md). This is where you'll spend most of your time.

**[components](./app/components/Components.md)**

This is where your components will live, the reusable building blocks to create your screens. A handful of built-in components come with Ignite that are adaptable to any custom design system you wish to implement.

**[config](./app/config/Config.md)**

This contains configuration for your app that might vary depending if you're running in development or production.

**[devtools](./app/devtools/Devtools.md)**

This is where setup and configuration of devtools like Reactotron occurs.

**[i18n (Internationalization)](./app/i18n/Internationalization.md)**

This is where your translations will live if you are using the included `react-native-i18n`.

**[models](./app/models/Models.md)**

This is where your app's models will live. Each model has a directory which will contain the `mobx-state-tree` model file, test file, and any other supporting files like actions, types, etc. In addition, a helpers directory contains utility functions such as `getRootStore` to access the root store.

**[navigators](./app/navigators/Navigation.md)**

This is where your `react-navigation` navigators will live.

**[screens](./app/screens/Screens.md)**

This is where your screen components will live. A screen is a React component which will take up the entire screen and be part of the navigation hierarchy. Each screen will have a directory containing the `.tsx` file, along with any assets or other helper files.

**[services](./app/services/Services.md)**

Any services that interface with the outside world will live here (think REST APIs, Push Notifications, etc.).

**[theme](./app/theme/Theming.md)**

Here lives the theme for your application, including spacing, colors, and typography.

- For help with adding custom fonts to your application, check out [Fonts & Typography](../boilerplate/app/theme/typography.ts.md).

**[utils](./app/utils/Utils.md)**

This is a great place to put miscellaneous helpers and utilities. Things like date helpers, formatters, etc. are often found here. However, it should only be used for things that are truly shared across your application. If a helper or utility is only used by a specific component or model, consider co-locating your helper with that component or model.

**[app.tsx](./app/app.tsx.md)**

The main entry point for your app!

### Root Directory

#### Directories

**[.maestro](./maestro.md)** - Maestro e2e tests

**[android](./android.md)** - Native Android / Android Studio project files for manual workflows

**[assets](./assets.md)** - icons and images

**[ignite](./ignite.md)** - all things Ignite, including generator templates.

**[ios](./ios.md)** - Native iOS / Xcode project files for manual workflows

**[plugins](./plugins/Plugins.md)** - any custom Expo Config Plugins to be applied during the prebuild process when generating the native code for the project.

**[test](./test/Test.md)** - Jest configs and mocks

#### Files

**[app.json/app.config.ts](./app.json.md)** - configuration files for your app. `app.json` contains the static configuration which will be fed into the dynamic configuration in `app.config.ts`, where Expo builds it's final configuration for the app.

**[index.tsx](./index.tsx.md)** - entry point to your app. This is where you will find the main App component which renders the rest of the application.

**[eas.json](./eas.json.md)** - build configurations for Expo EAS builds

================
File: docs/boilerplate/eas.json.md
================
---
title: eas.json
sidebar_position: 70
---

# eas.json

`eas.json` is the configuration file for [Expo Application Service (EAS)](https://docs.expo.dev/eas/). It allows you to create profiles for building and distributing your app.

Ignite includes a few default build profiles for common scenarios, but you can customize or add your own profiles too!

- `development` - internal debug build for testing on simulators
- `development:device` - internal debug build for testing on physical devices
- `preview` - internal production build for testing on simulators
- `preview:device` - internal production build for testing on physical devices
- `production` - default production profile intended for external distribution

Note how profiles can share settings via `extends`:

```json
"development": {
    "extends": "production",
    "distribution": "internal",
    "android": {
        "gradleCommand": ":app:assembleDebug"
    },
    "ios": {
        "buildConfiguration": "Debug",
        "simulator": true
    }
},
"development:device": {
    "extends": "development",
    "distribution": "internal",
    "ios": {
        "buildConfiguration": "Debug",
        "simulator": false
    }
},
"production": {}
```

In this example, `development:device` inherits the settings from `development`, but changes the `ios` setting to `simulator: false`. You can use `extends` to create a set of profiles to fit your needs without duplicating configuration.

View [Expo's eas.json Documentation](https://docs.expo.dev/build/eas-json/) for more info.

================
File: docs/boilerplate/ignite.md
================
---
title: ignite
sidebar_position: 25
---

# Ignite Folder

The `ignite` directory contains an initial set of generator templates to help scaffold new screens, components, models, app icons, and more.

Generators are the true gem of Ignite! They can save you countless hours as you build your app - we strongly recommend you give it a try!
Learn more about [Ignite Generators](../concept/Generators.md) and how to create your own [Ignite Generator Templates](../concept/Generator-Templates.md)

================
File: docs/boilerplate/index.tsx.md
================
---
title: index.tsx
sidebar_position: 65
---

# index.tsx

`index.tsx` is the entry point for Expo / React Native itself. It is minimal on purpose - its only responsibility is to:

- Register the root component with the `AppRegistry`
- Sets up the environment properly for the native build

================
File: docs/boilerplate/ios.md
================
---
title: ios
sidebar_position: 30
---

# `ios` folder

If you choose the `manual` workflow option when spinning up a new app (or you run `yarn prebuild:clean`) you'll get an `ios` (and probably [`android`](./android.md)) folder in your project root. This folder contains your native iOS / Xcode project, which has been pre-configured to work with React Native.

We generally recommend using the [Expo CNG (continuous native generation)](../expo/CNG.md) workflow, but if you need to customize your native code manually, you can do so here.

Just like any React Native project, you can open this folder in Xcode and run your app on a simulator or device. Learn more here: [https://reactnative.dev/docs/native-debugging#debugging-native-code](https://reactnative.dev/docs/native-debugging#debugging-native-code)

================
File: docs/boilerplate/maestro.md
================
---
title: .maestro
sidebar_position: 2
---

# Maestro

Ignite's demo project includes a `.maestro` directory with a few example test flows. [Maestro](https://maestro.mobile.dev/) is Ignite's default end-to-end testing solution.

If you have Maestro setup, you can run your tests via

```bash
maestro test .maestro/MyTestFile.yaml
```

This command is also setup as a npm script in `package.json`, which you can customize to your liking:

```bash
yarn run test:maestro
```

You can learn how to run and create Maestro tests by following the [Ignite Cookbook Recipe](https://ignitecookbook.com/docs/recipes/MaestroSetup) or by visiting [Maestro's Documentation](https://maestro.mobile.dev/)

================
File: docs/boilerplate/plugins/Plugins.md
================
## `plugins` Directory in Ignite Apps

The `plugins` directory is a dedicated space within the Ignite boilerplate for managing Expo Config Plugins. These plugins are used to customize the native configuration of your app without altering the native code directly.

### Adding Custom Plugins

To add a custom plugin:

1. **Create a Plugin**: In `plugins`, define your plugin in a TypeScript file, exporting a function that modifies the ExpoConfig.
2. **Integrate the Plugin**: In `app.config.ts`, import your plugin and add it to the `plugins` array.

Example:

```typescript
// In app.config.ts
plugins: [...existingPlugins, require("./plugins/yourCustomPlugin").yourCustomPlugin]
```

## Key Points

- Config plugins extend app configuration, automating native module integration.
- Create plugins in `plugins` and add them to `app.config.ts`.
- For complex setups, refer to mods but use them with caution.

For detailed information on creating and using config plugins, refer to [Expo's Config Plugins documentation](https://docs.expo.dev/config-plugins/introduction/).

================
File: docs/boilerplate/plugins/withSplashScreen.md
================
# withSplashScreen Config Plugin

## Purpose

`withSplashScreen` addresses the double splash screen issue in Expo apps (documented in [Expo GitHub issue #16084](https://github.com/expo/expo/issues/16084)), by ensuring a seamless transition between the initial native splash screen and the one managed by `expo-splash-screen`.

## Functionality

- **Transparent Splash Screen**: Replaces the default splash screen with a transparent one on Android.
- **Translucent Status Bar**: Sets the status bar to translucent to match the transparent splash screen.

## Implementation

1. **Modifies `strings.xml`**: Adds a setting for a translucent status bar.
2. **Updates `styles.xml`**: Adjusts `Theme.App.SplashScreen` to make the window translucent.

================
File: docs/boilerplate/test/Test.md
================
# Test Folder

Ignite includes support for writing [Jest](https://jestjs.io/) tests, which can be located anywhere in your codebase. But the initial Jest setup, mocking objects for testing, and any global scoped tests belong in the `test` directory.

### i18n.test.ts

`test/i18n.test.ts` is a handy test to check for any missing or mistyped translation keys in your app.
It searches the codebase for components using the `tx=""` prop, or any `translate("")` commands, and checks for a valid i18n key between the double quotes.

This approach isn't 100% perfect. If you are storing your key string in a variable because you are setting it conditionally, then it won't be picked up.

================
File: docs/cli/Ignite-CLI.md
================
# Ignite CLI

Ignite comes with a dynamic CLI that does more than just get you started with developing a new react-native mobile application! Check out the command list below for additional documentation on each.

## Commands

### Cache

- `npx ignite-cli cache`
- Alias: `npx ignite-cli c`

The [`new` command](#new) has a `useCache` flag that allows you to cache your dependencies to speed up future uses of `new`. By default, this flag is `false`. This command is provided to allow for interacting with the dependency cache file folder.

#### Subcommands

- `npx ignite-cli cache help` outputs help command to describe cache subcommands
- `npx ignite-cli cache path` outputs the path of the cache folder on your system
- `npx ignite-cli cache clear` deletes the cache folder on your system

#### Options

- `path` displays the path to the dependency cache
- `clear` clears the dependency cache

### Doctor

- `npx ignite-cli doctor`

Checks your development environment for dependencies and provides version information. This is especially helpful when reporting issues you're experiencing with Ignite. Below is a sample output:

```
System
  platform           darwin
  arch               arm64
  cpu                10 cores     Apple M1 Pro
  directory          ExpoPlist    /Users/irignite/code/ExpoPlist

JavaScript (and globally-installed packages)
  node                16.14.2      /Users/irignite/.nvm/versions/node/v16.14.2/bin/node
  npm                 8.5.0        /Users/irignite/.nvm/versions/node/v16.14.2/bin/npm
    corepack          0.10.0
    eas-cli           2.5.1
    expo-cli          6.0.6
    gatsby-cli        4.21.0
    ignite-cli        8.3.0
    npm               8.5.0
    vercel            28.4.12
    yarn              1.22.19
  yarn                1.22.19      /Users/irignite/.nvm/versions/node/v16.14.2/bin/yarn
    create-expo-app   1.1.2
  pnpm                -            not installed
  expo                46.0.16      managed

Ignite
  ignite-cli         8.3.0        /Users/irignite/.nvm/versions/node/v16.14.2/bin/ignite
  ignite src         src          /Users/irignite/code/ignite/src

Android
  java               11.0.14.1    /Users/irignite/.asdf/shims/java
  android home       -            /Users/irignite/Library/Android/sdk

iOS
  xcode              14.0.1
  cocoapods          1.11.3       /opt/homebrew/bin/pod

Tools
  git                git version 2.37.0 (Apple Git-136)   /usr/bin/git
```

### Generate

- `npx ignite-cli generate`
- Alias: `npx ignite-cli g`

Provides generators to keep your code consistent while saving you time to scaffold new models, components and screens in an automated fashion.

For full documentation on this, head on over to the [Generators documentation](../concept/Generators.md).

### Help

- `npx ignite-cli help`
- Alias: `npx ignite-cli h`

Provides this list of commands and a small description of each command in your terminal.

### New

- `npx ignite-cli new PizzaApp`

Starts the interactive prompt for generating a new Ignite project. Any options not provided at the time of command execution will be asked. You can accept all the defaults to the options passing in `--yes` and just get to coding!

#### Options

- `--bundle` string, provide a custom bundle identifier
- `--debug` verbose logging throughout the project setup
- `--git` create a new repository with an initial commit
- `--installDeps` run the packager install script after project creation
- `--overwrite` overwrite the target directory if it exists
- `--targetPath` string, specify a target directory where the project should be created
- `--removeDemo` will remove the boilerplate demo code after project creation
- `--state` string, one of `mst` or `none` to include MobX-State-Tree in project (can only be set to `none` if `--removeDemo=true`)
- `--useCache` flag specifying to use dependency cache for quicker installs
- `--no-timeout` flag to disable the timeout protection (useful for slow internet connections)
- `--yes` accept all prompt defaults
- `--workflow` string, one of `cng` or `manual` for project initialization
- `--experimental` comma separated string, indicates experimental features (which may or may not be stable) to turn on during installation. **A CNG workflow is require for these flags** `--workflow=cng`
  - `expo-router` converts the project to [Expo Router](https://docs.expo.dev/router/introduction/) from React Navigation
  - `new-arch` enables [The New Architecture](https://reactnative.dev/docs/new-architecture-intro)
  - `expo-canary` uses Expo's highly experimental canary release instead of the la test stable SDK
  - `expo-beta` uses Expo's latest beta SDK available instead of the latest stable SDK
  - Examples: `--experimental=new-arch` or `--experimental=new-arch,expo-beta`

### Issue

- `npx ignite-cli issue "Mac M1 install trouble"`
- Alias: `npx ignite-cli i`

Fires up a [new issue for Ignite on GitHub](https://github.com/infinitered/ignite/issues/new/) prefilled with collected [doctor](#doctor) information. Simply describe your steps to help reproduce the issue (and provide any relevant code snippets or repository) and press submit!

### Remove Demo Markup

- `npx ignite-cli remove-demo-markup`
- Alias: `npx ignite-cli rdm`

Removes all demo markup (comments only) from the generated boilerplate

#### Options

- `--dry-run` displays markup which would be removed without doing so

### Remove Demo

- `npx ignite-cli remove-demo`
- Alias: `npx ignite-cli rd`, `npx ignite-cli remove-demos`

Removes all demo code (files, marked code blocks and lines) from the generated boilerplate

#### Options

- `--dry-run` displays files that would be modified without doing so

### Rename

- `npx ignite-cli rename`
- Alias: `npx ignite-cli rn`

Renames your current project to the desired new name. It'll also help switch the bundle identifier.

### Update

- `npx ignite-cli update`

Updates the generator templates that currently exist in the project. This can be used to grab the latest versions of the templates should the project have been ignited with a previous version.

================
File: docs/cli/Remove-Demo-Code.md
================
---
sidebar_position: 170
---

# Remove Demo Code

Whenever users use command line boilerplate tool like `ignite` or `create-react-app`, the first thing that many users do is delete all the demo code to start their project.

Instead of going through the files yourself, or using find and replace, run `npx ignite-cli remove-demo`.

After the command, the Ignite boilerplate will now have the smallest amount of demo code possible, while having all of Ignite's set up still at your fingertips.

_Note: You can pass `--dry-run` to have the command tell you what it would remove/change._

## How It Works

When adding demo code to the boilerplate, use the following comments to have fine grained control over what gets stripped out. The goal is to be able to remove as much source code as possible while still having the generated Ignite app build correctly.

### `// @demo remove-file`

Remove the entire file.

#### Example:

```tsx
// @demo remove-file
export * from "./Text"
export * from "./Screen"
```

### `// @demo remove-current-line`

Remove the current line from the source code.

#### Example:

```tsx
const $style: ViewStyle = { padding: 10 } // @demo remove-current-line
```

### `// @demo remove-next-line`

Remove the next line from the source code

#### Example:

```tsx
// @demo remove-next-line
import { DemoScreen } from "./demo/screen"
```

### `// @demo remove-block-start && // @demo remove-block-end`

Remove the entire block between these lines from the source code

#### Example:

```tsx
// @demo remove-block-start
export function DemoDivider(props: DemoDividerProps) {
  const { type = "horizontal", size = 10, style: $styleOverride } = props

  return (
    <View
      style={[
        $divider,
        type === "horizontal" && { height: size },
        type === "vertical" && { width: size },
        $styleOverride,
      ]}
    />
  )
}
// @demo remove-block-end
```

================
File: docs/cli/Troubleshooting.md
================
---
sidebar_position: 145
---

# Troubleshooting

If you run into problems, first search the issues in the [GitHub repository](https://github.com/infinitered/ignite/issues). If you don't find anything, you can come talk to our friendly and active developers in the Infinite Red Community Slack ([community.infinite.red](http://community.infinite.red)).

## Troubleshooting setup

We recommend using `npx ignite-cli@latest [command]` to ensure you're using the latest & greatest Ignite.

### Remove a previous global install

You might run into version conflicts or environment differences if you have Ignite installed globally.
Check if Ignite is installed globally on your machine with:

```bash
ignite --info          # Should output cli information
where ignite           # identify where it's installed
```

You can uninstall previous versions of the cli with:

```bash
npm uninstall --global ignite-cli
# or
yarn global remove ignite-cli
```

================
File: docs/concept/Concepts.md
================
---
sidebar_position: 1
---

# Concepts &amp; Features

Ignite has **very** strong opinions about what the structure, dependencies, and layout of a react-native app should be.

For anything that falls outside the scope of a default ignited app, we have "cookbook" recipes for modifying the app. Check our the Ignite Cookbook here: https://ignitecookbook.com/

================
File: docs/concept/Error-Boundary.md
================
# Error Boundary

Sometimes, things go wrong in an app. A request comes back with an unexpected status, users find ways to make invalid inputs, a whole host of other issues that we can't imagine when we are first writing code.

It is a good idea to have a fallback UI for critical screens or components when they unexpected throw an error.

That is why we provide an ErrorBoundary component in Ignite by default.

## How to Handle Errors

### Render Error UI

```tsx
const ErrorMessage = () => <Text>Something went wrong!</Text>

class ErrorBoundary extends Component<Props, State> {
  state = { error: null, errorInfo: null }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    this.setState({
      error,
      errorInfo,
    })
  }

  render() {
    return this.state.error ? <ErrorMessage /> : this.props.children
  }
}
```

`ErrorBoundary` components leverage the `componentDidCatch` method on Class Components to capture and allow us to store errors when children throw an exception.

This allows us to show alternative UI components when an error is thrown on child components.

### Use Error Reporting Service

Inside `componentDidCatch` of an `ErrorBoundary` component is also a great place to report to monitoring services like BugSnag, Sentry, or Honeybadger, so you can be alerted when errors are happening for users.

Ignite provides utilities in [`/app/utils/crashReporting.ts`](https://github.com/infinitered/ignite/blob/master/boilerplate/app/utils/crashReporting.ts) to integrate these services into your app.

## Examples

- See our [`ErrorBoundary` component](https://github.com/infinitered/ignite/blob/master/boilerplate/app/screens/ErrorScreen/ErrorBoundary.tsx) for error catching logic
- See our [`ErrorScreen` component](https://github.com/infinitered/ignite/blob/master/boilerplate/app/screens/ErrorScreen/ErrorDetails.tsx) for error fallback UI
- [reactjs.org docs on Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)
- [codepen example of Error Boundary usage](https://codepen.io/gaearon/pen/wqvxGa?editors=0010)

================
File: docs/concept/Generator-Templates.md
================
---
sidebar_position: 111
---

# Generator Templates

Generator templates are written in [ejs](https://ejs.co/), which is a templating language using JavaScript.

You write the template however you want, and use `<%= foo %>` to run and output JavaScript.

You can also use control statements like "if" with `<% if (condition) { %>Stuff here<% } %>`.

## Folder naming conventions

Templates are located in your app's `./ignite/templates` folder, and the name of the folder should match the name of the generator.

For example, if you want to run `npx ignite-cli generate header Pizza`, you'd put the header templates in the `./ignite/templates/header/` folder.

Any files in that folder will be copied over & run through the generator with the `Pizza` name applied.

## File naming conventions

If you use all upper-case `NAME` in your template filenames, that will be replaced by a pascal-case version of the name provided by the person running the generator.

It's best to just look at an example:

Let's say you have a file called `NAMEScreen.ts`.

If they run `npx ignite-cli generate screen Pizza`, it'll name the file `PizzaScreen.ts`.

If you'd like to customize the filename you can provide a filename option in the front matter of the template like so:

```
---
filename: <%= props.camelCaseName %>.tsx
---
```

## Props

There's a provided `props` object that contains the following properties:

```
props.skipIndexFile  // boolean, if --skip-index-file is passed it's `true`
props.filename       // string, the name of the file being generated (e.g. "UserModel.tsx")
props.pascalCaseName // string, PascalCase version of the name that is passed in (e.g. "UserModel")
props.camelCaseName  // string, camelCase version of the name (e.g. "userModel")
props.kebabCaseName  // string, kebab-case version of the name (e.g. "user-model")
props.subdirectory   // string, the subdirectory path to the file being generated (e.g. "my/sub/path/")
```

Example of using these in a template:

```ejs
type <%= props.pascalCaseName %>Props = { some: string }
export function <%= props.pascalCaseName %>(props: <%= props.pascalCaseName %>Props) {
  return <Text>{props.some} in a <%= props.pascalCaseName %> component!</Text>
}
```

## Front Matter

"Front matter" is a way to specify meta-data about a template in the template itself. It's stripped out of the generated file. You delineate front matter by three dashes (`---`) above and below, and it has to be the very first thing in the template. The following front matter options are available:

### destinationDir

We use this in Ignite to customize the destination of a given template. For example, in `./ignite/templates/navigator/*` we could have:

```
---
destinationDir: app/navigation
---
import { StackNavigator } from "react-navigation"

// ...
```

This would copy files to `./app/navigation/*` instead of the default `./app/navigators/*`.

### patch

This lets you patch another file, such as an index file. Example:

```tsx
---
patch:
  path: "app/screens/index.ts"
  append: "export * from \"./<%= props.kebabCaseName %>/<%= props.kebabCaseName %>-screen\"\n"
  skip: <%= props.skipIndexFile %>
---
```

### patches

You can patch multiple files with `patches`. It works just the same as `patch`, but allows for multiple.

```tsx
---
patches:
  - path: "app/models/RootStore.ts"
    after: "from \"mobx-state-tree\"\n"
    insert: "import { <%= props.pascalCaseName %>Model } from \"../<%= props.kebabCaseName %>/<%= props.kebabCaseName %>\"\n"
    skip: <%= !props.kebabCaseName.endsWith('store') %>
  - path: "app/models/RootStore.ts"
    after: "types.model(\"RootStore\").props({\n"
    insert: "  <%= props.camelCaseName %>: types.optional(<%= props.pascalCaseName %>Model, {} as any),\n"
    skip: <%= !props.kebabCaseName.endsWith('store') %>
  - path: "app/models/index.ts"
    append: "export * from \"./<%= props.kebabCaseName %>/<%= props.kebabCaseName %>\"\n"
    skip: <%= props.skipIndexFile %>
---
```

## Notes

Front matter is very powerful, but not necessarily super intuitive. If you have questions about it, ask in the [Ignite Slack community](https://community.infinite.red) or post a [Discussion](https://github.com/infinitered/ignite/discussions).

================
File: docs/concept/Generators.md
================
---
sidebar_position: 110
---

# Generators

_The true gem of Ignite._ When you spin up a new app with Ignite CLI, we copy in several generator templates into `./ignite/templates/*`. Generators help you scaffold your app very quickly, be it for a proof-of-concept, a demo, or a production app. Generators are there to save you time, keep your code consistent, and help you with the basic structure of your app.

```
npx ignite-cli generate --list
```

...will give you information on what generators are present.

## Built-in generators

### Component generator

This is the generator you will be using most often. They come pre-wrapped with mobx-react-lite's `observer` function, which you'll need to trigger re-renders if any MobX-State-Tree properties that are being used in this component change.

```
npx ignite-cli generate component MyAwesomeButton
```

- Creates the component/function

### Screen generator

Generates a "hooks enabled" screen that is also pre-wrapped with mobx-react-lite's `observer` function, making it automatically re-render anytime a relevant MST property changes.

```
npx ignite-cli generate screen Settings
```

### Model generator

Creates a Mobx-State-Tree model.

```
npx ignite-cli generate model Pizza
```

- Creates the model
- Creates a unit test file
- Appends export to `models/index.ts` unless you pass `--skip-index-file`

### Navigator generator

Creates a React Navigation navigator in the `app/navigators` folder.

```
npx ignite-cli generate navigator OrderPizza
```

You can learn more about navigators [in the Navigation docs](../boilerplate/app/navigators/Navigation.md).

### App Icon generator

App icons are tricky - there are many different shapes and sizes, and many different configuration files and locations to update. So we include this generator to make it much easier on you!

This is a special kind of generator - "special" in that it modifies the native project folders with resized and transformed input image files found in the generator's template folder. Also, it only accepts predefined options for the second parameter: one of `ios`, `android`, `expo` or `all`.

The following files will be found in your templates folder (`ignite/templates/app-icon`) which can be customized:

- `android-adaptive-background.png`:

  - The generator will use this file to create all required adaptive launcher-icon background layers for Android 8.0 and above.
  - Updates same directories as the legacy icon.

- `android-adaptive-foreground.png`:

  - The generator will use this file to create all required adaptive launcher-icon foreground layers for Android 8.0 and above.
  - Updates same directories as the legacy icon.

- `android-legacy.png`:

  - The generator will use this file to create all required legacy launcher-icons for Android 7.1 and below.
  - Automatically transforms the icon to add necessary padding and radius. Note, when creating your custom input file, do not include the padding or radius.
  - (vanilla) Updates `./android/app/src/main/res/` including the `mipmap-anydpi-v26/ic_launcher.xml`.
  - (expo) Updates `./assets/images/` including the root file `./app.json`.

- `ios-universal.png`:

  - The generator will use this file to create all required app-icons for iOS.
  - (vanilla) Updates `./ios/**/Images.xcassets/AppIcon.appiconset/` including `Content.json`.
  - (expo) Updates `./assets/images/` including the root file `./app.json`.

When updating the template files, please note that names must stay the same as well as the size (1024x1024px). A Sketch template file can be [found here](https://github.com/infinitered/ignite/files/8576614/ignite-app-icon-template.zip) - just make your changes, hide the grids, then click File -> Export.

```
npx ignite-cli generate app-icon ios
```

By default, the generator will exit if the input-files in your templates folder match signatures with those of the default Ignite app-icons - this is done to encourage you to make actual changes to the icons before generating. However, if you want to override your application's app-icons with those of Ignite's, you can first reset your app-icon templates folder with `npx ignite-cli g app-icon --update` and then regenerate the app-icons with the `--skip-source-equality-validation` flag.

### Splash Screen generator

Similar to app/launcher icons, the splash-screen is somewhat tricky to configure and manage due to platform (and OS version) differences. Therefore, splash-screens come preconfigured in the latest versions of Ignite boilerplate and a handy generator is provided to aid with customization.

Unlike the app/launcher generator however, only a single input file is needed. This file, called `logo.png`, can be found and customized in the following templates folder: `ignite/templates/splash-screen`.

The generator requires a single parameter for the splash-screen's background color (in hex format).

```
npx ignite-cli generate splash-screen FF0000
// or
npx ignite-cli generate splash-screen "#FF0000"
// or
npx ignite-cli generate splash-screen fff
```

The generator will modify the `./assets/images/` and attempt to update `./app.json`. However, if your project is configured to use `app.config.js` or `app.config.ts`, the config changes will be output in the console for you to make them manually. You can read more about Expo's dynamic configuration [here](https://docs.expo.dev/workflow/configuration/#dynamic-configuration-with-appconfigjs).

Logo size transformations are predetermined based on platform. The defaults are meant to work in _most_ cases. However, you can adjust the logo transformation size according to your needs by using flags:

```
npx ignite-cli generate splash-screen FF0000 --ios-size=150 --android-size=180
```

A few notes about sizes. iOS size has no upper limit, so be careful with the value. Android has an upper limit of `288` as defined in [Android docs](https://developer.android.com/guide/topics/ui/splash-screen#splash_screen_dimensions). For Expo (both Android and iOS), custom sizes will be observed; however, due to Expo's config requirements, the splash-screen assets are generated with padding and attempt to fill the screen.

Lastly, the splash-screen generator will exit if your input file has not been modified. The same source equality check, as the one on the app-icon generator, will encourage you to make customizations before using the generator (see the `--skip-source-equality-validation` section above).

## CLI Options

### `--case`

The default filename format is PascalCase (`--case auto` or `--case pascal`), based on the name you pass in to the generate command. For example:

`npx ignite-cli@latest g screen Episodes` will generate `EpisodesScreen.tsx` in the case of the default generator template `NAMEScreen.tsx`.

This `--case` switch specifies the generated filenames (`NAME` in the filename of your template) will be how you pass it in. For example:

`npx ignite-cli@latest g screen log-in` will generate the following outputs given their template name:

| --case       | tpl filename       | generated filename |
| ------------ | ------------------ | ------------------ |
| auto, pascal | NAMEScreen.tsx.ejs | LogInScreen.tsx    |
| camel        | NAMEScreen.tsx.ejs | logInScreen.tsx    |
| snake        | NAMEScreen.tsx.ejs | log_in_screen.tsx  |
| kebab        | NAMEScreen.tsx.ejs | log-in-screen.tsx  |
| none         | NAMEScreen.tsx.ejs | log-in.tsx         |
| auto, pascal | NAME.tsx.ejs       | LogIn.tsx          |
| camel        | NAME.tsx.ejs       | logIn.tsx          |
| snake        | NAME.tsx.ejs       | log_in.tsx         |
| kebab        | NAME.tsx.ejs       | log-in.tsx         |
| none         | NAME.tsx.ejs       | log-in.tsx         |

### `--dir`

Specifies the output path for the generated files. This will override the default path of `app/` (Ignite's path where all app code lives at the time of this writing) and any `destinationDir:` front matter that exists. This is useful in the case of file-based routing navigation systems, such as [Expo Router](https://docs.expo.dev/router/introduction/).

## Customizing generators

You should feel free to make the provided templates your own! Just update the files in the `./ignite/templates/*` folders, and any generated files will then use your updated files. Read more in the [Generator Templates](./Generator-Templates.md) documentation.

## Making your own generators

Your generators live in your app, in `./ignite/templates/*`. To make a new generator, go look at the ones that are there when you start your app. You'll see that they have `*.ejs` files (which get interpreted when you generate them).

Read more about making your own generators in the [Generator Templates](./Generator-Templates.md) documentation.

## Updating generators

You may want to update your generators to the latest version of Ignite.

Just run `npx ignite-cli update <type>` or `npx ignite-cli update --all` from the root folder of your project to copy over the latest generators from Ignite to your project.

⚠️ Note that this will remove any customizations you've made, so make sure to make a commit first so you can roll it back!

## A Note About Windows

If you are noticing upon using the generator for a source file (such as a screen or model) that front matter is not removed from the newly created file, it could be that the End of Line Sequence is misconfigured. Ignite tries to take care of this on its own, but sometimes your machine will not have a proper CLI utility such as `unix2dos` installed (this usually comes with Git).

In this case, you can open VS Code (or another IDE) and convert the EOL characters for all `ejs` files in the `ignite/templates` directory. Then run the generator command again and it should create the new files properly.

================
File: docs/concept/MobX-State-Tree.md
================
---
sidebar_position: 125
---

# Why MobX-State-Tree?

If you've used Ignite Andross (the first Ignite stack), you know we formerly used Redux for state management, as does much of the community. However, we encountered some pain points with Redux so went in search of a different solution to meet our needs and landed on `mobx-state-tree` (also known as "MST"). We find that it’s a great middle-ground between completely structured (like `redux`) and completely freestyle (like `mobx`). It brings more than just state-management to the table as well (such as dependency injection, serialization, and lifecycle events).

### Some Highlights of MST

MST is...

- Intuitive
  - With concepts like `props` and `actions`, it feels familiar for React developers
  - Updating your data means calling functions on objects, rather than dispatching actions.
  - Feels similar to relational databases, with concepts like `identifiers` (primary keys), `references` (foreign keys), and `views` (calculated fields)
- Streamlined
  - No more `actionTypes`, `actionCreators`, or `reducers`
  - You don't have to declare your usage intentions with `mapStateToProps`; they are inferred
  - Side-effects are built-in; no need for 3rd party libraries like `redux-saga`, `redux-observable`, or `redux-thunk`
  - Immutability is built-in - no need for `immutable.js` or `seamless-immutable`
  - `types.compose` and `model.extend` allow for easy code-sharing of common patterns
- More than state management
  - Lifecycle hooks like `afterCreate`, `preProcessSnapshot`, and `beforeDestroy` let you have control over your data at various points in its lifecycle
- Performant
  - Round-trip store writes are much faster
  - Computed values (views) are only calculated when needed
  - `mobx-react-lite` makes React "MobX-aware" and only re-renders when absolutely necessary
- Customizable
  - MST ships with pre-built middlewares, including one which allows for [Redux interoperability](https://github.com/mobxjs/mobx-state-tree/blob/master/packages/mst-middlewares/README.md#redux). These middlewares can also serve as examples to create your own!

### Downsides

We also recognize no state management solution is perfect. MST has some known downfalls:

- Integration with TypeScript is clunky at times. MST's own typing system is sometimes at odds with what TypeScript wants
- `mobx` and `mobx-state-tree` both seem to have "magic" or "sorcery" that makes issues less straightforward to debug because you don't always have a clear picture of what's happening (but using [Reactotron](https://github.com/infinitered/reactotron), which has `mobx-state-tree` support built-in, helps a lot). The [MobX docs](https://mobx.js.org/) can also help illuminate some of the magic.
- The user base is small, so finding help on GitHub or Stack overflow is less convenient (however, the [Infinite Red Slack Community](http://community.infinite.red), as well as the [MobX-State-Tree GitHub Discussions group](https://github.com/mobxjs/mobx-state-tree/discussions) are both very helpful)
- Fatal errors are sometimes too-easily triggered and error messages can be verbose and hard to grok
- The API has a large surface area and the docs tend to be technical and unfriendly, although work is ongoing improving them all the time.

### Remove MST Option

We understand that state management is a highly opinionated topic with various options available. To accommodate this, we've added an option in Ignite CLI to remove MobX-State-Tree if you choose so! When Igniting a new project, provide `--state=none` to remove MobX-State-Tree code from the boilerplate. This option only works when also removing demo code.

```
npx ignite-cli@latest new PizzaApp --removeDemo=true --state=none
```

## Learning MobX-State-Tree

MobX and MobX-State-Tree can be a lot to learn if you're coming from Redux, so here are a few of our favorite resources to learn the basics:

- Be sure to check out the official [Getting Started](https://mobx-state-tree.js.org/intro/getting-started) guide for MobX-State-Tree.

- There is also a free [egghead.io course](https://egghead.io/courses/manage-application-state-with-mobx-state-tree).

- For a great explanation and walkthrough of the basics, check out [State Management with MobX-State-Tree](https://medium.com/react-native-training/state-management-with-mobx-state-tree-373f9f2dc68a) by React Native Training.

- And for more in-depth reading, the [official documentation](https://github.com/mobxjs/mobx-state-tree/blob/master/README.md) is a great resource.

- The official docs for [MobX](https://mobx.js.org/) are another important resource, since MST is built on MobX.

- For help from real people in the community, make sure to check out the [Infinite Red Community Slack](https://community.infinite.red) as well as the [MobX-State-Tree GitHub Discussions group](https://github.com/mobxjs/mobx-state-tree/discussions).

- To see example code bases using Ignite (and MST), check out these repositories:
- https://github.com/robinheinze/ignite-trivia (based on [this tutorial](https://shift.infinite.red/creating-a-trivia-app-with-ignite-bowser-part-1-1987cc6e93a1) by @robinheinze)
- https://github.com/jamonholmgren/PlayerPopularity (simple implementation)
- https://github.com/jamonholmgren/TrailBlazers (simple implementation with hooks)
- https://github.com/infinitered/ChainReactApp2019 (more in-depth implementation)

================
File: docs/concept/Styling.md
================
---
sidebar_position: 80
---

# Styling Ignite apps

Ignite's approach to styling individual components is, like many other things in Ignite, straightforward and direct.

If you're looking to set app-wide styles such as fonts/typography or colors, check out the [Theming](../boilerplate/app/theme/Theming.md) documentation.

We don't use `StyleSheet.create()` as a general rule, as it doesn't provide any real benefits over bare objects and functions.

We instead use a strategy of bare JS objects and functions that take a theme parameter, colocated with our components (usually below the component in the file), prefixed with `$`, and typed with TypeScript:

```tsx
import { View, type ViewStyle } from "react-native"
import { useAppTheme } from "@/utils/useAppTheme"

const MyComponent = () => {
  const { themed } = useAppTheme()
  return (
    <View style={themed($container)}>
      <View style={$plainObjectStyle} />
    </View>
  )
}

const $container: ThemedStyle<ViewStyle> = (theme) => ({
  flex: 1,
  backgroundColor: theme.colors.background,
  paddingHorizontal: theme.spacing.small,
})

const $plainObjectStyle: ViewStyle = {
  marginBottom: 20,
}
```

We use [components with presets](../boilerplate/app/components/Components.md) to share styles across our whole app.

With this strategy, you can tell if a variable is a style when it has the `$` prefix. You can also spread in other styles to compose styles:

```tsx
const $bold: TextStyle = {
  fontWeight: "bold",
}
const $larger: TextStyle = {
  fontSize: 22,
}
const $title: TextStyle = {
  ...$bold,
  ...$larger,
}
```

## Sharing Styles via Presets

Most of the [components](../boilerplate/app/components/Components.md) we include with Ignite include a `preset` property:

```tsx
<View preset="heading" text="My Header" />
```

Presets are defined in the component file itself, usually something like this:

```tsx
type Presets = "default" | "bold" | "heading" | "subheading"
const $presets: Record<Presets, ThemedStyleArray<TextStyle>> = {
  default: [$baseStyle],
  bold: [$baseStyle, $fontWeightStyles.bold],
  heading: [$baseStyle, $sizeStyles.xxl, $fontWeightStyles.bold],
  subheading: [$baseStyle, $sizeStyles.lg, $fontWeightStyles.medium],
}
```

These presets are usually composed of other styles, using arrays (which React Native will properly merge).

So, let's say we want a button that is a destructive action. We might add a "destructive" preset to the Button component.

The preset might look like this:

```tsx
const $warning: ThemedStyle<ViewStyle> = (theme) => ({
  backgroundColor: theme.colors.alert,
  color: "white",
  padding: theme.spacing.lg,
})

const $viewPresets: Record<Presets, ThemedStyle<ViewStyle>> = {
  destructive: [$baseViewStyle, $warning],
}
```

You can then use it with your Button like this:

```tsx
<Button
  text="Delete"
  // set the preset here
  preset="destructive"
  onPress={() => thisItem.destroy()}
/>
```

================
File: docs/concept/Testing.md
================
---
sidebar_position: 100
---

# Testing Ignite Apps

At Infinite Red, we want confidence that the code we are shipping isn't breaking the experience for our clients' users.

Our philosophy is roughly based on the following idea from Guillermo Rauch:

> Write tests. Not too many. Mostly integration.

This isn't a hard and fast rule, but it does express our approach fairly well.

## Maestro Testing

We provide an [Ignite Cookbook recipe](https://ignitecookbook.com/docs/recipes/MaestroSetup) to help explain how to get started and run Maestro tests once you have ignited your app

## Unit Testing

> Unit tests cover the smallest parts of code, like individual functions or classes.

-- <cite>[React Native docs](https://reactnative.dev/docs/testing-overview#unit-tests), under [CC By 4.0](https://creativecommons.org/licenses/by/4.0/)</cite>

### Test Structure

In Ignite, we include unit tests for pure functions, such as models or utility functions.

Ignite uses Jest as our test runner. Jest tests are written using `it` or `test` statements, which take a describe of the test, and a function to execute the test code.

Then, inside the test function, we can make "assertions", or what we expect a value to be using the `expect` function. We pass the value as the first argument to the `expect` function, then we use one of the "matcher" methods on `expect`, such as `.toBe` to describe what the value should match.

[The React Native doc](https://reactnative.dev/docs/testing-overview#unit-tests) provide the following example for a unit test:

```ts
it("given a date in the past, colorForDueDate() returns red", () => {
  const input = colorForDueDate("2000-10-20")
  expect(input).toBe("red")
})
```

Jest functions like `it`, `test`, `expect`, and more are loaded globally by the Jest test runner, so you don't need to import them.

### Best Practices

> When writing a test, do your best to make sure that your tests > include the following information:
>
> - Given - some precondition
> - When - some action executed by the function that you’re testing
> - Then - the expected outcome
>   This is also known as AAA (Arrange, Act, Assert).

-- <cite>[Structuring Tests in React Native Docs](https://reactnative.dev/docs/testing-overview#structuring-tests)</cite>

You can read more about how to best practices for creating tests in the [Structuring Tests](https://reactnative.dev/docs/testing-overview#structuring-tests) section of the React Native docs.

### Writing Tests

To write your own tests, create a `.test.ts` file within the `app` or `test` directory.

Then run `yarn test` to run all unit tests using Jest.

When writing tests, you can also run Jest in watch mode by running `yarn test:watch`. This will start a long running Jest process, that re-runs your tests on save in your editor. This is useful for iterating on values and getting quick feedback about whether your changes were successful or not.

### When to write Unit Tests

The most important question to ask when writing tests is "what code should be unit tested?" Not every line of code will benefit from a unit test. Typically, you'll want a unit test when you have code that can be run without external dependencies (like an API) that has some non-trivial logic.

- **complicated regexes**: for many developers, regex's only make sense as you are writing them. Testing with a series of valid and invalid inputs can help ensure that they work as intended for future developers.
- **nested if/else statements**: if you rely heavily on a function with a lot of if/else statements, it can be helpful to have tests to make sure that you can visit each condition. Often times when we have more than a handful of conditionals, it can become impossible to visit all of them without realizing it.
- **validation functions**: often times we may write functions like `isJson()` to validate that a value is a specific shape. If critical parts of our code rely on the correctness of this function, we want to test that code!

## Mocking

However, often our code is not entirely written as pure functions. Most apps have side effects like making network requests, calling native modules, or reaching for global objects.

In integration tests, we can set up a suitable testing environment to handle these side effects.

But in unit tests, where we want to test an isolated piece of code, another option is to provide mocks for these external dependencies.

Jest provides a variety of mocking strategies for our code:

### Mock Functions

You can create a mock callback function in Jest like so:

```ts
// take the input value, and add 42
const mockCallback = jest.fn((x) => 42 + x)
```

This callback can be called like a normal function

```ts
const added = [0, 1].map(mockCallback)
```

But it also has a variety of properties added to it, such as `.mock`, which you can assert against later in tests.

```ts
// The mock function is called twice, once for each item in the array
expect(mockCallback.mock.calls.length).toBe(2)
```

This particular example from the [official Jest docs](https://jestjs.io/docs/mock-functions#using-a-mock-function). You can read more about about [what other properties are available on the `.mock` property](https://jestjs.io/docs/mock-functions#mock-property) as well at the Jest docs.

### Mock Modules

Testing code that touches other libraries such as `axios` can be challenging, because we need to rely on the network for what gets returned from users.

```tsx
import { View, Text } from "react-native"
import axios from "axios"

export const getUsers = () => axios.get("/users").then((res) => res.data)
```

One way to solve this, is by mocking the `axios` library to return a static list of users, so that we can reliably get the same information in our tests.

```ts
import axios from "axios"
import { getUsers } from "./users"

jest.mock("axios")

test("should fetch users", () => {
  const users = [{ name: "Bob" }]
  const res = { data: users }

  axios.get.mockImplementation(() => Promise.resolve(res))

  getUsers().then((data) => {
    expect(data).toEqual(users)
  })
})
```

This example is derived from the the [Mocking Modules](https://jestjs.io/docs/mock-functions#mocking-modules) section of the Jest docs, where you can read about more sophisticated use cases.

### React Native Modules

In addition to regular Javascript libraries, you can also mock out native modules in React Native. Using the following syntax

```
jest.mock('react-native-video', () => 'Video');
```

The first argument of `jest.mock` is the name of the module want to mock, but you can also pass a second argument to provide a function that returns the module.

In this example, this will return a default export.

This example is derived from [Testing React Native](https://jestjs.io/docs/tutorial-react-native#mock-native-modules-using-jestmock) section of the Jest docs, where you can read more.

## Resources

### Libraries

There are a variety of testing libraries available in React Native that you may find useful to add to your Ignite app

- [React Native Testing Library](https://callstack.github.io/react-native-testing-library/) - port of @testing-library/react for React Native. Useful for unit testing components.
- [Detox](https://wix.github.io/Detox/) and [Appium](https://appium.io/) - alternatives for integration testing to Maestro.

### Relevant Reading

- [React Native docs on Testing](https://reactnative.dev/docs/testing-overview)
- [Testing React Native Apps with Jest](https://jestjs.io/docs/tutorial-react-native)
- [Why Maestro?](https://maestro.mobile.dev/#why-maestro)
- [Kent C. Dodds articles on Testing](https://kentcdodds.com/blog?q=test)

================
File: docs/concept/TypeScript.md
================
---
sidebar_position: 140
---

# TypeScript

We find that TypeScript streamlines the developer experience by catching errors _before_ you hit refresh on that simulator, and prevents costly bugs by enforcing type safety.

In Ignite, TypeScript is fully set up, so if you know TS, all you need to do is start coding!

## Resources

If you are new to TypeScript, here are some of our favorite resources:

- [TypeScript in 5 minutes](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) for a quick read
- [TypeScript in 50 minutes](https://youtu.be/WBPrJSw7yQA) for a longer watch
- [Execute Program -- TypeScript course](https://www.executeprogram.com/course/typescript) -- free course by Gary Bernhardt
- [TypeScript and VSCode](https://code.visualstudio.com/docs/typescript/typescript-tutorial) for awesome developer tools
- [Official Docs](https://www.typescriptlang.org/docs/home.html)

================
File: docs/concept/Upgrades.md
================
## Upgrading

It's important to stay up-to-date with React Native updates. Luckily, we can bank on Expo having done this work for us. If you're letting Expo manage your native code for you, just run the following:

```bash
npx expo install expo@latest
npx expo install --fix
```

And that's it! If you've added native dependencies outside the Expo ecosystem, you'll want to run prebuild again:

```bash
npx expo prebuild --clean --no-install
```

And finally, if you're managing native code yourself, check out these tools:

- [React Native Upgrade Helper](https://react-native-community.github.io/upgrade-helper/) great web based tool
- [rn-diff-purge](https://github.com/react-native-community/rn-diff-purge)

It's less important to keep your Ignite app updated, but you might want to keep pace with Infinite Red's latest changes. To do that, [@nirre7](https://github.com/nirre7) built an amazing tool:

- [ignite-diff-purge](https://github.com/nirre7/ignite-diff-purge) To help you see the diffs between different versions. The first diff is from 5.4.1 (ignite-bowser) and then continues with Ignite CLI boilerplate
- [ignite-expo-diff-purge](https://github.com/nirre7/ignite-expo-diff-purge) To help you see the diffs between different versions. The first diff is from 5.4.1 (ignite-bowser with Expo) and then continues with Ignite CLI boilerplate with Expo
- [ignite-bowser-diff-purge](https://github.com/nirre7/ignite-bowser-diff-purge) To help you see the diffs between different versions of the old [ignite-bowser](https://github.com/infinitered/ignite-bowser) boilerplate

================
File: docs/expo/CNG.md
================
---
sidebar_position: 30
---

# Expo Continuous Native Generation (CNG)

When you want native platform code integrations, we recommend using the Expo CNG workflow with Ignite. This is one of the options when you spin up a new Ignite app.

CNG (and Expo Prebuild) works well for almost any app. It's a great middle ground between Expo Go and the "do it yourself" (manual) workflow.

1. You don't have to work with Gradle and CocoaPods directly
2. Upgrades are much, much easier, since you're not working around your native code customizations
3. There are config plugins for many popular libraries, and custom config plugins are possible to write

You can learn more about Expo CNG in [Expo's docs](https://docs.expo.dev/workflow/continuous-native-generation/).

================
File: docs/expo/DIY.md
================
---
sidebar_position: 40
---

# Manual Workflow

If you don't want to use [Expo CNG](./CNG.md), you can manage the native code yourself via the manual workflow (`--workflow manual`). This is one of the options when you spin up a new Ignite app.

:::tip
Implementation detail that you probably didn't need to know: it's still a "CNG" workflow under the hood, but we generate the native ios and android folders for you -- and then you never run CNG again. Instead, you customize those native projects directly yourself. Hence, the manual part (formerly "DIY").
:::

## Why would I want to use the manual workflow?

We generally don't recommend it. It's mostly available for developers who are not interested in using Expo CNG / Prebuild and would rather maintain their own native code directly.

================
File: docs/expo/EAS.md
================
---
sidebar_position: 50
---

# Expo Application Services (EAS)

EAS is our favorite way to build and deploy Ignite apps. It's a cloud build service that allows you to build your app in the cloud, without Xcode or Android Studio.

You can learn more about EAS here: [https://expo.dev/eas](https://expo.dev/eas)

Ignite apps come with an `eas.json` configuration file that looks something like this:

```json
{
  "cli": {
    "version": ">= 3.15.1"
  },
  "build": {
    "development": {
      "extends": "production",
      "distribution": "internal",
      "android": {
        "gradleCommand": ":app:assembleDebug"
      },
      "ios": {
        "buildConfiguration": "Debug",
        "simulator": true
      }
    },
    "development:device": {
      "extends": "development",
      "distribution": "internal",
      "ios": {
        "buildConfiguration": "Debug",
        "simulator": false
      }
    },
    "preview": {
      "extends": "production",
      "distribution": "internal",
      "ios": { "simulator": true },
      "android": { "buildType": "apk" }
    },
    "preview:device": {
      "extends": "preview",
      "ios": { "simulator": false }
    },
    "production": {}
  },
  "submit": {
    "production": {}
  }
}
```

It's preconfigured to work with Ignite apps, but you can customize it to your liking.

================
File: docs/expo/Expo-and-Ignite.md
================
---
sidebar_position: 10
---

# Expo and Ignite

![ignite+expo](https://miro.medium.com/max/1400/1*Ii4JuTWmVLeVBcqFyX3v5g.jpeg)

> Expo is the easiest, nicest experience for Ignite apps. And I am convinced Ignite (especially version 9) is the nicest boilerplate for Expo apps you can possibly get. - Jamon Holmgren

If you're not familiar with [Expo](https://expo.dev), it's an open-source platform for making universal native apps for Android, iOS, and the web with [React Native](https://reactnative.dev). It's essentially a series of layers built around React Native. Here's a partial list of what Expo is:

- [Expo Go](https://expo.dev/client) -- an app for quickly previewing React Native apps without building them
- [EAS](https://eas.dev) -- a build & distribution service for mobile apps, especially RN
- A _lot_ of high quality, well-maintained [React Native libraries](https://github.com/expo/expo)
- Several integrated services, such as push notifications, over-the-air updates, [and much more](https://docs.expo.dev/)

## Overview

In previous versions of Ignite (versions 6 and 7), you could pass in a `--expo` flag to make the resulting generated app "Expo-ready". In version 8 (code-named "Maverick") we made the boilerplate "Expo-ready" by default -- but without locking you into using Expo Go or Expo's services if you don't want to.

In version 9 (code-named "Exp[ress]o") we let Expo drive the native template initially. If you want to take over the native template and maintain all native code yourself, you are free to do so! However, if you want to opt-in to [Continuous Native Generation](https://docs.expo.dev/workflow/continuous-native-generation/) you can modify/extend the native template via Expo's [Config Plugins](https://docs.expo.dev/guides/config-plugins/). The Ignite template includes a Config Plugin that adds in a bug fix for `expo-splash-screen` when on Android 12.

Now in version 10 (or Ignite X), we no longer support the option for the Expo Go during setup. This is due to Expo's recommendation for building and distributing production applications. You can read more [here](https://docs.expo.dev/develop/tools/#expo-go). This allowed for us to bring in some better dependencies to the boilerplate, which would not have been supported under Expo's ecosystem (such as `react-native-mmkv`). You can of course convert your Ignite project back to being [Expo Go compatible](https://ignitecookbook.com/docs/recipes/SwitchBetweenExpoGoCNG).

```
# Spin up a new app
npx ignite-cli new PizzaApp
cd PizzaApp
yarn ios
yarn android
```

### How it works

Ignite comes with the lightweight `expo` package pre-installed and configured, which enables use of any of Expo's great third-party libraries, such as `expo-device`, `expo-font`, `expo-splash-screen`, and others -- even if you aren't running it in Expo Go or a "managed app".

================
File: docs/Guide.md
================
---
sidebar_position: 2
---

# Getting Started Guide

## What is Ignite?

Ignite is best described as "[Infinite Red](https://infinite.red)'s favorite way to build React Native apps". It's a CLI and a boilerplate React Native project dating back to the early days of React Native (2016), as well as some command-line generators. It's also a community of like-minded developers who like the way we do things!

In short -- if you use Ignite to start your next React Native project, you're using a battle-tested, familiar stack.

### Ignite CLI

In order to start a new Ignite project, you can use the CLI. No need to install it globally as it works great with `npx`:

```bash
npx ignite-cli@latest new PizzaApp
```

It'll walk you through several prompts to configure your package manager, navigation library and state management. Or you can simply take all the defaults via `--yes` and jump right into the demo application.

Once it's up and running, you can use the Ignite CLI to [generate](./concept/Generators.md) components, screens, MST models, and more.

Running into errors? have a look at [Troubleshooting](./cli/Troubleshooting.md)

### Ignite Boilerplate

Your new Ignite project comes with a full stack of useful libraries, pre-set up for you so you can start coding. Some of the following are optional, but this list details the default options:

- React Native
- React Navigation
- MobX-State-Tree [(Why not Redux?)](./concept/MobX-State-Tree.md)
- MobX-React-Lite
- TypeScript
- React Native MMKV (integrated with MST for restoring state)
- apisauce (to talk to REST servers)
- Reactotron-ready (and pre-integrated with MST)
- Supports Expo (and Expo web) out of the box
- About a dozen prebuilt [components](./boilerplate/app/components/Components.md) to build out your UI with
- And more!

## Where do I start?

First, spin up the app and make sure you can see the initial screen. If you have any issues, please report them.

Once it's running, you'll want to get familiarized with the following concepts:

### Navigation

We use React Navigation v6 in the current version of Ignite. You'll find any navigators in `./app/navigators`, with the `AppNavigator.tsx` being the primary one.

There's also a `navigationUtilities.ts` file which provides some utility functions we find useful in building apps, such as `getActiveRouteName`, `useBackButtonHandler` and `useNavigationPersistence`.

Learn more in our [Navigation](./boilerplate/app/navigators/Navigation.md) documentation.

### Components

Ignite comes with some prebuilt, flexible, and customizable components. Unlike most component libraries, it's not built to drop in out of the box, but rather with custom design in mind (you do have a nice, custom design, don't you?)

Ignite works fine with other component libraries, but the built-in component system works the best for custom-designed apps.

Check out the [Components](./boilerplate/app/components/Components.md) documentation.

### Testing

Ignite is pre-configured to use Jest for unit tests and [React Native Testing Library](https://callstack.github.io/react-native-testing-library/) for component tests.

Ignite includes samples of UI end-to-end tests using [Maestro](https://maestro.mobile.dev/). See our [Ignite Cookbook recipe](https://ignitecookbook.com/docs/recipes/MaestroSetup) for setup and walkthrough of the test samples or check out Maestro's docs on [Installing Maestro](https://maestro.mobile.dev/getting-started/installing-maestro) to run the flows.

You can learn more about why we chose these tests and how to use them in the [Testing](./concept/Testing.md) docs.

### Styling

Ignite's approach to styling is, like many other things in Ignite, straightforward and blunt.

We don't use `StyleSheet.create()` as a general rule, as it doesn't provide any real benefits over bare objects.

We instead use a strategy of constants, co-located with our components, camelCase and prefixed with `$`, and typed with TypeScript:

```tsx
import { View, ViewStyle } from "react-native"
import { useAppTheme } from "@/utils/useAppTheme"
import type { ThemedStyle } from "@/theme"

// This is a themed style that you must wrap with `themed()` to pass the style object.
const $container: ThemedStyle<ViewStyle> = ({ colors }) => ({
  flex: 1,
  backgroundColor: colors.palette.bgColor,
})

// This is a non-themed style
const $innerView: ViewStyle{
  backgroundColor: '#fff',
  alignItems: "center",
}

const MyComponent = () => {
  const { themed } = useAppTheme()
  return (
    <View style={themed($container)}>
    <View style={$innerView}>...</View>
    </View>
  )
}
```

Very often, we use [components with presets](./boilerplate/app/components/Components.md) to share styles across our whole app.

Read more about styling in the [Styling](./concept/Styling.md) docs.

================
File: eas.json
================
{
  "cli": {
    "version": ">= 3.15.1"
  },
  "build": {
    "development": {
      "extends": "production",
      "distribution": "internal",
      "android": {
        "gradleCommand": ":app:assembleDebug"
      },
      "ios": {
        "buildConfiguration": "Debug",
        "simulator": true
      }
    },
    "development:device": {
      "extends": "development",
      "distribution": "internal",
      "ios": {
        "buildConfiguration": "Debug",
        "simulator": false
      }
    },
    "preview": {
      "extends": "production",
      "distribution": "internal",
      "ios": { "simulator": true },
      "android": { "buildType": "apk" }
    },
    "preview:device": {
      "extends": "preview",
      "ios": { "simulator": false }
    },
    "production": {}
  },
  "submit": {
    "production": {}
  }
}

================
File: ignite/templates/component/NAME.tsx.ejs
================
---
destinationDir: app/components/<%= props.subdirectory %>
patch:
  path: "app/components/index.ts"
  append: "export * from \"./<%= props.subdirectory %><%= props.pascalCaseName %>\"\n"
  skip: <%= props.skipIndexFile %>
---
import { StyleProp, TextStyle, View, ViewStyle } from "react-native"
import { useAppTheme } from "@/utils/useAppTheme"
import type { ThemedStyle } from "@/theme"
import { Text } from "@/components/Text"

export interface <%= props.pascalCaseName %>Props {
  /**
   * An optional style override useful for padding & margin.
   */
  style?: StyleProp<ViewStyle>
}

/**
 * Describe your component here
 */

export const <%= props.pascalCaseName %> = (props: <%= props.pascalCaseName %>Props) => {
  const { style } = props
  const $styles = [$container, style]
  const { themed } = useAppTheme();

  return (
    <View style={$styles}>
      <Text style={themed($text)}>Hello</Text>
    </View>
  )

}

const $container: ViewStyle = {
  justifyContent: "center",
}

const $text: ThemedStyle<TextStyle> = ({ colors, typography }) => ({
  fontFamily: typography.primary.normal,
  fontSize: 14,
  color: colors.palette.primary500,
})

================
File: ignite/templates/navigator/NAMENavigator.tsx.ejs
================
---
destinationDir: app/navigators
patch:
  path: "app/navigators/index.ts"
  append: "export * from \"./<%= props.pascalCaseName %>Navigator\"\n"
  skip: <%= props.skipIndexFile %>
---
import { createNativeStackNavigator } from "@react-navigation/native-stack"
import {
  WelcomeScreen
} from "@/screens"

export type <%= props.pascalCaseName %>NavigatorParamList = {
  Demo: undefined
}

const Stack = createNativeStackNavigator<<%= props.pascalCaseName %>NavigatorParamList>()
export const <%= props.pascalCaseName %>Navigator = () => {
  return (
    <Stack.Navigator screenOptions={{ cardStyle: { backgroundColor: "transparent" }, headerShown: false, }}>
      <Stack.Screen name="Demo" component={WelcomeScreen} />
    </Stack.Navigator>
  )
}

================
File: ignite/templates/screen/NAMEScreen.tsx.ejs
================
---
destinationDir: app/screens
patches:
- path: "app/screens/index.ts"
  append: "export * from \"./<%= props.pascalCaseName %>Screen\"\n"
  skip: <%= props.skipIndexFile %>
- path: "app/navigators/AppNavigator.tsx"
  replace: "// IGNITE_GENERATOR_ANCHOR_APP_STACK_PARAM_LIST"
  insert: "<%= props.pascalCaseName %>: undefined\n\t// IGNITE_GENERATOR_ANCHOR_APP_STACK_PARAM_LIST"
- path: "app/navigators/AppNavigator.tsx"
  replace: "{/* IGNITE_GENERATOR_ANCHOR_APP_STACK_SCREENS */}"
  insert: "<Stack.Screen name=\"<%= props.pascalCaseName %>\" component={Screens.<%= props.pascalCaseName %>Screen} />\n\t\t\t{/* IGNITE_GENERATOR_ANCHOR_APP_STACK_SCREENS */}"
  skip: <%= props.skipIndexFile %>
---
import { FC } from "react"
import { ViewStyle } from "react-native"
import { AppStackScreenProps } from "@/navigators"
import { Screen, Text } from "@/components"
// import { useNavigation } from "@react-navigation/native"

interface <%= props.pascalCaseName %>ScreenProps extends AppStackScreenProps<"<%= props.pascalCaseName %>"> {}


export const <%= props.pascalCaseName %>Screen: FC<<%= props.pascalCaseName %>ScreenProps> = () => {

  // Pull in navigation via hook
  // const navigation = useNavigation()
  return (
    <Screen style={$root} preset="scroll">
      <Text text="<%= props.camelCaseName %>" />
    </Screen>
  )

}

const $root: ViewStyle = {
  flex: 1,
}

================
File: index.tsx
================
import "@expo/metro-runtime" // this is for fast refresh on web w/o expo-router
import { registerRootComponent } from "expo"

import { App } from "@/app"

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App)

================
File: jest.config.js
================
/** @type {import('@jest/types').Config.ProjectConfig} */
module.exports = {
  preset: "jest-expo",
  setupFiles: ["<rootDir>/test/setup.ts"],
}

================
File: metro.config.js
================
/* eslint-env node */
// Learn more https://docs.expo.io/guides/customizing-metro
const { getDefaultConfig } = require("expo/metro-config")

/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname)

config.transformer.getTransformOptions = async () => ({
  transform: {
    // Inline requires are very useful for deferring loading of large dependencies/components.
    // For example, we use it in app.tsx to conditionally load Reactotron.
    // However, this comes with some gotchas.
    // Read more here: https://reactnative.dev/docs/optimizing-javascript-loading
    // And here: https://github.com/expo/expo/issues/27279#issuecomment-1971610698
    inlineRequires: true,
  },
})

// This helps support certain popular third-party libraries
// such as Firebase that use the extension cjs.
config.resolver.sourceExts.push("cjs")

module.exports = config

================
File: package.json
================
{
  "name": "app",
  "version": "0.0.1",
  "private": true,
  "main": "index.tsx",
  "scripts": {
    "compile": "tsc --noEmit -p . --pretty",
    "lint": "eslint . --fix",
    "lint:check": "eslint .",
    "patch": "patch-package",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:maestro": "maestro test .maestro/FavoritePodcast.yaml",
    "adb": "adb reverse tcp:9090 tcp:9090 && adb reverse tcp:3000 tcp:3000 && adb reverse tcp:9001 tcp:9001 && adb reverse tcp:8081 tcp:8081",
    "postinstall": "patch-package",
    "build:ios:sim": "eas build --profile development --platform ios --local",
    "build:ios:dev": "eas build --profile development:device --platform ios --local",
    "build:ios:prod": "eas build --profile production --platform ios --local",
    "build:android:sim": "eas build --profile development --platform android --local",
    "build:android:dev": "eas build --profile development:device --platform android --local",
    "build:android:prod": "eas build --profile production --platform android --local",
    "start": "expo start --dev-client",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "bundle:web": "npx expo export --platform web",
    "serve:web": "npx serve dist",
    "prebuild:clean": "npx expo prebuild --clean"
  },
  "dependencies": {
    "@expo-google-fonts/space-grotesk": "^0.2.2",
    "@expo/metro-runtime": "~4.0.0",
    "@react-navigation/native": "^6.0.2",
    "@react-navigation/native-stack": "^6.0.2",
    "@shopify/flash-list": "1.7.3",
    "apisauce": "3.0.1",
    "date-fns": "^4.1.0",
    "expo": "~52.0.7",
    "expo-build-properties": "~0.13.1",
    "expo-dev-client": "~5.0.1",
    "expo-font": "~13.0.1",
    "expo-linking": "~7.0.2",
    "expo-localization": "~16.0.0",
    "expo-splash-screen": "~0.29.10",
    "expo-status-bar": "~2.0.0",
    "expo-system-ui": "~4.0.3",
    "i18next": "^23.14.0",
    "intl-pluralrules": "^2.0.1",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-i18next": "^15.0.1",
    "react-native": "0.76.7",
    "react-native-drawer-layout": "^4.0.1",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-keyboard-controller": "^1.12.7",
    "react-native-mmkv": "^2.12.2",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-web": "~0.19.6"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@babel/preset-env": "^7.20.0",
    "@babel/runtime": "^7.20.0",
    "@testing-library/react-native": "^12.5.2",
    "@types/jest": "^29.2.1",
    "@types/react": "~18.3.12",
    "babel-jest": "^29.2.1",
    "eslint": "^8.57.0",
    "eslint-config-expo": "~8.0.1",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-react-native": "^4.1.0",
    "eslint-plugin-reactotron": "^0.1.2",
    "jest": "^29.2.1",
    "jest-expo": "~52.0.1",
    "patch-package": "^8.0.0",
    "postinstall-prepare": "1.0.1",
    "prettier": "^3.3.3",
    "react-test-renderer": "18.2.0",
    "reactotron-core-client": "^2.9.4",
    "reactotron-react-js": "^3.3.11",
    "reactotron-react-native": "^5.0.5",
    "reactotron-react-native-mmkv": "^0.2.6",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.2",
    "typescript": "~5.3.3"
  },
  "engines": {
    "node": "^18.18.0 || >=20.0.0"
  }
}

================
File: plugins/withSplashScreen.ts
================
import { ConfigPlugin, withStringsXml, AndroidConfig, withAndroidStyles } from "expo/config-plugins"

/**
 *
 * Expo Config Plugin to help address the double splash screen issue with `expo-splash-screen`
 * See more information about this issue here: https://github.com/expo/expo/issues/16084
 *
 * How it works:
 *   1) Replace the default splash screen with a transparent screen
 *   2) Set the splash screen status bar to translucent
 */
export const withSplashScreen: ConfigPlugin = (config) => {
  config = withAndroidSplashScreen(config)
  return config
}

/**
 * Android implementation of the config plugin - the only platform needed for this plugin.
 * However, it is good practice to break up your config plugins from the exported
 * function into parts by platform. For example, if it was needed, we would also
 * add `withIosSplashScreen` for the iOS implementation.
 */
const withAndroidSplashScreen: ConfigPlugin = (config) => {
  config = withCustomStylesXml(config)
  config = withCustomStringsXml(config)
  return config
}

/**
 * Modifies the `android/app/src/main/res/values/strings.xml` file to add the following string:
 *
 * <string name="expo_splash_screen_status_bar_translucent" translatable="false">true</string>
 */
const withCustomStringsXml: ConfigPlugin = (config) =>
  withStringsXml(config, (modConfig) => {
    modConfig.modResults = AndroidConfig.Strings.setStringItem(
      [
        {
          _: "true",
          $: {
            name: "expo_splash_screen_status_bar_translucent",
            translatable: "false",
          },
        },
      ],
      modConfig.modResults,
    )
    return modConfig
  })

/**
 * Modifies the `android/app/src/main/res/values/styles.xml` file to append the
 * the following to the Theme.App.SplashScreen style:
 *
 * <item name="android:windowIsTranslucent">true</item>
 */
const withCustomStylesXml: ConfigPlugin = (config) =>
  withAndroidStyles(config, async (modConfig) => {
    modConfig.modResults = AndroidConfig.Styles.assignStylesValue(modConfig.modResults, {
      add: true,
      name: "android:windowIsTranslucent",
      value: "true",
      parent: {
        name: "Theme.App.SplashScreen",
        parent: "AppTheme",
      },
    })
    return modConfig
  })

================
File: README.md
================
# Welcome to your new ignited app!

> The latest and greatest boilerplate for Infinite Red opinions

This is the boilerplate that [Infinite Red](https://infinite.red) uses as a way to test bleeding-edge changes to our React Native stack.

- [Quick start documentation](https://github.com/infinitered/ignite/blob/master/docs/boilerplate/Boilerplate.md)
- [Full documentation](https://github.com/infinitered/ignite/blob/master/docs/README.md)

## Getting Started

```bash
npm install
npm run start
```

To make things work on your local simulator, or on your phone, you need first to [run `eas build`](https://github.com/infinitered/ignite/blob/master/docs/expo/EAS.md). We have many shortcuts on `package.json` to make it easier:

```bash
npm run build:ios:sim # build for ios simulator
npm run build:ios:dev # build for ios device
npm run build:ios:prod # build for ios device
```

### `./assets` directory

This directory is designed to organize and store various assets, making it easy for you to manage and use them in your application. The assets are further categorized into subdirectories, including `icons` and `images`:

```tree
assets
├── icons
└── images
```

**icons**
This is where your icon assets will live. These icons can be used for buttons, navigation elements, or any other UI components. The recommended format for icons is PNG, but other formats can be used as well.

Ignite comes with a built-in `Icon` component. You can find detailed usage instructions in the [docs](https://github.com/infinitered/ignite/blob/master/docs/boilerplate/app/components/Icon.md).

**images**
This is where your images will live, such as background images, logos, or any other graphics. You can use various formats such as PNG, JPEG, or GIF for your images.

Another valuable built-in component within Ignite is the `AutoImage` component. You can find detailed usage instructions in the [docs](https://github.com/infinitered/ignite/blob/master/docs/Components-AutoImage.md).

How to use your `icon` or `image` assets:

```typescript
import { Image } from 'react-native';

const MyComponent = () => {
  return (
    <Image source={require('../assets/images/my_image.png')} />
  );
};
```

## Running Maestro end-to-end tests

Follow our [Maestro Setup](https://ignitecookbook.com/docs/recipes/MaestroSetup) recipe.

## Next Steps

### Ignite Cookbook

[Ignite Cookbook](https://ignitecookbook.com/) is an easy way for developers to browse and share code snippets (or “recipes”) that actually work.

### Upgrade Ignite boilerplate

Read our [Upgrade Guide](https://ignitecookbook.com/docs/recipes/UpdatingIgnite) to learn how to upgrade your Ignite project.

## Community

⭐️ Help us out by [starring on GitHub](https://github.com/infinitered/ignite), filing bug reports in [issues](https://github.com/infinitered/ignite/issues) or [ask questions](https://github.com/infinitered/ignite/discussions).

💬 Join us on [Slack](https://join.slack.com/t/infiniteredcommunity/shared_invite/zt-1f137np4h-zPTq_CbaRFUOR_glUFs2UA) to discuss.

📰 Make our Editor-in-chief happy by [reading the React Native Newsletter](https://reactnativenewsletter.com/).

================
File: test/i18n.test.ts
================
import en from "../app/i18n/en"
import { exec } from "child_process"

// Use this array for keys that for whatever reason aren't greppable so they
// don't hold your test suite hostage by always failing.
const EXCEPTIONS: string[] = [
  // "welcomeScreen:readyForLaunch",
]

function iterate(obj, stack, array) {
  for (const property in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      if (typeof (obj as object)[property] === "object") {
        iterate(obj[property], `${stack}.${property}`, array)
      } else {
        array.push(`${stack.slice(1)}.${property}`)
      }
    }
  }

  return array
}

/**
 * This tests your codebase for missing i18n strings so you can avoid error strings at render time
 *
 * It was taken from https://gist.github.com/Michaelvilleneuve/8808ba2775536665d95b7577c9d8d5a1
 * and modified slightly to account for our Ignite higher order components,
 * which take 'tx' and 'fooTx' props.
 * The grep command is nasty looking, but it's essentially searching the codebase for a few different things:
 *
 * tx="*"
 * Tx=""
 * tx={""}
 * Tx={""}
 * translate(""
 *
 * and then grabs the i18n key between the double quotes
 *
 * This approach isn't 100% perfect. If you are storing your key string in a variable because you
 * are setting it conditionally, then it won't be picked up.
 *
 */

describe("i18n", () => {
  test("There are no missing keys", (done) => {
    // Actual command output:
    // grep "[T\|t]x=[{]\?\"\S*\"[}]\?\|translate(\"\S*\"" -ohr './app' | grep -o "\".*\""
    const command = `grep "[T\\|t]x=[{]\\?\\"\\S*\\"[}]\\?\\|translate(\\"\\S*\\"" -ohr './app' | grep -o "\\".*\\""`
    exec(command, (_, stdout) => {
      const allTranslationsDefinedOld = iterate(en, "", [])
      // Replace first instance of "." because of i18next namespace separator
      const allTranslationsDefined = allTranslationsDefinedOld.map((key) => key.replace(".", ":"))
      const allTranslationsUsed = stdout.replace(/"/g, "").split("\n")
      allTranslationsUsed.splice(-1, 1)

      for (let i = 0; i < allTranslationsUsed.length; i += 1) {
        if (!EXCEPTIONS.includes(allTranslationsUsed[i])) {
          // You can add keys to EXCEPTIONS (above) if you don't want them included in the test
          expect(allTranslationsDefined).toContainEqual(allTranslationsUsed[i])
        }
      }
      done()
    })
  }, 240000)
})

================
File: test/mockFile.ts
================
export default {
  height: 100,
  width: 100,
  scale: 2.0,
  uri: "https://placecats.com/200/200",
}

================
File: test/setup.ts
================
// we always make sure 'react-native' gets included first
import * as ReactNative from "react-native"
import mockFile from "./mockFile"

// libraries to mock
jest.doMock("react-native", () => {
  // Extend ReactNative
  return Object.setPrototypeOf(
    {
      Image: {
        ...ReactNative.Image,
        resolveAssetSource: jest.fn((_source) => mockFile), // eslint-disable-line @typescript-eslint/no-unused-vars
        getSize: jest.fn(
          (
            uri: string, // eslint-disable-line @typescript-eslint/no-unused-vars
            success: (width: number, height: number) => void,
            failure?: (_error: any) => void, // eslint-disable-line @typescript-eslint/no-unused-vars
          ) => success(100, 100),
        ),
      },
    },
    ReactNative,
  )
})

jest.mock("i18next", () => ({
  currentLocale: "en",
  t: (key: string, params: Record<string, string>) => {
    return `${key} ${JSON.stringify(params)}`
  },
  translate: (key: string, params: Record<string, string>) => {
    return `${key} ${JSON.stringify(params)}`
  },
}))

jest.mock("expo-localization", () => ({
  ...jest.requireActual("expo-localization"),
  getLocales: () => [{ languageTag: "en-US", textDirection: "ltr" }],
}))

jest.mock("../app/i18n/i18n.ts", () => ({
  i18n: {
    isInitialized: true,
    language: "en",
    t: (key: string, params: Record<string, string>) => {
      return `${key} ${JSON.stringify(params)}`
    },
    numberToCurrency: jest.fn(),
  },
}))

declare const tron // eslint-disable-line @typescript-eslint/no-unused-vars

declare global {
  let __TEST__: boolean
}

================
File: test/test-tsconfig.json
================
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "allowJs": false,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "jsx": "react-native",
    "module": "es2015",
    "moduleResolution": "node",
    "noImplicitAny": false,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noUnusedLocals": false,
    "sourceMap": true,
    "target": "esnext",
    "lib": ["esnext", "dom"],
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": ["**/*.test.ts", "**/*.test.tsx"]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "allowJs": false,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "jsx": "react-native",
    "module": "es2015",
    "moduleResolution": "node",
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "sourceMap": true,
    "target": "esnext",
    "lib": [
      "esnext",
      "dom"
    ],
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./app/*"],
      "assets/*": ["./assets/*"]
    },
    "typeRoots": [
      "./node_modules/@types",
      "./types"
    ]
  },
  "extends": "expo/tsconfig.base",
  "ts-node": {
    "compilerOptions": {
      "module": "commonjs"
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules",
    "test/**/*"
  ]
}

================
File: types/lib.es5.d.ts
================
/**
 * Fixes https://github.com/microsoft/TypeScript/issues/16655 for `Array.prototype.filter()`
 * For example, using the fix the type of `bar` is `string[]` in the below snippet as it should be.
 *
 *  const foo: (string | null | undefined)[] = [];
 *  const bar = foo.filter(Boolean);
 *
 * For related definitions, see https://github.com/microsoft/TypeScript/blob/master/src/lib/es5.d.ts
 *
 * Original licenses apply, see
 *  - https://github.com/microsoft/TypeScript/blob/master/LICENSE.txt
 *  - https://stackoverflow.com/help/licensing
 */

/** See https://stackoverflow.com/a/51390763/1470607  */
type Falsy = false | 0 | "" | null | undefined

interface Array<T> {
  /**
   * Returns the elements of an array that meet the condition specified in a callback function.
   * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
   * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
   */
  filter<S extends T>(predicate: BooleanConstructor, thisArg?: any): Exclude<S, Falsy>[]
}



================================================================
End of Codebase
================================================================

</starter_template>
```

## Tarea

Tu tarea es generar una especificación técnica completa basada en la información anterior.

## Proceso de Planificación

Antes de crear la especificación final, analiza los requerimientos del proyecto y planifica tu enfoque. Envuelve tu proceso de pensamiento en etiquetas `<specification_planning>`, considerando:

- Arquitectura general de la aplicación y flujos de navegación.
- Estructura y organización del proyecto en React Native (Expo).
- Especificaciones de cada funcionalidad (pantallas, componentes, lógica).
- Diseño de pantallas, rutas y manejo de navegación (React Navigation).
- Sistema de diseño (temas, estilos, tipografía, spacing, componentes base).
- Arquitectura de componentes (organización, props, modularidad).
- Manejo del estado (MobX-State-Tree, Redux, Zustand o la librería elegida).
- Integración con servicios externos (APIs REST/GraphQL, push notifications, etc.).
- Conexión con EAS para build y deployment (entornos, variables de entorno).
- Pruebas (unitarias con Jest, tests de componentes, e2e con Maestro u otras herramientas).
- Accesibilidad (lineamientos y consideraciones).
- Internacionalización (si aplica, uso de i18n).
- Gestión de assets (imágenes, íconos, fuentes).
- Optimización de performance (lazy loading, inlineRequires, etc.).
- Estrategia de publicación (App Stores, TestFlight, Play Internal Testing).

Para cada área anterior:

- Proporciona un desglose paso a paso de lo que se debe incluir (por ejemplo, qué librerías se usarían y qué configuraciones se requieren).
- Enumera los posibles desafíos o puntos que requieran clarificación con el equipo de producto o diseño.
- Considera posibles casos extremos y planes de fallback (por ejemplo, ¿qué pasa si falla la carga de assets o si no hay internet?).

## Especificación Técnica Final (Formato Markdown)

Después de tu análisis, genera la especificación técnica final utilizando la siguiente estructura en Markdown:

```markdown
# Especificación Técnica Frontend Expo React Native - {Nombre del Proyecto}

## 1. Resumen del Sistema
- **Propósito central y alcance del frontend** (rol de la app en el dispositivo)
- **Flujos principales de usuario** (ej.: registro, login, pantallas de lista/detalle)
- **Arquitectura general** (Expo, TypeScript, etc.)

## 2. Estructura del Proyecto Expo React Native
- **Desglose detallado de la organización de carpetas** (`app/`, `components/`, `navigators/`, `screens/`, `theme/`, etc.)
- **Configuración principal** (app.json, app.config.ts, EAS, etc.)
- **Convenciones de nomenclatura**

## 3. Especificación de Funcionalidades
Para cada funcionalidad o “feature” principal:

### 3.1 {Nombre de la Funcionalidad}
- **Descripción / Historia de usuario**
- **Lista de pantallas involucradas** (si aplica)
- **Flujos o casos de uso** (navegación y lógica UI)
- **Estructura de los componentes** (propiedades, estados, eventos)
- **Manejo de errores y edge cases** (ej.: offline, inputs vacíos, etc.)
- **Integración con APIs (si aplica)**

## 4. Navegación y Rutas
### 4.1 Configuración de React Navigation
- **Stack Navigator, Tab Navigator, Drawer** (si aplica)
- **Deep Linking** (si fuera necesario)
- **Rutas y parámetros principales**

### 4.2 Ejemplos de uso de navegación
- **Cómo navegar** (ej.: `navigate`, `goBack`, `resetRoot`)
- **Rutas protegidas** (si aplica)

## 5. Sistema de Diseño y Theming
### 5.1 Paleta de colores
- **Colores primarios, secundarios**, neutrales, alertas, etc. (con códigos hex)

### 5.2 Tipografía
- **Fuentes** (familias, tamaños, pesos)
- Configuración de fuentes en Expo

### 5.3 Estilos Base y Componentes
- **Estilos globales** (espacios, tamaños)
- **Componentes reutilizables** (Button, Text, Card, Header, etc.)
- **Cómo manejar estados** (hover, focus, pressed) en RN

## 6. Arquitectura de Componentes
### 6.1 Organización
- **Carpetas** (`components/` vs. `screens/`, etc.)
- **Principios** (componentes presentacionales, container, etc.)

### 6.2 Definición de Props e Interfaces (TypeScript)
- Tipos para props y estados
- Uso de `React.FC` o funciones anónimas

### 6.3 Manejo de Estado
- **MobX-State-Tree** / Redux / Zustand / Context API (según corresponda)
- **Estructura del store**, acciones, etc.

## 7. Integraciones
### 7.1 Integración con APIs
- **Apisauce, Axios u otro** (endpoints, headers, manejo de respuestas)
- **Manejo de errores** (retry, timeouts, logs)

### 7.2 Expo Plugins
- **Config plugins** (por ejemplo, SplashScreen, Fonts, SecureStore, etc.)
- **Configuración en app.config.ts** o app.json

### 7.3 Otros Servicios Externos (Auth, notificaciones push, analítica)
- Uso de Firebase, AWS Amplify, etc. (si aplica)
- Configuración de llaves y entornos

## 8. EAS (Expo Application Services)
- **Flujo de builds**: desarrollo, preview, producción
- **Configuraciones en eas.json** (perfiles de build)
- **Configuración de variables de entorno** (si aplica)
- **Distribución en iOS y Android** (TestFlight, Play Internal Testing)

## 9. Accesibilidad
- **Lineamientos** (uso de `accessibilityLabel`, `importantForAccessibility`)
- **Soporte de screen readers** (VoiceOver, TalkBack)
- **Pruebas de accesibilidad**

## 10. Pruebas
### 10.1 Pruebas Unitarias y de Componentes
- **Jest** (estructura de test, coverage)
- **React Native Testing Library** (pruebas de componentes, snapshots)
- Ejemplos de casos de prueba

### 10.2 Pruebas E2E (Maestro / Detox / etc.)
- Configuración de scripts
- Flujos clave a probar
- Entornos de test

## 11. Internacionalización (opcional, si aplica)
- **Configuración de i18n** (react-i18next o librería elegida)
- **Cómo agregar nuevos idiomas**
- **Manejo de strings y fallback**

## 12. Estrategia de Publicación
- **App Stores** (descripción breve del proceso)
- **Versionado** (semver, convención interna)
- **Automatización con EAS** (canales de release, etc.)

## 13. Manejo de Assets
- **Íconos, imágenes y fuentes** (dónde se ubican, cómo se cargan)
- **Optimizaciones** (carga perezosa, compresión, `AutoImage`)

## 14. Optimización de Performance (opcional)
- **Uso de inlineRequires** en metro.config.js
- **Uso de memo, PureComponent** donde sea relevante
- **Seguimiento de rendimiento** (flipper, logs)

## 15. Checklist Final y Notas Adicionales
- **Resumen de librerías críticas** (versiones, link a docs)
- **Pendientes y riesgos** (si existen aspectos no resueltos)
- **Glosario / Siglas** (si el proyecto lo requiere)

Asegúrate de que tu especificación final sea muy detallada, proporcionando guía de implementación específica cuando sea posible. Incluye ejemplos concretos de código para funcionalidades complejas (por ejemplo, configuración de `<Stack.Navigator>` o un snippet de la store MST) y define claramente cómo se interrelacionan los componentes y pantallas.

Una vez que finalices, se usará esta especificación en un sistema AI de generación de código para construir la aplicación frontend en React Native con Expo.